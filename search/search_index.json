{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"IREE","text":"<p>IREE (Intermediate Representation Execution Environment1) is an MLIR-based end-to-end compiler and runtime that lowers Machine Learning (ML) models to a unified IR that scales up to meet the needs of the datacenter and down to satisfy the constraints and special considerations of mobile and edge deployments.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li> Ahead-of-time compilation of scheduling and execution logic together</li> <li> Support for dynamic shapes, flow control, streaming, and other advanced       model features</li> <li> Optimized for many CPU and GPU architectures</li> <li> Low overhead, pipelined execution for efficient power and resource usage</li> <li> Binary size as low as 30KB on embedded systems</li> <li> Debugging and profiling support</li> </ul>"},{"location":"#support-matrix","title":"Support matrix","text":"<p>IREE supports importing from a variety of ML frameworks:</p> <ul> <li> TensorFlow</li> <li> TensorFlow Lite</li> <li> JAX</li> <li> PyTorch</li> <li> ONNX (hoped for)</li> </ul> <p>The IREE compiler tools run on  Linux,  Windows, and  macOS and can generate efficient code for a variety of runtime platforms:</p> <ul> <li> Linux</li> <li> Windows</li> <li> Android</li> <li> macOS</li> <li> iOS</li> <li> Bare metal</li> <li> WebAssembly (planned)</li> </ul> <p>and architectures:</p> <ul> <li> ARM</li> <li> x86</li> <li> RISC-V</li> </ul> <p>Support for hardware accelerators and APIs is also included:</p> <ul> <li> Vulkan</li> <li> CUDA</li> <li> Metal (planned)</li> <li> WebGPU (planned)</li> </ul>"},{"location":"#project-architecture","title":"Project architecture","text":"<p>IREE adopts a holistic approach towards ML model compilation: the IR produced contains both the scheduling logic, required to communicate data dependencies to low-level parallel pipelined hardware/API like Vulkan, and the execution logic, encoding dense computation on the hardware in the form of hardware/API-specific binaries like SPIR-V.</p> <p> </p>"},{"location":"#workflow-overview","title":"Workflow overview","text":"<p>Using IREE involves the following general steps:</p> <ol> <li> <p>Import your model</p> <p>Develop your program using one of the supported frameworks, then import into IREE</p> </li> <li> <p>Select your deployment configuration</p> <p>Identify your target platform, accelerator(s), and other constraints</p> </li> <li> <p>Compile your model</p> <p>Compile through IREE, picking settings based on your deployment configuration</p> </li> <li> <p>Run your model</p> <p>Use IREE's runtime components to execute your compiled model</p> </li> </ol>"},{"location":"#importing-models-from-ml-frameworks","title":"Importing models from ML frameworks","text":"<p>IREE supports importing models from a growing list of ML frameworks and model formats:</p> <ul> <li>TensorFlow and   TensorFlow Lite</li> <li>JAX</li> <li>PyTorch</li> </ul>"},{"location":"#selecting-deployment-configurations","title":"Selecting deployment configurations","text":"<p>IREE provides a flexible set of tools for various deployment scenarios. Fully featured environments can use IREE for dynamic model deployments taking advantage of multi-threaded hardware, while embedded systems can bypass IREE's runtime entirely or interface with custom accelerators.</p> <ul> <li>What platforms are you targeting? Desktop? Mobile? An embedded system?</li> <li>What hardware should the bulk of your model run on? CPU? GPU?</li> <li>How fixed is your model itself? Can the weights be changed? Do you want   to support loading different model architectures dynamically?</li> </ul> <p>IREE supports the full set of these configurations using the same underlying technology.</p>"},{"location":"#compiling-models","title":"Compiling models","text":"<p>Model compilation is performed ahead-of-time on a host machine for any combination of targets. The compilation process converts from layers and operators used by high level frameworks down into optimized native code and associated scheduling logic.</p> <p>For example, compiling for GPU execution using Vulkan generates SPIR-V kernels and Vulkan API calls. For CPU execution, native code with static or dynamic linkage and the associated function calls are generated.</p>"},{"location":"#running-models","title":"Running models","text":"<p>IREE offers a low level C API, as well as several sets of API bindings for compiling and running programs using various languages.</p>"},{"location":"#communication-channels","title":"Communication channels","text":"<ul> <li> GitHub issues: Feature requests,   bugs, and other work tracking</li> <li> IREE Discord server: Daily development   discussions with the core team and collaborators</li> <li> iree-discuss email list:   Announcements, general and low-priority discussion</li> </ul>"},{"location":"#roadmap","title":"Roadmap","text":"<p>IREE is in the early stages of development and is not yet ready for broad adoption. We use both GitHub Projects and GitHub Milestones to track progress.</p> <ol> <li> <p>Pronounced \"eerie\" and often styled with the   emoji\u00a0\u21a9</p> </li> </ol>"},{"location":"building-from-source/","title":"Building from source","text":"<p>While IREE does offer binary distributions for its compiler tools and Python bindings, building from source is still useful when using IREE's runtime or when making changes to the compiler or import tools themselves.</p>"},{"location":"building-from-source/#reference-pages","title":"Reference pages","text":"<ul> <li>Getting started</li> <li>Android cross-compilation</li> <li>iOS cross-compilation</li> <li>RISC-V cross-compilation</li> </ul>"},{"location":"building-from-source/android/","title":"Android cross-compilation","text":"<p>Running on a platform like Android involves cross-compiling from a host platform (e.g. Linux) to a target platform (a specific Android version and system architecture):</p> <ul> <li>IREE's compiler is built on the host and is used there to generate modules   for the target</li> <li>IREE's runtime is built on the host for the target. The runtime is then   either pushed to the target to run natively or is bundled into an Android   APK</li> </ul>","tags":["Android"]},{"location":"building-from-source/android/#prerequisites","title":"Prerequisites","text":"","tags":["Android"]},{"location":"building-from-source/android/#host-environment-setup","title":"Host environment setup","text":"<p>You should already be able to build IREE from source on your host platform. Please make sure you have followed the getting started steps.</p>","tags":["Android"]},{"location":"building-from-source/android/#install-android-ndk-and-adb","title":"Install Android NDK and ADB","text":"<p>The Android Native Developer Kit (NDK) is needed to use native C/C++ code on Android. You can download it here, or, if you have installed Android Studio, you can follow this guide instead.</p> <p>Note</p> <p>Make sure the <code>ANDROID_NDK</code> environment variable is set after installing the NDK.</p> <p>ADB (the Android Debug Bridge) is also needed to communicate with Android devices from the command line. Install it following the official user guide.</p>","tags":["Android"]},{"location":"building-from-source/android/#configure-and-build","title":"Configure and build","text":"","tags":["Android"]},{"location":"building-from-source/android/#host-configuration","title":"Host configuration","text":"<p>Build and install on your host machine:</p> <pre><code>cmake -GNinja -B ../iree-build/ \\\n-DCMAKE_INSTALL_PREFIX=../iree-build/install \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n.\ncmake --build ../iree-build/ --target install\n</code></pre>","tags":["Android"]},{"location":"building-from-source/android/#target-configuration","title":"Target configuration","text":"<p>Build the runtime using the Android NDK toolchain:</p> LinuxmacOSWindows <pre><code>cmake -GNinja -B ../iree-build-android/ \\\n-DCMAKE_TOOLCHAIN_FILE=\"${ANDROID_NDK?}/build/cmake/android.toolchain.cmake\" \\\n-DIREE_HOST_BIN_DIR=\"$PWD/../iree-build/install/bin\" \\\n-DANDROID_ABI=\"arm64-v8a\" \\\n-DANDROID_PLATFORM=\"android-29\" \\\n-DIREE_BUILD_COMPILER=OFF \\\n.\ncmake --build ../iree-build-android/\n</code></pre> <pre><code>cmake -GNinja -B ../iree-build-android/ \\\n-DCMAKE_TOOLCHAIN_FILE=\"${ANDROID_NDK?}/build/cmake/android.toolchain.cmake\" \\\n-DIREE_HOST_BIN_DIR=\"$PWD/../iree-build/install/bin\" \\\n-DANDROID_ABI=\"arm64-v8a\" \\\n-DANDROID_PLATFORM=\"android-29\" \\\n-DIREE_BUILD_COMPILER=OFF \\\n.\ncmake --build ../iree-build-android/\n</code></pre> <pre><code>cmake -GNinja -B ../iree-build-android/ \\\n-DCMAKE_TOOLCHAIN_FILE=\"%ANDROID_NDK%/build/cmake/android.toolchain.cmake\" \\\n-DIREE_HOST_BIN_DIR=\"%CD%/../iree-build/install/bin\" \\\n-DANDROID_ABI=\"arm64-v8a\" \\\n-DANDROID_PLATFORM=\"android-29\" \\\n-DIREE_BUILD_COMPILER=OFF \\\n.\ncmake --build ../iree-build-android/\n</code></pre> <p>Note</p> <p>See the Android NDK CMake guide and Android Studio CMake guide for details on configuring CMake for Android.</p> <p>The specific <code>ANDROID_ABI</code> and <code>ANDROID_PLATFORM</code> used should match your target device.</p>","tags":["Android"]},{"location":"building-from-source/android/#running-android-tests","title":"Running Android tests","text":"<p>Make sure you enable developer options and USB debugging on your Android device and can see your it when you run <code>adb devices</code>, then run all built tests through CTest:</p> <pre><code>ctest --test-dir ../iree-build-android/ --output-on-failure\n</code></pre> <p>This will automatically upload build artifacts to the connected Android device, run the tests, then report the status back to your host machine.</p>","tags":["Android"]},{"location":"building-from-source/android/#running-tools-directly","title":"Running tools directly","text":"<p>Invoke the host compiler tools to produce a bytecode module FlatBuffer:</p> <pre><code>../iree-build/install/bin/iree-compile \\\n--iree-hal-target-backends=vmvx \\\nsamples/models/simple_abs.mlir \\\n-o /tmp/simple_abs_vmvx.vmfb\n</code></pre> <p>Push the Android runtime tools to the device, along with any FlatBuffer files:</p> <pre><code>adb push ../iree-build-android/tools/iree-run-module /data/local/tmp/\nadb shell chmod +x /data/local/tmp/iree-run-module\nadb push /tmp/simple_abs_vmvx.vmfb /data/local/tmp/\n</code></pre> <p>Run the tool:</p> <pre><code>adb shell /data/local/tmp/iree-run-module --device=local-task \\\n--module=/data/local/tmp/simple_abs_vmvx.vmfb \\\n--function=abs \\\n--input=\"f32=-5\"\n</code></pre>","tags":["Android"]},{"location":"building-from-source/getting-started/","title":"Getting started","text":""},{"location":"building-from-source/getting-started/#prerequisites","title":"Prerequisites","text":"<p>IREE can be built from source using CMake. We also recommend the Ninja CMake generator and the clang or MSVC C/C++ compilers.</p> Note - Other CMake generators and compilers <p>IREE developers and CIs primarily use Ninja, clang, and MSVC. Other configurations (including the Makefile generator and gcc) are \"best effort\". Patches to improve support are always welcome.</p> LinuxmacOSWindows <ol> <li> <p>Install a compiler/linker (typically \"clang\" and \"lld\" package)</p> </li> <li> <p>Install CMake (typically \"cmake\" package)</p> </li> <li> <p>Install Ninja (typically \"ninja-build\"    package)</p> </li> </ol> <p>On Debian/Ubuntu:</p> <pre><code>sudo apt install cmake ninja-build clang lld\n</code></pre> <ol> <li> <p>Install CMake</p> </li> <li> <p>Install Ninja</p> </li> </ol> <p>If using Homebrew:</p> <pre><code>brew install cmake ninja\n</code></pre> <ol> <li> <p>Install MSVC from Visual Studio or \"Tools for Visual Studio\" on the    official downloads page</p> </li> <li> <p>Install CMake from the    official downloads page</p> </li> <li> <p>Install Ninja from the official site</p> </li> </ol> <p>Note</p> <p>Initialize MSVC by running <code>vcvarsall.bat</code> to build on the command line. See the official documentation for details.</p>"},{"location":"building-from-source/getting-started/#quickstart-clone-and-build","title":"Quickstart: clone and build","text":"<p>Use Git to clone the IREE repository and initialize its submodules:</p> <pre><code>git clone https://github.com/openxla/iree.git\ncd iree\ngit submodule update --init\n</code></pre> <p>The most basic CMake workflow is:</p> <pre><code># Configure\ncmake -G Ninja -B ../iree-build/ .\n\n# Build\ncmake --build ../iree-build/\n</code></pre> <p>Caution - slow builds</p> <p>The compiler build is complex. You will want a powerful machine and to tune the settings following the next section. In 2023, we've seen builds take around 5-10 minutes on 64-core Linux machines.</p> <p>Use case permitting, disabling the compiler build with <code>-DIREE_BUILD_COMPILER=OFF</code> will drastically simplify the build.</p>"},{"location":"building-from-source/getting-started/#configuration-settings","title":"Configuration settings","text":"<p>The configure step should be customized for your build environment. These settings can improve compile and link times substantially.</p> LinuxmacOSWindows <pre><code># Recommended development options using clang and lld:\ncmake -G Ninja -B ../iree-build/ -S . \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DIREE_ENABLE_ASSERTIONS=ON \\\n-DIREE_ENABLE_SPLIT_DWARF=ON \\\n-DIREE_ENABLE_THIN_ARCHIVES=ON \\\n-DCMAKE_C_COMPILER=clang \\\n-DCMAKE_CXX_COMPILER=clang++ \\\n-DIREE_ENABLE_LLD=ON\n</code></pre> <pre><code># Recommended development options using clang and lld:\ncmake -G Ninja -B ../iree-build/ -S . \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DIREE_ENABLE_ASSERTIONS=ON \\\n-DIREE_ENABLE_SPLIT_DWARF=ON \\\n-DIREE_ENABLE_THIN_ARCHIVES=ON \\\n-DCMAKE_C_COMPILER=clang \\\n-DCMAKE_CXX_COMPILER=clang++ \\\n-DIREE_ENABLE_LLD=ON\n</code></pre> <pre><code># Recommended development options:\ncmake -G Ninja -B ../iree-build/ -S . \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DIREE_ENABLE_ASSERTIONS=ON\n</code></pre> Tip - CMAKE_BUILD_TYPE values <p>We recommend using the <code>RelWithDebInfo</code> build type by default for a good balance of debug info and performance. The <code>Debug</code>, <code>Release</code>, and <code>MinSizeRel</code> build types are useful in more specific cases. Note that several useful LLVM debugging features are only available in <code>Debug</code> builds. See the official CMake documentation for general details.</p> Tip - Faster recompilation with ccache <p>We recommend using <code>ccache</code> with CMake, especially when rebuilding the compiler. To use it, configure CMake with:</p> <pre><code>-DCMAKE_C_COMPILER_LAUNCHER=ccache -DCMAKE_CXX_COMPILER_LAUNCHER=ccache\n</code></pre> <p>See also our developer documentation for ccache.</p>"},{"location":"building-from-source/getting-started/#optional-components","title":"Optional components","text":"<p>By default, the CMake build includes:</p> <ul> <li>All compiler targets (<code>llvm-cpu</code>, <code>cuda</code>, <code>vulkan-spirv</code>, etc.)</li> <li>All runtime HAL drivers (<code>local-task</code>, <code>cuda</code>, <code>vulkan</code>, etc.)</li> <li>All compiler input formats (StableHLO, TOSA, etc.)</li> <li>All compiler output formats (VM bytecode, C)</li> </ul> <p>The default build does not include:</p> <ul> <li>Compiler or runtime bindings (Python, TFLite, etc.)</li> <li>Advanced features like AddressSanitizer or tracing instrumentation</li> <li>Experimental components</li> </ul> <p>These can be changed via the <code>IREE_</code> CMake options listed in the root <code>CMakeLists.txt</code>.</p>"},{"location":"building-from-source/getting-started/#extensions-and-integrations","title":"Extensions and integrations","text":"<p>When using IREE within other projects, you can register compiler plugins and runtime HAL drivers. You can also bring your own copy of LLVM and some other tools. See the root <code>CMakeLists.txt</code> for details.</p>"},{"location":"building-from-source/getting-started/#tests-and-samples","title":"Tests and samples","text":""},{"location":"building-from-source/getting-started/#running-tests","title":"Running tests","text":"<p>Tests are run via ctest. To build and run the core project tests:</p> <pre><code># Build default targets\ncmake --build ../iree-build/\n\n# Run tests\nctest --test-dir ../iree-build/\n</code></pre> <p>Caution</p> <p>This has two limitations:</p> <ol> <li>Large tests are excluded from the build by default</li> <li>Some tests require hardware like a GPU and will fail on unsupported systems</li> </ol> <p>To build and then run all tests:</p> <pre><code># 1. Build default targets\ncmake --build ../iree-build/\n\n# 2. Build test dependencies\ncmake --build ../iree-build/ --target iree-test-deps\n\n# 3. Run tests\nctest --test-dir ../iree-build/\n\n\n# Or combine all steps using a utility target\ncmake --build ../iree-build --target iree-run-tests\n</code></pre> <p>To run only certain tests, we have a helper script that converts environment variables into ctest filters:</p> <pre><code># Run default tests\n./build_tools/cmake/ctest_all.sh\n\n# Run tests, turning CUDA on and Vulkan off\nexport IREE_CUDA_DISABLE=0\nexport IREE_VULKAN_DISABLE=1\n./build_tools/cmake/ctest_all.sh\n</code></pre>"},{"location":"building-from-source/getting-started/#running-samples","title":"Running samples","text":"<pre><code># Build\ncmake --build ../iree-build/\n\n# Run a standalone sample application\n../iree-build/runtime/src/iree/runtime/demo/hello_world_embedded\n# 4xf32=1 1.1 1.2 1.3\n#  *\n# 4xf32=10 100 1000 10000\n#  =\n# 4xf32=10 110 1200 13000\n\n# Try out the developer tools\nls ../iree-build/tools/\n../iree-build/tools/iree-compile --help\n../iree-build/tools/iree-run-module --help\n</code></pre>"},{"location":"building-from-source/getting-started/#python-bindings","title":"Python bindings","text":"<p>Python packages can either be built from source or installed from our releases. See the Python bindings page for details about the bindings themselves.</p>"},{"location":"building-from-source/getting-started/#dependencies","title":"Dependencies","text":"<p>You will need a recent Python installation &gt;=3.8 (we aim to support non-eol Python versions).</p> Tip - Managing Python versions <p>Make sure your 'python' is what you expect:</p> LinuxmacOSWindows <p>Note that on multi-python systems, this may have a version suffix, and on many Linuxes where python2 and python3 can co-exist, you may also want to use <code>python3</code>.</p> <pre><code>which python\npython --version\n</code></pre> <p>Note that on multi-python systems, this may have a version suffix, and on macOS where python2 and python3 can co-exist, you may also want to use <code>python3</code>.</p> <pre><code>which python\npython --version\n</code></pre> <p>The Python launcher for Windows (<code>py</code>) can help manage versions.</p> <pre><code>which python\npython --version\npy --list-paths\n</code></pre> Tip - Virtual environments <p>We recommend using virtual environments to manage python packages, such as through <code>venv</code> (about, tutorial):</p> LinuxmacOSWindows <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre> <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre> <pre><code>python -m venv .venv\n.venv\\Scripts\\activate.bat\n</code></pre> <p>When done, run <code>deactivate</code>.</p> <pre><code># Upgrade PIP before installing other requirements\npython -m pip install --upgrade pip\n\n# Install IREE build requirements\npython -m pip install -r runtime/bindings/python/iree/runtime/build_requirements.txt\n</code></pre>"},{"location":"building-from-source/getting-started/#building-with-cmake","title":"Building with CMake","text":"<p>To build the Python bindings, configure CMake with the <code>IREE_BUILD_PYTHON_BINDINGS</code> option. We also recommend explicitly setting which Python executable to use with <code>Python3_EXECUTABLE</code>:</p> <pre><code># Configure (including other options as discussed above)\ncmake -G Ninja -B ../iree-build/ \\\n-DIREE_BUILD_PYTHON_BINDINGS=ON  \\\n-DPython3_EXECUTABLE=\"$(which python)\" \\\n.\n\n# Build\ncmake --build ../iree-build/\n</code></pre>"},{"location":"building-from-source/getting-started/#using-the-python-bindings","title":"Using the Python bindings","text":"<p>Extend your <code>PYTHONPATH</code> with IREE's <code>bindings/python</code> paths and try importing:</p> LinuxmacOSWindows <pre><code>source ../iree-build/.env &amp;&amp; export PYTHONPATH\npython -c \"import iree.compiler\"\npython -c \"import iree.runtime\"\n</code></pre> <pre><code>source ../iree-build/.env &amp;&amp; export PYTHONPATH\npython -c \"import iree.compiler\"\npython -c \"import iree.runtime\"\n</code></pre> <pre><code>../iree-build/.env.bat\npython -c \"import iree.compiler\"\npython -c \"import iree.runtime\"\n</code></pre> <p>Using IREE's ML framework importers requires a few extra steps:</p> <pre><code># Install test requirements\npython -m pip install -r integrations/tensorflow/test/requirements.txt\n\n# Install pure Python packages (no build required)\npython -m pip install integrations/tensorflow/python_projects/iree_tf\npython -m pip install integrations/tensorflow/python_projects/iree_tflite\n\n# Then test the tools:\niree-import-tf --help\niree-import-tflite --help\n</code></pre>"},{"location":"building-from-source/ios/","title":"iOS cross-compilation","text":"<p>Cross-compilation for iOS consists of the two steps below.</p> <ul> <li>On the macOS host, build the IREE compiler.  We can run it to create   IREE modules.</li> <li>Build the IREE runtime on the macOS host for iOS devices and the   simulator.  We can then run the IREE module on the simulator.</li> </ul>","tags":["iOS"]},{"location":"building-from-source/ios/#prerequisites","title":"Prerequisites","text":"","tags":["iOS"]},{"location":"building-from-source/ios/#install-xcode-and-ios-sdk","title":"Install Xcode and iOS SDK","text":"<p>For cross-compilation, you need Xcode. It comes with the SDKs for iOS devices and the simulator, as well as the <code>simctl</code> tool for controlling the simulator from the command line.</p>","tags":["iOS"]},{"location":"building-from-source/ios/#host-environment-setup","title":"Host environment setup","text":"<p>On your host platform, you should already be able to build IREE from source.  Please make sure you've gone through the steps in getting started.</p>","tags":["iOS"]},{"location":"building-from-source/ios/#configure-and-build","title":"Configure and Build","text":"","tags":["iOS"]},{"location":"building-from-source/ios/#build-the-iree-compiler-for-the-host","title":"Build the IREE Compiler for the Host","text":"<p>Build and install on your macOS host:</p> <pre><code>cmake -S . -B ../iree-build/ -GNinja \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n-DCMAKE_INSTALL_PREFIX=../iree-build/install\n\ncmake --build ../iree-build/ --target install\n</code></pre>","tags":["iOS"]},{"location":"building-from-source/ios/#cross-compile-the-iree-runtime-for-ios","title":"Cross-compile the IREE Runtime for iOS","text":"<p>Build the runtime for the iOS Simulator.</p> <pre><code>cmake -S . -B ../build-ios-sim -GNinja \\\n-DCMAKE_SYSTEM_NAME=iOS \\\n-DCMAKE_OSX_SYSROOT=$(xcodebuild -version -sdk iphonesimulator Path) \\\n-DCMAKE_OSX_ARCHITECTURES=arm64 \\\n-DCMAKE_SYSTEM_PROCESSOR=arm64 \\\n-DCMAKE_OSX_DEPLOYMENT_TARGET=11.0 \\\n-DCMAKE_IOS_INSTALL_COMBINED=YES \\\n-DIREE_HOST_BIN_DIR=\"$PWD/../iree-build/install/bin\" \\\n-DCMAKE_INSTALL_PREFIX=../build-ios-sim/install \\\n-DIREE_BUILD_COMPILER=OFF\n\ncmake --build ../build-ios-sim --config Release --target install\n</code></pre> <p>Or, we can build the runtime for iOS devices it by changing the value of the <code>-DCMAKE OSX SYSROOT</code> option to:</p> <pre><code>  -DCMAKE_OSX_SYSROOT=$(xcodebuild -version -sdk iphoneos Path)\n</code></pre>","tags":["iOS"]},{"location":"building-from-source/ios/#running-iree-modules-on-the-ios-simulator","title":"Running IREE Modules on the iOS Simulator","text":"<p>Run the IREE compiler on the host to generate a module.</p> <pre><code>../iree-build/install/bin/iree-compile \\\n--iree-hal-target-backends=vmvx \\\nsamples/models/simple_abs.mlir \\\n-o /tmp/simple_abs_vmvx.vmfb\n</code></pre> <p>We could test the generated module by running the macOS version of <code>iree-run-module</code> on the host.</p> <pre><code>../iree-build/install/bin/iree-run-module \\\n--module=/tmp/simple_abs_vmvx.vmfb \\\n--device=local-task \\\n--function=abs \\\n--input=\"f32=-5\"\n</code></pre> <p>To run it on the iOS simulator, we need to copy the vmfb file into the <code>iree-run-module</code> iOS app bundle.</p> <pre><code>cp /tmp/simple_abs_vmvx.vmfb \\\n../build-ios-sim/install/bin/iree-run-module.app/\n</code></pre> <p>Open the iOS Simulator Manager on the host.</p> <pre><code>open -a Simulator\n</code></pre> <p>After creating and booting a simulator in this app, you can list it from the command-line.</p> <pre><code>xcrun simctl list devices | grep Booted\n</code></pre> <p>This is what should come out of the command:</p> <pre><code>    iPhone 14 Pro (12341234-ABCD-ABCD-ABCD-123412341234) (Booted)\n</code></pre> <p>where <code>iPhone 14 Pro</code> is the device being simulated and <code>12341234-ABCD-ABCD-ABCD-123412341234</code> is the simulator's unique device ID (UDID).</p> <p>Install the app <code>iree-run-module</code> on the simulator, given its UDID.</p> <pre><code>xcrun simctl install &lt;UDID&gt; ../build-ios-sim/install/bin/iree-run-module.app\n</code></pre> <p>Check the path to the installed bundle, where the <code>simple_abs_vmvx.vmfb</code> module should be found.</p> <pre><code>ls $(xcrun simctl get_app_container &lt;UDID&gt; dev.iree.iree-run-module)\n</code></pre> <p>The string <code>dev.iree.iree-run-module</code> is the bundle identifier of the iOS app.  The CMake building process generates it and saves it in the property list (plist) file <code>../build-ios-sim/install/bin/iree-run-module.app/Info.plist</code>.</p> <p>Launch the <code>iree-run-module</code> app on the simulator to run the IREE module <code>simple_abs_vmvx.vmfb</code>.</p> <pre><code>xcrun simctl launch --console \\\n&lt;UDID&gt; \\\ndev.iree.runmodule \\\n--device=local-task \\\n--function=abs \\\n--input=\"f32=-5\" \\\n--module=$(xcrun simctl get_app_container &lt;UDID&gt; dev.iree.iree-run-module)/simple_abs_vmvx.vmfb\n</code></pre>","tags":["iOS"]},{"location":"building-from-source/riscv/","title":"RISC-V cross-compilation","text":"<p>Running on a platform like RISC-V involves cross-compiling from a host platform (e.g. Linux) to a target platform (a specific RISC-V CPU architecture and operating system):</p> <ul> <li>IREE's compiler is built on the host and is used there to generate modules   for the target</li> <li>IREE's runtime is built on the host for the target. The runtime is then   pushed to the target to run natively.</li> </ul>","tags":["CPU"]},{"location":"building-from-source/riscv/#prerequisites","title":"Prerequisites","text":"","tags":["CPU"]},{"location":"building-from-source/riscv/#host-environment-setup","title":"Host environment setup","text":"<p>You should already be able to build IREE from source on your host platform. Please make sure you have followed the getting started steps.</p>","tags":["CPU"]},{"location":"building-from-source/riscv/#install-risc-v-cross-compile-toolchain-and-emulator","title":"Install RISC-V cross-compile toolchain and emulator","text":"<p>You'll need a RISC-V LLVM compilation toolchain and a RISC-V enabled QEMU emulator.</p> <p>See instructions in the following links</p> <ul> <li>Clang getting started</li> <li>RISC-V GNU toolchain</li> <li>QEMU</li> <li>RISC-V Linux QEMU</li> </ul> <p>Note</p> <p>The <code>RISCV_TOOLCHAIN_ROOT</code> environment variable needs to be set to the root directory of the installed GNU toolchain when building the RISC-V compiler target and the runtime library.</p>","tags":["CPU"]},{"location":"building-from-source/riscv/#install-prebuilt-risc-v-tools-risc-v-64-bit-linux-toolchain","title":"Install prebuilt RISC-V tools (RISC-V 64-bit Linux toolchain)","text":"<p>Execute the following script to download the prebuilt RISC-V toolchain and QEMU from the IREE root directory:</p> <pre><code>./build_tools/riscv/riscv_bootstrap.sh\n</code></pre>","tags":["CPU"]},{"location":"building-from-source/riscv/#support-vector-extension","title":"Support vector extension","text":"<p>For RISC-V vector extensions support, see additional instructions</p>","tags":["CPU"]},{"location":"building-from-source/riscv/#configure-and-build","title":"Configure and build","text":"","tags":["CPU"]},{"location":"building-from-source/riscv/#host-configuration","title":"Host configuration","text":"<p>Build and install on your host machine:</p> <pre><code>cmake -GNinja -B ../iree-build/ \\\n-DCMAKE_C_COMPILER=clang \\\n-DCMAKE_CXX_COMPILER=clang++ \\\n-DCMAKE_INSTALL_PREFIX=../iree-build/install \\\n-DCMAKE_BUILD_TYPE=RelWithDebInfo \\\n.\ncmake --build ../iree-build/ --target install\n</code></pre>","tags":["CPU"]},{"location":"building-from-source/riscv/#target-configuration","title":"Target configuration","text":"<p>The following instruction shows how to build for a RISC-V 64-bit Linux machine. For other RISC-V targets, please refer to riscv.toolchain.cmake as a reference of how to set up the cmake configuration.</p>","tags":["CPU"]},{"location":"building-from-source/riscv/#risc-v-64-bit-linux-target","title":"RISC-V 64-bit Linux target","text":"<pre><code>cmake -GNinja -B ../iree-build-riscv/ \\\n-DCMAKE_TOOLCHAIN_FILE=\"./build_tools/cmake/riscv.toolchain.cmake\" \\\n-DIREE_HOST_BIN_DIR=$(realpath ../iree-build/install/bin) \\\n-DRISCV_CPU=linux-riscv_64 \\\n-DIREE_BUILD_COMPILER=OFF \\\n-DRISCV_TOOLCHAIN_ROOT=${RISCV_TOOLCHAIN_ROOT} \\\n-DIREE_ENABLE_CPUINFO=OFF \\\n.\ncmake --build ../iree-build-riscv/\n</code></pre>","tags":["CPU"]},{"location":"building-from-source/riscv/#running-iree-bytecode-modules-on-the-risc-v-system","title":"Running IREE bytecode modules on the RISC-V system","text":"<p>Note</p> <p>The following instructions are meant for the RISC-V 64-bit Linux target. For the bare-metal target, please refer to simple_embedding to see how to build a ML workload for a bare-metal machine.</p> <p>Set the path to qemu-riscv64 Linux emulator binary in the <code>QEMU_BIN</code> environment variable. If it is installed with <code>riscv_bootstrap.sh</code>, the path is default at ${HOME}/riscv/qemu/linux/RISCV/bin/qemu-riscv64.</p> <pre><code>export QEMU_BIN=&lt;path to qemu-riscv64 binary&gt;\n</code></pre> <p>Invoke the host compiler tools to produce a bytecode module FlatBuffer:</p> <pre><code>../iree-build/install/bin/iree-compile \\\n--iree-hal-target-backends=vmvx \\\nsamples/models/simple_abs.mlir \\\n-o /tmp/simple_abs_vmvx.vmfb\n</code></pre> <p>Run the RISC-V emulation:</p> <pre><code>${QEMU_BIN} \\\n-cpu rv64 \\\n-L ${RISCV_TOOLCHAIN_ROOT}/sysroot/ \\\n../iree-build-riscv/tools/iree-run-module \\\n--device=local-task \\\n--module=/tmp/simple_abs_vmvx.vmfb \\\n--function=abs \\\n--input=f32=-5\n</code></pre>","tags":["CPU"]},{"location":"building-from-source/riscv/#optional-configuration","title":"Optional configuration","text":"<p>RISC-V Vector extensions allows SIMD  code to run more efficiently. To enable the vector extension for the compiler  toolchain and the emulator, build the tools from the following sources:</p> <ul> <li>RISC-V toolchain is built from https://github.com/llvm/llvm-project (main branch).<ul> <li>Currently, the LLVM compiler is built on GNU toolchain, including libgcc,   GNU linker, and C libraries. You need to build GNU toolchain first.</li> <li>Clone GNU toolchain from:   https://github.com/riscv/riscv-gnu-toolchain   (master branch). Switch the \"riscv-binutils\" submodule to   <code>git://sourceware.org/git/binutils-gdb.git</code> (master branch) manually.</li> </ul> </li> <li>RISC-V QEMU is built from https://github.com/sifive/qemu/tree/v5.2.0-rvv-rvb-zfh.</li> </ul> <p>The SIMD code can be generated following the IREE CPU flow with the additional command-line flags</p> <pre><code>tools/iree-compile \\\n--iree-hal-target-backends=llvm-cpu \\\n--iree-llvmcpu-target-triple=riscv64 \\\n--iree-llvmcpu-target-cpu=generic-rv64 \\\n--iree-llvmcpu-target-abi=lp64d \\\n--iree-llvmcpu-target-cpu-features=\"+m,+a,+f,+d,+zvl512b,+v\" \\\n--riscv-v-fixed-length-vector-lmul-max=8 \\\niree_input.mlir -o mobilenet_cpu.vmfb\n</code></pre> <p>Then run on the RISC-V QEMU:</p> <pre><code>${QEMU_BIN} \\\n-cpu rv64,x-v=true,x-k=true,vlen=512,elen=64,vext_spec=v1.0 \\\n-L ${RISCV_TOOLCHAIN_ROOT}/sysroot/ \\\n../iree-build-riscv/tools/iree-run-module \\\n--device=local-task \\\n--module=mobilenet_cpu.vmfb \\\n--function=predict \\\n--input=\"1x224x224x3xf32=0\"\n</code></pre>","tags":["CPU"]},{"location":"community/","title":"Community projects","text":"<p>Projects built by community members:</p> <ul> <li> <p>The SHARK project from   nod.ai uses a forked version of IREE   (SHARK-Runtime), offering   highly tuned performance on a large corpus of machine learning programs.</p> </li> <li> <p>The IREE Bare-Metal Arm Sample   shows how to build IREE with the   Arm GNU Toolchain   for bare-metal Arm targets using the open-source firmware libraries   CMSIS and   libopencm3.</p> </li> <li> <p>The IREE C++ Template   shows one way to integrate IREE's runtime into a project with CMake.</p> </li> </ul> <p>Official repositories:</p> <ul> <li> <p>iree-jax is home to   IREE's support for JAX programs.</p> </li> <li> <p>iree-torch contains   IREE's PyTorch frontend, leveraging the   torch-mlir project.</p> </li> <li> <p>iree-samples   includes various samples and prototypes built with IREE.</p> </li> <li> <p>iree-llvm-sandbox   contains experimental work by the IREE team closely related to LLVM and   MLIR, usually with the aim of contributing back to those upstream projects.</p> </li> </ul>"},{"location":"community/blog/","title":"Blog","text":"<p>Latest posts from the IREE team</p> <ul> <li>2021-10-15: CUDA backend</li> <li>2021-10-13: Work in progress on Matrix Multiplication on CPU</li> <li>2021-07-19: TFLite Support via TOSA</li> </ul>"},{"location":"community/blog/2021-07-19-tflite-tosa/","title":"TFLite Support via TOSA","text":"<p>Monday, July 19, 2021 By Rob Suderman and Jenni Kilduff</p>","tags":["TensorFlow"]},{"location":"community/blog/2021-07-19-tflite-tosa/#tflite-support-via-tosa","title":"TFLite Support via TOSA","text":"<p>IREE can now execute TensorFlow Lite (TFLite) models through the use of TOSA, an open standard of common tensor operations, and a part of MLIR core. TOSA\u2019s high-level representation of tensor operations provides a common front-end for ingesting models from different frameworks. In this case we ingest a TFLite FlatBuffer and compile it to TOSA IR, which IREE takes as an input format to compile to its various backends.</p> <p></p> <p>Using TFLite as a frontend for IREE provides an alternative ingestion method for already existing models that could benefit from IREE\u2019s design. This enables models already designed for on-device inference to have an alternative path for execution without requiring any additional porting, while benefiting from IREE\u2019s improvements in buffer management, work dispatch system, and compact binary format. With continued improvements to IREE/MLIR\u2019s compilation performance, more optimized versions can be compiled and distributed to target devices without an update to the clientside environment.</p> <p>Today, we have validated floating point support for a variety of models, including mobilenet (v1, v2, and v3) and mobilebert. More work is in progress to support fully quantized models, and TFLite\u2019s hybrid quantization, along with dynamic shape support.</p>","tags":["TensorFlow"]},{"location":"community/blog/2021-07-19-tflite-tosa/#examples","title":"Examples","text":"<p>TFLite with IREE is available in Python and Java.  We have a colab notebook that shows how to use IREE\u2019s python bindings and TFLite compiler tools to compile a pre-trained TFLite model from a FlatBuffer and run using IREE.  We also have an Android Java app that was forked from an existing TFLite demo app, swapping out the TFLite library for our own AAR.  More information on IREE\u2019s TFLite frontend is available here.</p>","tags":["TensorFlow"]},{"location":"community/blog/2021-10-13-mmt4d/","title":"Work in progress on Matrix Multiplication on CPU","text":"<p>Wednesday, October 13, 2021 By Ahmed Taei, Benoit Jacob</p>","tags":["CPU"]},{"location":"community/blog/2021-10-13-mmt4d/#work-in-progress-on-matrix-multiplication-on-cpu","title":"Work in progress on Matrix Multiplication on CPU","text":"","tags":["CPU"]},{"location":"community/blog/2021-10-13-mmt4d/#introduction","title":"Introduction","text":"<p>Matrix multiplication (matmul) is an important operation in ML workloads that poses specific challenges to code generation. For example, matmul makes repeated accesses to the same data, which makes locality of reference a top concern.</p> <p>Moreover, modern CPUs instruction set architectures (ISAs) offer specialized SIMD instructions that the matmul implementation needs to use to achieve optimal performance, and these instructions expect data to be in a particular layout.</p> <p>This article is about an in-development MLIR operation, <code>linalg.mmt4d</code>, offering a compilation path for <code>linalg.matmul</code> that is designed from the ground up for these efficiency considerations.</p> <p>We are still in the early implementation phase of this <code>linalg.mmt4d</code> plan, but we feel confident that we know where we are going because what we are really doing here is importing into the compiler what we have learned working on optimized matrix multiplication libraries, particularly Ruy. We know what loop schedule and kernel we want the compiler to generate \u2014 essentially the same as we wrote in Ruy, give or take additional optimizations such as fusions and constant folding that become possible now that we are doing this within a compiler. This allows us to focus on how we get the compiler to generate that schedule and kernel with purely algebraic transformations that compose and enable further compiler optimizations.</p> <p>At the basis of this work is the extensible op system of the Linalg dialect in the MLIR compiler toolkit. In this case, a general purpose, mixed precision mmt4d op is defined via a high level description directly in the compiler and is then available to both users of the compiler (as a <code>linalg.mmt4d</code> op) or for direct emission via Python based IR construction (i.e. for direct integration into high level frameworks without rebuilding the compiler). The ability to define such new special forms cheaply, and without any systemic framework level cost, is part of the extensibility and composition story that we expect will become increasingly important in development and deployment scenarios in the future, and in this case, it let us spring board off of high quality code generation which was already well integrated and composed well with other features of the compiler.</p>","tags":["CPU"]},{"location":"community/blog/2021-10-13-mmt4d/#existing-matrix-multplication-code-generation","title":"Existing Matrix Multplication Code Generation","text":"<p>Let us start by discussing IREE\u2019s existing matmul code generation and highlight the issues that <code>mmt4d</code> aims to overcome.</p> <p>The existing approach operates in-place on the source matrices. When we discuss \"tiling\" in this paragraph, we refer exclusively to the traversal \u2014 how these source matrices are traversed by the matmul loop. There is no \"tiled layout\" here, which will be the key difference with <code>mmt4d</code> below.</p> <p>The destination matrix is tiled into workgroups (CPU threads) tiles, then each workgroup tile is tiled to fit some level of CPU cache, and finally each tile is further tiled to fit target architecture registers (e.g. 8x8).</p> <p>That multi-level tiling means that the code works like the following loop nest:</p> <pre><code>def tiled_matmul(A, B, C, tile_m, tile_n, tile_k, tile_m_v, tile_n_v, tile_k_v):\n m = A.shape[0]\n k = A.shape[1]\n n = B.shape[1]\n for m1 in range(0, m, tile_m):\n   for n1 in range(0, n, tile_n):\n     for k1 in range(0, k, tile_k):\n       # First level of tiling views...\n       lhs_tile = A[m1:m1+tile_m, k1:k1+tile_k]\n       rhs_tile = B[k1:k1+tile_k, n1:n1+tile_n]\n       dst_tile = C[m1:m1+tile_m, n1:n1+tile_n]\n       for mv in range(0, tile_m, tile_m_v):\n         for nv in range(0, tile_n, tile_n_v):\n           for kv in range(0, tile_k, tile_k_v):\n             # Register tiling views...\n             lhs_tile_v = lhs_tile[mv:mv+tile_m_v, kv:kv+tile_k_v]\n             rhs_tile_v = rhs_tile[kv:kv+tile_k_v, nv:nv+tile_n_v]\n             # kernel.\n             dst_tile[mv:mv+tile_m_v, nv:nv+tile_n_v] += np.matmul(lhs_tile_v, rhs_tile_v)\n return C\n</code></pre> <p>The two main problems with this approach are:</p> <ul> <li> <p>Overhead to meet SIMD ISA layout requirements: In practice, the kernel     needs to use specific SIMD     instructions to perform the arithmetic. They expect small tiles of the     matrices to be loaded in registers, in a specific layout. If the matrix data     wasn't already stored in memory in such a tiled layout, then the kernel has     to perform such a data rearrangement on the fly, incurring substantial     overhead. For NxN matrix multiplication, the kernel performs     O(N3) work on O(N2) data, so doing that rearrangement     there means O(N3) overhead where O(N2) should have     sufficed, as this could have been done as a pre-processing step on     O(N2) data.</p> </li> <li> <p>Inefficent memory traversal: For efficiency reasons, we always need     <code>tile_m_v&gt;1</code> and <code>tile_n_v&gt;1</code>. That is because the higher these values, the     fewer memory-load instructions are needed overall; and this is also dictated     by the SIMD instructions that we want to use. But that means that the kernel     is accessing simultaneously multiple rows or columns of the left-hand and     right-hand side matrices. And in this existing approach, they are stored in     linear layout, not in a tiled layout, so these accesses are not contiguous     in memory. This is detrimental to memory access performance, meaning the     CPU caches, in multiple ways. One     is that these multiple non-contiguous accesses may alias each other in the     L1 cache because of low     associativity.</p> </li> </ul>","tags":["CPU"]},{"location":"community/blog/2021-10-13-mmt4d/#matrix-multiplication-operation-with-4d-tiled-operands","title":"Matrix Multiplication Operation With 4D Tiled Operands","text":"<p>For the reasons above, an efficient matmul implementation must reorder data into a tiled layout matching the target SIMD ISA and making the memory access patterns as contiguous as possible.</p> <p>IREE/MLIR defaults to bufferizing all tensors into a \"row-major\" order, meaning that the last-enumerated dimension is the one that is contiguous in memory. As we prefer not to write custom bufferization code, we can't specify an alternative layout for a tensor. Fortunately, it is possible to represent a 2D tiled layout as a 4D layout. For example, <code>tensor&lt;2x2x2x2xf32&gt;</code> can represent a 4x4 matrix made of 2x2 tiles, each of which is 2x2. The row-major layout on <code>tensor&lt;2x2x2x2xf32&gt;</code> makes each 2x2 tile contiguous and row-major, and arranges the 2x2 tiles themselves into a row-major 2x2 layout in the overall 4x4 matrix.</p> <p>Such a row-major-tiled layout is exactly what we need for the left-hand side of a matrix multiplication, because matrix multiplication traverses the left-hand side matrix row by row. But for the right-hand side matrix, we want a column-major-tiled layout. To solve this problem, we decide to implement not matrix multiplication, but matrix-multiplication-by-transposed-right-hand-side which is where the <code>t</code> in the <code>linalg.mmt4d</code> came from. Now such an op is happy with both the left and right-hand sides being row-major-tiled.</p> <p>The following example illustrates that. In these diagrams, each matrix element is rendered its memory offset.</p> <p></p> <p>To compute the 2x2 block in the destination matrix, we will have to load two yellow blocks from LHS, RHS matrices respectively compute their matmul results (i.e. call the kernel), then the two blue blocks, and so on. As we can see, each tile loads data that is not contiguous. It would be better if we rearranged the elements in the following layout:</p> <p></p> <p>Now tiles are stored contiguously in memory and the kernel can simply load them from memory into the registers that will be directly consumed by the SIMD instructions performing the multiplications. Moreover, the kernel is now loading from just two contiguous data streams, a simple memory access pattern which is sure to be efficient (regarding caches, etc) on any reasonable target hardware.</p> <p>We introduce a <code>linalg.mmt4d</code> operation that performs such a matrix multiplication on matrices in a tiled layout represented as 4D tensors. That leaves the question of how to represent, within the linalg dialect, the conversions between ordinary matrices represented as 2D tensors, and these tiled matrices represented as 4D tensors. Moreover, these conversions should be tileable and decompose well. Thankfully, the transformation from 2D to 4D can be written as a reshape followed by a transpose as in the following digram:</p> <p></p> <p>So we can think of the outermost two dimensions of the 4D representations as the tile position in the overall matrix, and the innermost two as the element position within one tile. Hopefully the following Python pseudocode makes it more concrete:</p> <pre><code>def pack_2d_4d(operand, parallel_size, reduction_size):\n i1 = operand.shape[0] // parallel_size # M1\n i2 = parallel_size    # M0\n j1 = operand.shape[1] // reduction_size # K1\n j2 = reduction_size   # K0\n operand_4d = np.reshape(operand, [i1, i2, j1, j2])\n return np.transpose(operand_4d, [0, 2, 1, 3]) # [M1, K1, M0, K0]\n</code></pre> <p>Now the mmt4d operation will follow a structure as the multi level tiling, for simplicity we considered the case here where no L1 tiling is required only first level of distribution to workgroups:</p> <pre><code>def mmt4d(A, B, C, M0, N0, K0):\n M = A.shape[0]\n N = B.shape[1]\n Bt = np.transpose(B, [1, 0])\n A4d = pack_2d_4d(A, M0, K0)\n Bt4d = pack_2d_4d(Bt, N0, K0)\n M1 = A4d.shape[0]\n N1 = Bt4d.shape[0]\n K1 = A4d.shape[1]\n for m1 in range(0, M1):\n   for n1 in range(0, N1):\n     for k1 in range(0, K1):\n       # Tile views that are contiguous in memory.\n       lhs_tile = np.reshape(A4d[m1, k1, :, :], [M0, K0])\n       rhs_tile = np.reshape(Bt4d[n1, k1, :, :], [N0, K0])\n       # Inner kernel.\n       C[m1, n1, :, :] += np.matmul(lhs_tile, np.transpose(rhs_tile, [1, 0]))\n # 4d -&gt; 2D\n C2d = unpack_4d_2d(C)\n return C2d\n</code></pre> <p>The resulting 4D tiled matrix still needs be rearranged back to the original layout as 2D tensor:</p> <pre><code>def unpack_4d_2d(operand):\n i1 = operand.shape[0] # M1\n j1 = operand.shape[1] # N1\n i2 = operand.shape[2] # M0\n j2 = operand.shape[3] # N0\n operand_transposed = operand.transpose([0, 2, 1, 3]) # [M1, M0, N1, N0]\n return operand_transposed.reshape([i1 * i2, j1 * j2]) # [M, N]\n</code></pre>","tags":["CPU"]},{"location":"community/blog/2021-10-13-mmt4d/#performance-results","title":"Performance Results","text":"<p>We benchmarked various float32 matmul problems of different sizes and the result showed that mmt4d is faster than the existing matmul implementation for bigger matrices as we can see the in the following chart:</p> <p></p> <p>The SIMD instruction being used here is the simplest kind, a <code>vector*scalar</code> multiplication, and the storage orders of the matrices allow the existing implementation to directly load the vectors from the source matrices without any rearrangement overhead. So this case is particularly friendly to the existing code, which is why the mmt4d code is only faster for bigger matrices. To understand why mmt4d is faster in that case, we collected statistics of L1 cache misses:</p> <p></p> <p>This shows that in this case, the better cache-friendliness of mmt4d, thanks to its simple contiguous memory access pattern, accounts for its higher performance.</p> <p>As we proceed with increasingly sophisticated SIMD targets, starting with the dot-product instructions found in current mobile devices for the int8 case and going to become generalized to all data types all the way to float32 over the next few years with upcoming ARM SIMD instructions, the advantage of mmt4d will widen for all sizes, not just the larger ones.</p> <p>Part of why we feel confident about the eventual performance that our approach will achieve is that, as mentioned in the introduction, we are rebuilding within the compiler an existing library's schedule and kernel, and we have benchmark results about it.</p>","tags":["CPU"]},{"location":"community/blog/2021-10-13-mmt4d/#conclusion","title":"Conclusion","text":"<p>We introduced a 4d tiled representation for 2d matrix-matrix multiplication with a decomposable algebric transformations that requires only reshape and transpose of input operands, we discussed and empirically showed how that solves major drawbacks in row-major linear matmul by providing a flexible way to match different ISA layout along with better cache locality achieving near peak performance.</p> <p>As was mentioned in the introduction, this work in under active development and the next immediate steps are to prove the rest of the hypothesis by:</p> <ul> <li> <p>Handling dynamic sizes and padding to the next multiple of the target tile   size.</p> </li> <li> <p>Implementing the integer case (<code>int32 += int8 * int8</code>).</p> </li> <li> <p>Implementing the dispatch to different SIMD ISA variants at runtime.</p> </li> <li> <p>Implementing cache-friendly traversal for larger matmuls and multi-threading   by interfacing with IREE's runtime dispatch.</p> </li> <li> <p>Improving the generated code by fusing the 4d tiled layout with the   producers and consumers of the <code>linalg.mmt4d</code>.</p> </li> </ul>","tags":["CPU"]},{"location":"community/blog/2021-10-15-cuda-backend/","title":"CUDA backend","text":"<p>Friday, October 15, 2021 By Thomas Raoux</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#cuda-backend-in-iree","title":"CUDA Backend in IREE","text":"<p>IREE is being designed with re-targetability as a core goal: it should be possible to use IREE to target a broad spectrum of power regimes, from embedded systems to distributed clusters; and it should be possible to extend IREE to target new back-ends without having to reinvent the wheel each time.</p> <p>To explore this, we recently branched out from our initial focus on low-latency mobile deployments with a goal of using IREE to target data center workloads on Nvidia CUDA. This post describes how we quickly brought up a CUDA back-end for IREE and used it to train BERT, then shares some metrics and next steps.</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#bring-up","title":"Bring up","text":"","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#hal-support","title":"HAL support","text":"<p>IREE has a HAL API that abstract all the targets behind a common interface. The first step to supporting a CUDA target was to map the HAL API onto CUDA. We use the CUDA driver API to reduce dependencies and be closer to the hardware. The HAL API is based on other GPU APIs like Vulkan and Metal, so it was a natural fit for CUDA. The HAL API exposes memory allocations, basic fill and memset commands, kernel dispatch, and general command buffer handling. The original implementation uses the CUDA graph API as a graph maps naturally to command buffers. There is also an implementation using CUDA streams for comparison.</p> <p>HAL exposes an API that can be tested independently, even if we are not able to create CUDA kernels yet we can test a large portion of the CUDA driver using CTS tests. Those can be run to make sure a system has the required CUDA support.</p> <p></p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#compiler-support","title":"Compiler support","text":"<p>CUDA has an open source backend in LLVM generating PTX that we are leveraging. Therefore IREE can create NVVM (CUDA LLVM variant) and use LLVM's backend to generate PTX. The CUDA driver will do the \"last mile compilation\" at runtime to convert PTX into the GPU's native ISA.</p> <p>IREE compiler pipeline starts from linalg with tensor operands. A large part of the compiler is independent of the target.</p> <p>The linalg on tensor representation of the graph is broken up into dispatch regions that are processed by NVVM Codegen. A simple implementation of the compiler is to run bufferization and convert linalg to standard followed by conversion to NVVM/LLVM. Most of those transformation can re-use upstream MLIR transformations and share it with any other backend targeting LLVM IR. Leveraging MLIR conversion to LLVM will allow us to quickly go from a simple \"hello world\" to supporting full models.</p> <p>IREE code generation is based on MLIR infrastructure so each step can easily be tested independently using the MLIR lit framework.</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#flatbuffer-definition","title":"FlatBuffer definition","text":"<p>Kernels are encoded in a FlatBuffer containing the PTX code as well as the workgroup size to use for the dispatch. This allows serialization of the kernels in the IR, it is then de-serialized by the HAL layer.</p> <pre><code>table CUDAExecutableDef {\n  // A map of entry point ordinals to string names as used in the shader\n  // library.\n  entry_points:[string];\n\n  // Block sizes for each entry point.\n  block_sizes:[CUDABlockSizeDef];\n\n  // PTX string of the module.\n  ptx_image:string;\n}\n</code></pre>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#hello-world","title":"Hello world","text":"<p>Together those 3 steps are enough to provide most of the functionality and we can now successfully compile full models.</p> <p></p> <p>The steps to reproduce running a simple op end to end through CUDA backend are described here.</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#performance","title":"Performance","text":"<p>Now that we have enabled functionality we need to look at the performance. Once again we can leverage existing MLIR transformations to speed up the developement work.</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#tiling-and-distribution","title":"Tiling and distribution","text":"<p>The first obvious step to get efficient code on CUDA is to make sure we distribute the work on enough blocks and threads to fill up the GPU. At the time of bring up not all ops were being tiled and distributed in the common IREE layer. During dispatch region creation we apply tile and fuse which will distribute the work into a set of workgroups that are mapped to CUDA blocks.</p> <p>At the beginning of the code generation we look at the dispatch region and decide on the tile size for a workgroup. For CUDA we also decide the number of threads per block. We will then have a pass tiling the ops in the dispatch region a second time to distribute the work onto threads within the block.</p> <p>At this stage the IR looks like the following:</p> <pre><code>    %8 = \"gpu.thread_id\"() {dimension = \"x\"} : () -&gt; index\n    %9 = affine.apply affine_map&lt;()[s0] -&gt; (s0 * 4)&gt;()[%8]\n    %10 = memref.subview %in0[%9] [4] [1] : memref&lt;128xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt; to memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n    %11 = memref.subview %in1[%9] [4] [1] : memref&lt;128xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt; to memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n    %12 = memref.subview %out[%9] [4] [1] : memref&lt;128xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt; to memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n    linalg.generic {\n        indexing_maps = [affine_map&lt;(d0) -&gt; (d0)&gt;,\n                         affine_map&lt;(d0) -&gt; (d0)&gt;,\n                         affine_map&lt;(d0) -&gt; (d0)&gt;],\n        iterator_types = [\"parallel\"]}\n      ins(%10, %11 :\n          memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;,\n          memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;)\n      outs(%12 : memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;) {\n    ^bb0(%arg1: f32, %arg2: f32, %arg3: f32):  // no predecessors\n      %13 = addf %arg1, %arg2 : f32\n      linalg.yield %13 : f32\n    }\n</code></pre>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#vectorization","title":"Vectorization","text":"<p>Even though GPUs execute most operations as scalar, memory operations are optimized to access 128 bits of data per thread. Therefore it is critical to vectorize load/store operations. After tiling to a size we vectorize the IR to get vector read/write mapping to load4/store4. This significantly improves the memory access pattern of the code generated.</p> <p>This convert the previous IR to:</p> <pre><code>    %8 = \"gpu.thread_id\"() {dimension = \"x\"} : () -&gt; index\n    %9 = affine.apply affine_map&lt;()[s0] -&gt; (s0 * 4)&gt;()[%8]\n    %10 = memref.subview %in0[%9] [4] [1] : memref&lt;128xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt; to memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n    %11 = memref.subview %in1[%9] [4] [1] : memref&lt;128xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt; to memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n    %12 = memref.subview %out[%9] [4] [1] : memref&lt;128xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt; to memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n    %13 = vector.transfer_read %10[%c0], %cst {in_bounds = [true]} : memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;, vector&lt;4xf32&gt;\n    %14 = vector.transfer_read %11[%c0], %cst {in_bounds = [true]} : memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;, vector&lt;4xf32&gt;\n    %15 = addf %13, %14 : vector&lt;4xf32&gt;\n    vector.transfer_write %15, %12[%c0] {in_bounds = [true]} : vector&lt;4xf32&gt;, memref&lt;4xf32, affine_map&lt;(d0)[s0] -&gt; (d0 + s0)&gt;&gt;\n</code></pre>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#shared-memory-optimization","title":"Shared memory optimization","text":"<p>Nvidia GPUs have a fast shared memory that needs to be leveraged to optimize cases where we may be memory bound and have the potential to re-use memory reads.</p> <p>For operations like GEMM using shared memory gives us a significant speed up. We leverage memory promotion, vector distribution and software pipelining transformations from MLIR to generate efficient copies from global to shared memory that can be interleaved with the compute work.</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#optimization-pipeline","title":"Optimization pipeline","text":"<p>Those different transformations compose to this flow:</p> <p></p> <p>The full dump step by step of a linalg.matmul operation can be found here.</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#results-and-next-steps","title":"Results and next steps","text":"","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#gemm","title":"GEMM","text":"<p>We compare the performance of a single GEMM operation to highly optimized library cuBLAS using mmperf framework.</p> <p></p> <p>The graph can be re-produced based on instructions on mmperf</p>","tags":["GPU","CUDA"]},{"location":"community/blog/2021-10-15-cuda-backend/#future-work","title":"Future work","text":"<p>Nod.ai has contributed an experimental HAL module for ROCM that allows us to re-use the compiler parts to support ROCM, more support is going to be added in the future.</p> <p>Several performance improvements are still under progress, including optimizing the runtime allocator to reduce the host-side overhead and tuning tile sizes based profiling.</p> <p>Several models are running and we will publish more detailed benchmark results in the near future.</p>","tags":["GPU","CUDA"]},{"location":"guides/","title":"Guides","text":""},{"location":"guides/#ml-frameworks","title":"ML frameworks","text":"<p>Start here: ML frameworks overview</p> <p>Guides for specific frameworks:</p> <ul> <li>TensorFlow</li> <li>TensorFlow Lite</li> <li>JAX</li> <li>PyTorch</li> </ul>"},{"location":"guides/#deployment-configurations","title":"Deployment configurations","text":"<p>Start here: Deplyment configurations overview</p> <p>Guides for specific configurations:</p> <ul> <li>CPU</li> <li>CPU - Bare-Metal</li> <li>GPU - Vulkan</li> <li>GPU - CUDA/ROCm</li> </ul>"},{"location":"guides/#other-topics","title":"Other topics","text":"<ul> <li>Developer tips and tricks</li> </ul>"},{"location":"guides/developer-tips/","title":"IREE developer tips and tricks","text":"<p>The IREE compiler is built using MLIR, so it naturally supports the common MLIR debugging workflows. For areas where IREE differentiates itself, this page lists other helpful tips and tricks.</p>"},{"location":"guides/developer-tips/#setting-compiler-options","title":"Setting compiler options","text":"<p>Tools such as <code>iree-compile</code> take options via command-line flags. Pass <code>--help</code> to see the full list:</p> <pre><code>$ iree-compile --help\n\nOVERVIEW: IREE compilation driver\n\nUSAGE: iree-compile [options] &lt;input file or '-' for stdin&gt;\n\nOPTIONS:\n  ...\n</code></pre> <p>Tip - Options and the Python bindings</p> <p>If you are using the Python bindings, options can be passed via the <code>extra_args=[\"--flag\"]</code> argument:</p> <pre><code>import iree.compiler as ireec\n\ninput_mlir = \"\"\"\nfunc.func @abs(%input : tensor&lt;f32&gt;) -&gt; (tensor&lt;f32&gt;) {\n%result = math.absf %input : tensor&lt;f32&gt;\n  return %result : tensor&lt;f32&gt;\n}\"\"\"\n\ncompiled_module = ireec.tools.compile_str(\n    input_mlir,\n    target_backends=[\"llvm-cpu\"],\nextra_args=[\"--mlir-timing\"])\n</code></pre>"},{"location":"guides/developer-tips/#inspecting-vmfb-files","title":"Inspecting <code>.vmfb</code> files","text":"<p>The IREE compiler generates FlatBuffer files using the <code>.vmfb</code> file extension, short for \"Virtual Machine FlatBuffer\", which can then be loaded and executed using IREE's runtime.</p> Info - other output formats <p>The IREE compiler can output different formats with the <code>`--output-format=</code> flag:</p> Flag value Output <code>--output-format=vm-bytecode</code> (default) VM Bytecode (<code>.vmfb</code>) files <code>--output-format=vm-c</code> C source modules <p>VM Bytecode files are usable across a range of deployment scenarios, while C source modules provide low level connection points for constrained environments like bare metal platforms.</p> <p>By default, <code>.vmfb</code> files can be opened as zip files:</p> <pre><code>$ unzip -d simple_abs_cpu ./simple_abs_cpu.vmfb\n\nArchive:  ./simple_abs_cpu.vmfb\n  extracting: simple_abs_cpu/module.fb\n  extracting: simple_abs_cpu/abs_dispatch_0_system_elf_x86_64.so\n</code></pre> <p>The embedded binary (here an ELF shared object with CPU code) can be parsed by standard tools:</p> <pre><code>$ readelf -Ws ./simple_abs_cpu/abs_dispatch_0_system_elf_x86_64.so\n\nSymbol table '.dynsym' contains 2 entries:\n  Num:    Value          Size Type    Bind   Vis      Ndx Name\n    0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND\n    1: 0000000000001760    17 FUNC    GLOBAL DEFAULT    7 iree_hal_executable_library_query\n\nSymbol table '.symtab' contains 42 entries:\n  Num:    Value          Size Type    Bind   Vis      Ndx Name\n    0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND\n    1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS abs_dispatch_0\n    2: 0000000000001730    34 FUNC    LOCAL  DEFAULT    7 abs_dispatch_0_generic\n    3: 00000000000034c0    80 OBJECT  LOCAL  DEFAULT    8 iree_hal_executable_library_query_v0\n    4: 0000000000001780   111 FUNC    LOCAL  DEFAULT    7 iree_h2f_ieee\n    5: 00000000000017f0   207 FUNC    LOCAL  DEFAULT    7 iree_f2h_ieee\n    ...\n</code></pre> <p>The <code>iree-dump-module</code> tool can also be used to see information about a given <code>.vmfb</code> file:</p> <pre><code>$ iree-dump-module simple_abs.vmfb\n\n//===---------------------------------------------------------------------===//\n// @module : version 0\n//===---------------------------------------------------------------------===//\n\nRequired Types:\n  [  0] i32\n  [  1] i64\n  [  2] !hal.allocator\n  [  3] !hal.buffer\n  ...\n\nModule Dependencies:\n  hal, version &gt;= 0, required\n\nImported Functions:\n  [  0] hal.ex.shared_device() -&gt; (!vm.ref&lt;?&gt;)\n  [  1] hal.allocator.allocate(!vm.ref&lt;?&gt;, i32, i32, i64) -&gt; (!vm.ref&lt;?&gt;)\n  ...\n\nExported Functions:\n  [  0] abs(!vm.ref&lt;?&gt;) -&gt; (!vm.ref&lt;?&gt;)\n  [  1] __init() -&gt; ()\n\n...\n</code></pre>"},{"location":"guides/developer-tips/#dumping-executable-files","title":"Dumping executable files","text":"<p>The <code>--iree-hal-dump-executable-*</code> flags instruct the compiler to save files related to \"executable translation\" (code generation for a specific hardware target) into a directory of your choosing. If you are interested in seeing which operations in your input program were fused into a compute kernel or what device code was generated for a given program structure, these flags are a great starting point.</p> Flag Files dumped <code>iree-hal-dump-executable-files-to</code> All files (meta-flag) <code>iree-hal-dump-executable-sources-to</code> Source <code>.mlir</code> files prior to HAL compilation <code>iree-hal-dump-executable-intermediates-to</code> Intermediate files (e.g. <code>.o</code> files, <code>.mlir</code> stages) <code>iree-hal-dump-executable-binaries-to</code> Binary files (e.g. <code>.so</code>, <code>.spv</code>, <code>.ptx</code>), as used in the <code>.vmfb</code> <code>iree-hal-dump-executable-benchmarks-to</code> Standalone benchmark files for <code>iree-benchmark-module</code> CPUGPU - VulkanGPU - CUDA <pre><code>$ mkdir -p /tmp/iree/simple_abs/\n\n$ iree-compile simple_abs.mlir \\\n--iree-hal-target-backends=llvm-cpu \\\n--iree-llvmcpu-link-embedded=false \\\n--iree-hal-dump-executable-files-to=/tmp/iree/simple_abs \\\n-o /tmp/iree/simple_abs/simple_abs_cpu.vmfb\n\n$ ls /tmp/iree/simple_abs\n\nmodule_abs_dispatch_0.mlir\nmodule_abs_dispatch_0_system_elf_x86_64_benchmark.mlir\nmodule_abs_dispatch_0_system_elf_x86_64.codegen.bc\nmodule_abs_dispatch_0_system_elf_x86_64.linked.bc\nmodule_abs_dispatch_0_system_elf_x86_64.optimized.bc\nmodule_abs_dispatch_0_system_elf_x86_64.s\nmodule_abs_dispatch_0_system_elf_x86_64.so\nsimple_abs_cpu.vmfb\n</code></pre> <p>Tip - Embedded and system linking</p> <p>The default value of <code>--iree-llvmcpu-link-embedded=true</code> generates embedded ELF files. By disabling that flag, the compiler will produce platform-standard <code>.so</code> files for Linux, <code>.dll</code> files for Windows, etc. While embedded ELF files can be smaller and more portable, inspection of artifacts is easier with platform-standard shared object files.</p> Tip - Disassembling <code>.bc</code> files with <code>llvm-dis</code> <p>The <code>.bc</code> intermediate files use the LLVM BitCode format, which can be disassembled using <code>llvm-dis</code>:</p> <pre><code>// Build `llvm-dis` from source as needed:\n$ cmake --build iree-build/ --target llvm-dis\n$ iree-build/llvm-project/bin/llvm-dis --help\n\n$ cd /tmp/iree/simple_abs/\n$ llvm-dis module_abs_dispatch_0_system_elf_x86_64.codegen.bc\n$ cat module_abs_dispatch_0_system_elf_x86_64.codegen.ll\n\n; ModuleID = 'module_abs_dispatch_0_system_elf_x86_64.codegen.bc'\nsource_filename = \"abs_dispatch_0\"\ntarget triple = \"x86_64-linux-gnu\"\n\n%iree_hal_executable_library_header_t = type { i32, ptr, i32, i32 }\n%iree_hal_executable_dispatch_attrs_v0_t = type { i16, i16 }\n\n...\n\ndefine internal i32 @abs_dispatch_0_generic(\n    ptr noalias nonnull align 16 %0,\n    ptr noalias nonnull align 16 %1,\n    ptr noalias nonnull align 16 %2) #0 {\n  %4 = load %iree_hal_executable_dispatch_state_v0_t, ptr %1, align 8,\n  %5 = extractvalue %iree_hal_executable_dispatch_state_v0_t %4, 10,\n  %6 = load ptr, ptr %5, align 8,\n  %7 = ptrtoint ptr %6 to i64,\n  %8 = and i64 %7, 63,\n  %9 = icmp eq i64 %8, 0,\n  call void @llvm.assume(i1 %9),\n  %10 = load %iree_hal_executable_dispatch_state_v0_t, ptr %1, align 8,\n  %11 = extractvalue %iree_hal_executable_dispatch_state_v0_t %10, 10,\n  %12 = getelementptr ptr, ptr %11, i32 1,\n  %13 = load ptr, ptr %12, align 8,\n  %14 = ptrtoint ptr %13 to i64,\n  %15 = and i64 %14, 63,\n  %16 = icmp eq i64 %15, 0,\n  call void @llvm.assume(i1 %16),\n  %17 = load float, ptr %6, align 4,\n  %18 = call float @llvm.fabs.f32(float %17),\n  store float %18, ptr %13, align 4,\n  ret i32 0,\n}\n\n...\n</code></pre> <pre><code>$ mkdir -p /tmp/iree/simple_abs/\n\n$ iree-compile simple_abs.mlir \\\n--iree-hal-target-backends=vulkan-spirv \\\n--iree-hal-dump-executable-files-to=/tmp/iree/simple_abs \\\n-o /tmp/iree/simple_abs/simple_abs_vulkan.vmfb\n\n$ ls /tmp/iree/simple_abs\n\nmodule_abs_dispatch_0.mlir\nmodule_abs_dispatch_0_vulkan_spirv_fb_benchmark.mlir\nmodule_abs_dispatch_0_vulkan_spirv_fb.mlir\nmodule_abs_dispatch_0_vulkan_spirv_fb.spv\nsimple_abs_vulkan.vmfb\n</code></pre> Tip - Disassembling <code>.spv</code> files with <code>spirv-dis</code> <p>The <code>.spv</code> files use the SPIR-V binary format, which can be disassembled using <code>spirv-dis</code> from SPIR-V Tools:</p> <pre><code>$ cd /tmp/iree/simple_abs/\n$ spirv-dis module_abs_dispatch_0_vulkan_spirv_fb.spv\n\n; SPIR-V\n; Version: 1.0\n; Generator: Khronos; 22\n; Bound: 20\n; Schema: 0\n              OpCapability Shader\n              OpExtension \"SPV_KHR_storage_buffer_storage_class\"\n        %18 = OpExtInstImport \"GLSL.std.450\"\n              OpMemoryModel Logical GLSL450\n              OpEntryPoint GLCompute %abs_dispatch_0_generic \"abs_dispatch_0_generic\"\n              OpExecutionMode %abs_dispatch_0_generic LocalSize 1 1 1\n              OpName %__resource_var_0_0_ \"__resource_var_0_0_\"\n              OpName %__resource_var_0_1_ \"__resource_var_0_1_\"\n              OpName %abs_dispatch_0_generic \"abs_dispatch_0_generic\"\n              OpDecorate %_arr_float_uint_1 ArrayStride 4\n              OpMemberDecorate %_struct_2 0 Offset 0\n              OpDecorate %_struct_2 Block\n              OpDecorate %__resource_var_0_0_ Binding 0\n              OpDecorate %__resource_var_0_0_ DescriptorSet 0\n              OpDecorate %__resource_var_0_1_ Binding 1\n              OpDecorate %__resource_var_0_1_ DescriptorSet 0\n      %float = OpTypeFloat 32\n      %uint = OpTypeInt 32 0\n    %uint_1 = OpConstant %uint 1\n%_arr_float_uint_1 = OpTypeArray %float %uint_1\n  %_struct_2 = OpTypeStruct %_arr_float_uint_1\n%_ptr_StorageBuffer__struct_2 = OpTypePointer StorageBuffer %_struct_2\n%__resource_var_0_0_ = OpVariable %_ptr_StorageBuffer__struct_2 StorageBuffer\n%__resource_var_0_1_ = OpVariable %_ptr_StorageBuffer__struct_2 StorageBuffer\n      %void = OpTypeVoid\n          %9 = OpTypeFunction %void\n    %uint_0 = OpConstant %uint 0\n%_ptr_StorageBuffer_float = OpTypePointer StorageBuffer %float\n%abs_dispatch_0_generic = OpFunction %void None %9\n        %12 = OpLabel\n        %15 = OpAccessChain %_ptr_StorageBuffer_float %__resource_var_0_0_ %uint_0 %uint_0\n        %16 = OpLoad %float %15\n        %17 = OpExtInst %float %18 FAbs %16\n        %19 = OpAccessChain %_ptr_StorageBuffer_float %__resource_var_0_1_ %uint_0 %uint_0\n              OpStore %19 %17\n              OpReturn\n              OpFunctionEnd\n</code></pre> <pre><code>$ mkdir -p /tmp/iree/simple_abs/\n\n$ iree-compile simple_abs.mlir \\\n--iree-hal-target-backends=cuda \\\n--iree-hal-dump-executable-files-to=/tmp/iree/simple_abs \\\n-o /tmp/iree/simple_abs/simple_abs_cuda.vmfb\n\n$ ls /tmp/iree/simple_abs\n\nmodule_abs_dispatch_0_cuda_nvptx_fb_benchmark.mlir\nmodule_abs_dispatch_0_cuda_nvptx_fb.codegen.bc\nmodule_abs_dispatch_0_cuda_nvptx_fb.linked.bc\nmodule_abs_dispatch_0_cuda_nvptx_fb.optimized.bc\nmodule_abs_dispatch_0_cuda_nvptx_fb.ptx\nmodule_abs_dispatch_0.mlir\nsimple_abs_cuda.vmfb\n</code></pre> Tip - Disassembling <code>.bc</code> files with <code>llvm-dis</code> <p>The <code>.bc</code> intermediate files use the LLVM BitCode format, which can be disassembled using <code>llvm-dis</code>:</p> <pre><code>// Build `llvm-dis` from source as needed:\n$ cmake --build iree-build/ --target llvm-dis\n$ iree-build/llvm-project/bin/llvm-dis --help\n\n$ cd /tmp/iree/simple_abs/\n$ llvm-dis module_abs_dispatch_0_cuda_nvptx_fb.codegen.bc\n$ cat module_abs_dispatch_0_cuda_nvptx_fb.codegen.ll\n\n; ModuleID = 'module_abs_dispatch_0_cuda_nvptx_fb.codegen.bc'\nsource_filename = \"abs_dispatch_0\"\n\ndeclare ptr @malloc(i64)\n\ndeclare void @free(ptr)\n\ndeclare float @__nv_fabsf(float)\n\ndefine void @abs_dispatch_0_generic(ptr noalias readonly align 16 %0, ptr noalias align 16 %1) {\n  %3 = ptrtoint ptr %0 to i64\n  %4 = and i64 %3, 63\n  %5 = icmp eq i64 %4, 0\n  call void @llvm.assume(i1 %5)\n  %6 = ptrtoint ptr %1 to i64\n  %7 = and i64 %6, 63\n  %8 = icmp eq i64 %7, 0\n  call void @llvm.assume(i1 %8)\n  %9 = load float, ptr %0, align 4\n  %10 = call float @__nv_fabsf(float %9)\n  store float %10, ptr %1, align 4\n  ret void\n}\n\n!nvvm.annotations = !{!0, !1, !2, !3}\n\n!0 = !{ptr @abs_dispatch_0_generic, !\"kernel\", i32 1}\n!1 = !{ptr @abs_dispatch_0_generic, !\"maxntidx\", i32 1}\n!2 = !{ptr @abs_dispatch_0_generic, !\"maxntidy\", i32 1}\n!3 = !{ptr @abs_dispatch_0_generic, !\"maxntidz\", i32 1}\n</code></pre>"},{"location":"guides/developer-tips/#compiling-phase-by-phase","title":"Compiling phase by phase","text":"<p>IREE compiles programs through a series of broad phases:</p> <pre><code>graph LR\n  accTitle: Compilation phases overview\n  accDescr: Input to ABI to Flow to Stream to HAL to VM\n\n  A([Input])\n  A --&gt; B([ABI])\n  B --&gt; C([Flow])\n  C --&gt; D([Stream])\n  D --&gt; E([HAL])\n  E --&gt; F([VM])</code></pre> <p>You can output a program snapshot at intermediate phases with the <code>--compile-to=&lt;phase name&gt;</code> flag:</p> <pre><code>$ cat simple_abs.mlir\n\nfunc.func @abs(%input : tensor&lt;f32&gt;) -&gt; (tensor&lt;f32&gt;) {\n  %result = math.absf %input : tensor&lt;f32&gt;\n  return %result : tensor&lt;f32&gt;\n}\n\n$ iree-compile simple_abs.mlir --compile-to=abi\n\nmodule {\n  func.func @abs(%arg0: !hal.buffer_view) -&gt; !hal.buffer_view attributes {iree.abi.stub} {\n    %0 = hal.tensor.import %arg0 \"input 0\" : !hal.buffer_view -&gt; tensor&lt;f32&gt;\n    %1 = math.absf %0 : tensor&lt;f32&gt;\n    %2 = hal.tensor.export %1 \"output 0\" : tensor&lt;f32&gt; -&gt; !hal.buffer_view\n    return %2 : !hal.buffer_view\n  }\n}\n</code></pre> <p>This is similar to the <code>--mlir-print-ir-after=</code> flag, but at clearly defined pipeline phases.</p> <p>Compilation can be continued from any intermediate phase. This allows for interative workflows - compile to a phase, make edits to the <code>.mlir</code> file, then resume compilation and continue through the pipeline:</p> <pre><code>$ iree-compile simple_abs.mlir --compile-to=abi -o simple_abs_abi.mlir\n\n$ sed \\\n-e 's/math.absf/math.exp/' \\\n-e 's/@abs/@exp/' \\\nsimple_abs_abi.mlir &gt; simple_exp_abi.mlir\n\n$ iree-compile simple_exp_abi.mlir \\\n--iree-hal-target-backends=llvm-cpu \\\n-o simple_exp_cpu.vmfb\n</code></pre>"},{"location":"guides/deployment-configurations/","title":"Deployment configurations","text":"<p>IREE provides a flexible set of tools for various deployment scenarios. Fully featured environments can use IREE to load programs on demand and to take advantage of multi-threaded hardware, while embedded systems can bypass IREE's runtime entirely or interface with custom accelerators.</p>"},{"location":"guides/deployment-configurations/#stable-configurations","title":"Stable configurations","text":"<ul> <li>CPU for general purpose CPU deployment</li> <li>CPU - Bare-Metal with minimal platform dependencies</li> <li>GPU - Vulkan</li> <li>GPU - CUDA/ROCm</li> </ul> <p>These are just the most stable configurations IREE supports. Feel free to reach out on any of IREE's communication channels if you have questions about a specific platform, hardware accelerator, or set of system features.</p>"},{"location":"guides/deployment-configurations/#compiler-target-backends","title":"Compiler target backends","text":"<p>Compiler target backends are used to generate executable code for hardware APIs and device architectures. Compiler targets may implement special optimizations or generate distinct code for certain device/architecture/performance profiles.</p> <p>When compiling programs, a list of target backends must be specified via</p> <ul> <li><code>--iree-hal-target-backends=</code> (command-line)</li> <li><code>target_backends=[...]</code> (Python)</li> </ul> Target backend Description Compatible HAL devices <code>llvm-cpu</code> Code generation for CPU-like devices supported by LLVM <code>local-sync</code>, <code>local-task</code> <code>vmvx</code> Portable interpreter powered by a microkernel library <code>local-sync</code>, <code>local-task</code> <code>vulkan</code> or<code>vulkan-spirv</code> Portable GPU support via SPIR-V for Vulkan <code>vulkan</code> <code>cuda</code> NVIDIA GPU support via PTX for CUDA <code>cuda</code> <code>rocm</code> Experimental  AMD GPU support via HSACO for ROCm <code>rocm</code> <code>webgpu-wgsl</code> Experimental  GPU support on the Web via WGSL for WebGPU <code>webgpu</code> <code>metal</code> or<code>metal-spirv</code> Experimental  GPU support on Apple platforms via MSL for Metal <code>metal</code> <p>Tip - listing available backends</p> <p>The list of compiler target backends can be queried:</p> Command-linePython bindings <pre><code>$ iree-compile --iree-hal-list-target-backends\n\nRegistered target backends:\n    cuda\n    llvm-cpu\n    metal\n    metal-spirv\n    vmvx\n    vmvx-inline\n    vulkan\n    vulkan-spirv\n</code></pre> <pre><code>iree.compiler.query_available_targets()\n\n['cuda',\n 'llvm-cpu',\n 'metal',\n 'metal-spirv',\n 'vmvx',\n 'vmvx-inline',\n 'vulkan',\n 'vulkan-spirv']\n</code></pre>"},{"location":"guides/deployment-configurations/#runtime-hal-driversdevices","title":"Runtime HAL drivers/devices","text":"<p>Runtime HAL devices call into hardware APIs to load and run executable code. Devices may use multithreading or other system resources, depending on their focus and the build configuration.</p> HAL device Description <code>local-sync</code> Synchronous local CPU device with inline execution <code>local-task</code> Multithreaded local CPU device using a 'task' executor <code>vulkan</code> Portable GPU execution using the Vulkan API <code>cuda</code> NVIDIA GPU execution using CUDA <code>rocm</code> Experimental  AMD GPU execution using ROCm <code>webgpu</code> Experimental  GPU execution on the web using WebGPU <code>metal</code> Experimental  GPU execution on Apple platforms using Metal <p>Additional HAL drivers can also be defined external to the core project via <code>IREE_EXTERNAL_HAL_DRIVERS</code>.</p>"},{"location":"guides/deployment-configurations/bare-metal/","title":"Running on a Bare-Metal Platform","text":"<p>IREE supports model execution via CPU on bare-metal platforms. Bare metal platforms have no operating system support, and executables are built using machine-specific linker scripts and/or board support packages (BSPs).</p> <p>Bare-metal deployment typically uses IREE's LLVM compiler target backend much like the CPU configuration, but using a limited subset of IREE's CPU HAL driver code at runtime to load and execute compiled programs.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#prerequisites","title":"Prerequisites","text":"<p>Out-of-tree bare-metal platform tools and source code for the system should be ready, such as</p> <ul> <li>Compilation toolchain</li> <li>Platform linker script</li> <li>Firmware libraries</li> </ul> <p>Please follow the instructions to retrieve the IREE compiler.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#compile-the-model-for-bare-metal","title":"Compile the model for bare-metal","text":"<p>The model can be compiled with the following command:</p> <pre><code>iree-compile \\\n--iree-stream-partitioning-favor=min-peak-memory \\\n--iree-hal-target-backends=llvm-cpu \\\n--iree-llvmcpu-target-triple=x86_64-pc-linux-elf \\\n--iree-llvmcpu-debug-symbols=false \\\nsamples/models/simple_abs.mlir \\\n-o /tmp/simple_abs_cpu.vmfb\n</code></pre> <p>In which</p> <ul> <li><code>--iree-stream-partitioning-favor=min-peak-memory</code>: Optimize for minimum peak     memory usage at the cost of concurrency - include when targeting     single-threaded execution to reduce memory consumption.</li> <li><code>--iree-hal-target-backends=llvm-cpu</code>: Compile using the LLVM CPU target</li> <li><code>--iree-llvmcpu-target-triple</code>: Use the <code>&lt;arch&gt;-pc-linux-elf</code> LLVM target triple     so the artifact has a fixed ABI to be rendered by the     elf_module library</li> <li><code>--iree-llvmcpu-debug-symbols=false</code>: To reduce the artifact size</li> </ul> <p>See generate.sh for example command-line instructions of some common architectures.</p> <p>You can replace the MLIR file with the other MLIR model files, following the instructions.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#compiling-the-bare-metal-model-for-static-library-support","title":"Compiling the bare-metal model for static-library support","text":"<p>See the static_library demo sample for an example and instructions on running a model with IREE's <code>static_library_loader</code>.</p> <p>By default, the demo targets the host machine when compiling. To produce a bare-metal compatible model, run <code>iree-compile</code> as in the previous example and add the additional <code>-iree-llvmcpu-static-library-output-path=</code> flag to specify the static library destination. This will produce a <code>.h\\.o</code> file to link directly into the target application.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#build-bare-metal-runtime-from-source","title":"Build bare-metal runtime from source","text":"<p>A few CMake options and macros should be set to build a subset of IREE runtime libraries compatible with the bare-metal platform. We assume there's no multi-thread control nor system library support in the bare-metal system. The model execution is in a single-thread synchronous fashion.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#set-cmake-options","title":"Set CMake options","text":"<pre><code># Build the IREE runtime only\nset(IREE_BUILD_COMPILER OFF)\n\n# Tell CMake to skip targeting a specific operating system\nset(CMAKE_SYSTEM_NAME Generic)\n\n# Disable multi-thread library support\nset(IREE_ENABLE_THREADING OFF)\n\n# Only enable the local synchronous HAL driver\nset(IREE_HAL_DRIVER_DEFAULTS OFF)\nset(IREE_HAL_DRIVER_LOCAL_SYNC ON)\n\n# Only enable some executable loaders\nset(IREE_HAL_EXECUTABLE_LOADER_DEFAULTS OFF)\nset(IREE_HAL_EXECUTABLE_LOADER_EMBEDDED_ELF ON)\nset(IREE_HAL_EXECUTABLE_LOADER_VMVX_MODULE ON)\n\n# Only enable the embedded ELF executable plugin\nset(IREE_HAL_EXECUTABLE_PLUGIN_DEFAULTS OFF)\nset(IREE_HAL_EXECUTABLE_PLUGIN_EMBEDDED_ELF ON)\n\n# Disable tests until IREE supports running them on bare-metal platforms\nset(IREE_BUILD_TESTS OFF)\n\n# Build samples\nset(IREE_BUILD_SAMPLES ON)\n</code></pre> <p>Todo</p> <p>Clean the list up after #6353 is fixed.</p> <p>Also, set the toolchain-specific cmake file to match the tool path, target architecture, target abi, linker script, system library path, etc.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#define-iree-macros","title":"Define IREE macros","text":"<p>These macros should be defined, either in C/C++ or via CMake options like</p> <pre><code>set(MY_FLAGS \"-DIREE_PLATFORM_GENERIC=1\")\nset(CMAKE_C_FLAGS ${MY_FLAGS} ${CMAKE_C_FLAGS})\nset(CMAKE_CXX_FLAGS ${MY_FLAGS} ${CMAKE_CXX_FLAGS})\n</code></pre> Macro Description <code>IREE_PLATFORM_GENERIC</code> Let IREE build the runtime library without targeting a specific platform. <code>IREE_SYNCHRONIZATION_DISABLE_UNSAFE=1</code> Disable thread synchronization support.Must only be used if there's a single thread. <code>IREE_FILE_IO_ENABLE=0</code> Disable file I/O. <code>IREE_TIME_NOW_FN</code> A function to return the system time. For the bare-metal systems, it can be set as <code>IREE_TIME_NOW_FN=\\\"\\{ return 0;\\}\\\"</code> as there's no asynchronous wait handling. <code>IREE_WAIT_UNTIL_FN</code> A function to wait until the given time in nanoseconds. Must match the signature <code>bool(uint64_t nanos)</code> and return false if the wait failed. <p>Examples of how to setup the CMakeLists.txt and .cmake file:</p> <ul> <li>IREE RISC-V toolchain cmake</li> <li>IREE Bare-Metal Arm Sample</li> <li>IREE Bare-Metal RV32 Sample</li> </ul>","tags":["CPU"]},{"location":"guides/deployment-configurations/bare-metal/#bare-metal-execution-example","title":"Bare-metal execution example","text":"<p>See simple_embedding for generic platform to see how to use the IREE runtime library to build/run the IREE model for the bare-metal target.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/","title":"CPU Deployment","text":"<p>IREE supports efficient program execution on CPU devices by using LLVM to compile all dense computations in each program into highly optimized CPU native instruction streams, which are embedded in one of IREE's deployable formats.</p> <p>To compile a program for CPU execution, pick one of IREE's supported executable formats:</p> Executable Format Description embedded ELF portable, high performance dynamic library system library platform-specific dynamic library (.so, .dll, etc.) VMVX reference target <p>At runtime, CPU executables can be loaded using one of IREE's CPU HAL drivers:</p> <ul> <li><code>local-task</code>: asynchronous, multithreaded driver built on IREE's \"task\"    system</li> <li><code>local-sync</code>: synchronous, single-threaded driver that executes work inline</li> </ul> <p>Todo</p> <p>Add IREE's CPU support matrix: what architectures are supported; what architectures are well optimized; etc.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#prerequisites","title":"Prerequisites","text":"","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#get-the-iree-compiler","title":"Get the IREE compiler","text":"","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#download-the-compiler-from-a-release","title":"Download the compiler from a release","text":"<p>Python packages are regularly published to PyPI. See the Python Bindings page for more details. The core <code>iree-compiler</code> package includes the LLVM-based CPU compiler:</p> <pre><code>python -m pip install iree-compiler\n</code></pre> <p>Tip</p> <p><code>iree-compile</code> is installed to your python module installation path. If you pip install with the user mode, it is under <code>${HOME}/.local/bin</code>, or <code>%APPDATA%Python</code> on Windows. You may want to include the path in your system's <code>PATH</code> environment variable:</p> <pre><code>export PATH=${HOME}/.local/bin:${PATH}\n</code></pre>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#build-the-compiler-from-source","title":"Build the compiler from source","text":"<p>Please make sure you have followed the Getting started page to build IREE for your host platform and the Android cross-compilation or iOS cross-compilation page if you are cross compiling for a mobile device. The <code>llvm-cpu</code> compiler backend is compiled in by default on all platforms.</p> <p>Ensure that the <code>IREE_TARGET_BACKEND_LLVM_CPU</code> CMake option is <code>ON</code> when configuring for the host.</p> <p>Tip</p> <p><code>iree-compile</code> will be built under the <code>iree-build/tools/</code> directory. You may want to include this path in your system's <code>PATH</code> environment variable.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#get-the-iree-runtime","title":"Get the IREE runtime","text":"<p>You will need to get an IREE runtime that supports the local CPU HAL driver, along with the appropriate executable loaders for your application.</p> <p>You can check for CPU support by looking for the <code>local-sync</code> and <code>local-task</code> drivers:</p> <pre><code>$ iree-run-module --list_drivers\n\n        cuda: CUDA (dynamic)\n  local-sync: Local execution using a lightweight inline synchronous queue\n  local-task: Local execution using the IREE multithreading task system\n      vulkan: Vulkan 1.x (dynamic)\n</code></pre>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#build-the-runtime-from-source","title":"Build the runtime from source","text":"<p>Please make sure you have followed the Getting started page to build IREE for your host platform and the Android cross-compilation page if you are cross compiling for Android. The local CPU HAL drivers are compiled in by default on all platforms.</p> <p>Ensure that the <code>IREE_HAL_DRIVER_LOCAL_TASK</code> and <code>IREE_HAL_EXECUTABLE_LOADER_EMBEDDED_ELF</code> (or other executable loader) CMake options are <code>ON</code> when configuring for the target.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#compile-and-run-a-program","title":"Compile and run a program","text":"<p>With the requirements out of the way, we can now compile a model and run it.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#compile-a-program","title":"Compile a program","text":"<p>The IREE compiler transforms a model into its final deployable format in many sequential steps. A model authored with Python in an ML framework should use the corresponding framework's import tool to convert into a format (i.e., MLIR) expected by the IREE compiler first.</p> <p>Using MobileNet v2 as an example, you can download the SavedModel with trained weights from TensorFlow Hub and convert it using IREE's TensorFlow importer. Then run the following command to compile with the <code>llvm-cpu</code> target:</p> <pre><code>iree-compile \\\n--iree-hal-target-backends=llvm-cpu \\\nmobilenet_iree_input.mlir -o mobilenet_cpu.vmfb\n</code></pre> <p>Tip - CPU targets</p> <p>The <code>--iree-llvmcpu-target-triple</code> flag tells the compiler to generate code for a specific type of CPU. You can see the list of supported targets with <code>iree-compile --iree-llvmcpu-list-targets</code>, or pass \"host\" to let LLVM infer the triple from your host machine (e.g. <code>x86_64-linux-gnu</code>).</p> <pre><code>$ iree-compile --iree-llvmcpu-list-targets\n\n  Registered Targets:\n    aarch64    - AArch64 (little endian)\n    aarch64_32 - AArch64 (little endian ILP32)\n    aarch64_be - AArch64 (big endian)\n    arm        - ARM\n    arm64      - ARM64 (little endian)\n    arm64_32   - ARM64 (little endian ILP32)\n    armeb      - ARM (big endian)\n    riscv32    - 32-bit RISC-V\n    riscv64    - 64-bit RISC-V\n    wasm32     - WebAssembly 32-bit\n    wasm64     - WebAssembly 64-bit\n    x86        - 32-bit X86: Pentium-Pro and above\n    x86-64     - 64-bit X86: EM64T and AMD64\n</code></pre> <p>Tip - CPU features</p> <p>The <code>--iree-llvmcpu-target-cpu-features</code> flag tells the compiler to generate code using certain CPU \"features\", like SIMD instruction sets. Like the target triple, you can pass \"host\" to this flag to let LLVM infer the features supported by your host machine.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/cpu/#run-a-compiled-program","title":"Run a compiled program","text":"<p>In the build directory, run the following command:</p> <pre><code>tools/iree-run-module \\\n--device=local-task \\\n--module=mobilenet_cpu.vmfb \\\n--function=predict \\\n--input=\"1x224x224x3xf32=0\"\n</code></pre> <p>The above assumes the exported function in the model is named as <code>predict</code> and it expects one 224x224 RGB image. We are feeding in an image with all 0 values here for brevity, see <code>iree-run-module --help</code> for the format to specify concrete values.</p>","tags":["CPU"]},{"location":"guides/deployment-configurations/gpu-cuda-rocm/","title":"GPU Deployment using CUDA and ROCm","text":"<p>IREE can accelerate model execution on Nvidia GPUs using CUDA and on AMD GPUs using ROCm. Due to the similarity of CUDA and ROCm APIs and infrastructure, the CUDA and ROCm backends share much of their implementation in IREE:</p> <ul> <li>The IREE compiler uses a similar GPU code generation pipeline for each, but   generates PTX for CUDA and hsaco for ROCm</li> <li>The IREE runtime HAL driver for ROCm mirrors the one for CUDA, except for   command buffers implementations - where CUDA has \"direct\", \"stream\", and   \"graph\" command buffers, and ROCm has only \"direct\" command buffers</li> </ul>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda-rocm/#prerequisites","title":"Prerequisites","text":"<p>In order to use CUDA or ROCm to drive the GPU, you need to have a functional CUDA or ROCm environment. It can be verified by the following steps:</p> Nvidia/CUDAAMD/ROCm <p>Run the following command in a shell:</p> <pre><code>nvidia-smi | grep CUDA\n</code></pre> <p>If <code>nvidia-smi</code> does not exist, you will need to install the latest CUDA Toolkit SDK.</p> <p>Run the following command in a shell:</p> <pre><code>rocm-smi | grep rocm\n</code></pre> <p>If <code>rocm-smi</code> does not exist, you will need to install the latest ROCm Toolkit SDK).</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda-rocm/#get-the-iree-compiler","title":"Get the IREE compiler","text":"","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda-rocm/#download-the-compiler-from-a-release","title":"Download the compiler from a release","text":"Nvidia/CUDAAMD/ROCm <p>Python packages are regularly published to PyPI. See the Python Bindings page for more details. The core <code>iree-compiler</code> package includes the CUDA compiler:</p> <pre><code>python -m pip install iree-compiler\n</code></pre> <p>Tip</p> <p><code>iree-compile</code> is installed to your python module installation path. If you pip install with the user mode, it is under <code>${HOME}/.local/bin</code>, or <code>%APPDATA%Python</code> on Windows. You may want to include the path in your system's <code>PATH</code> environment variable:</p> <pre><code>export PATH=${HOME}/.local/bin:${PATH}\n</code></pre> <p>Currently ROCm is NOT supported for the Python interface.</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda-rocm/#build-the-compiler-from-source","title":"Build the compiler from source","text":"<p>Please make sure you have followed the Getting started page to build the IREE compiler, then enable the CUDA compiler target with the <code>IREE_TARGET_BACKEND_CUDA</code> option or the ROCm compiler target with the <code>IREE_TARGET_BACKEND_ROCM</code> option.</p> <p>Tip</p> <p><code>iree-compile</code> will be built under the <code>iree-build/tools/</code> directory. You may want to include this path in your system's <code>PATH</code> environment variable.</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda-rocm/#get-the-iree-runtime","title":"Get the IREE runtime","text":"<p>Next you will need to get an IREE runtime that includes the CUDA (for Nvidia hardware) or ROCm (for AMD hardware) HAL driver.</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda-rocm/#build-the-runtime-from-source","title":"Build the runtime from source","text":"<p>Please make sure you have followed the Getting started page to build IREE from source, then enable the CUDA HAL driver with the <code>IREE_HAL_DRIVER_CUDA</code> option or the experimental ROCm HAL driver with the <code>IREE_EXTERNAL_HAL_DRIVERS=rocm</code> option.</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda-rocm/#compile-and-run-a-program-model","title":"Compile and run a program model","text":"<p>With the compiler and runtime ready, we can now compile programs and run them on GPUs.</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda-rocm/#compile-a-program","title":"Compile a program","text":"<p>The IREE compiler transforms a model into its final deployable format in many sequential steps. A model authored with Python in an ML framework should use the corresponding framework's import tool to convert into a format (i.e., MLIR) expected by the IREE compiler first.</p> <p>Using MobileNet v2 as an example, you can download the SavedModel with trained weights from TensorFlow Hub and convert it using IREE's TensorFlow importer. Then run one of the following commands to compile:</p> Nvidia/CUDAAMD/ROCm <pre><code>iree-compile \\\n--iree-hal-target-backends=cuda \\\n--iree-hal-cuda-llvm-target-arch=&lt;...&gt; \\\nmobilenet_iree_input.mlir -o mobilenet_cuda.vmfb\n</code></pre> <p>Note that a cuda target architecture(<code>iree-hal-cuda-llvm-target-arch</code>) of the form <code>sm_&lt;arch_number&gt;</code> is needed to compile towards each GPU architecture. If no architecture is specified then we will default to <code>sm_35</code>.</p> <p>Here is a table of commonly used architectures:</p> CUDA GPU Target Architecture Nvidia K80 <code>sm_35</code> Nvidia P100 <code>sm_60</code> Nvidia V100 <code>sm_70</code> Nvidia A100 <code>sm_80</code> <pre><code>iree-compile \\\n--iree-hal-target-backends=rocm \\\n--iree-rocm-target-chip=&lt;...&gt; \\\n--iree-rocm-link-bc=true \\\n--iree-rocm-bc-dir=&lt;...&gt; \\\nmobilenet_iree_input.mlir -o mobilenet_rocm.vmfb\n</code></pre> <p>Note ROCm Bitcode Dir(<code>iree-rocm-bc-dir</code>) path is required. If the system you are compiling IREE in has ROCm installed, then the default value of <code>/opt/rocm/amdgcn/bitcode</code> will usually suffice. If you intend on building ROCm compiler in a non-ROCm capable system, please set <code>iree-rocm-bc-dir</code> to the absolute path where you might have saved the amdgcn bitcode.</p> <p>Note that a ROCm target chip(<code>iree-rocm-target-chip</code>) of the form <code>gfx&lt;arch_number&gt;</code> is needed to compile towards each GPU architecture. If no architecture is specified then we will default to <code>gfx908</code>.</p> <p>Here is a table of commonly used architectures:</p> AMD GPU Target Chip AMD MI25 <code>gfx900</code> AMD MI50 <code>gfx906</code> AMD MI60 <code>gfx906</code> AMD MI100 <code>gfx908</code>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-cuda-rocm/#run-a-compiled-program","title":"Run a compiled program","text":"<p>Run the following command:</p> Nvidia/CUDAAMD/ROCm <pre><code>iree-run-module \\\n--device=cuda \\\n--module=mobilenet_cuda.vmfb \\\n--function=predict \\\n--input=\"1x224x224x3xf32=0\"\n</code></pre> <pre><code>iree-run-module \\\n--device=rocm \\\n--module=mobilenet_rocm.vmfb \\\n--function=predict \\\n--input=\"1x224x224x3xf32=0\"\n</code></pre> <p>The above assumes the exported function in the model is named as <code>predict</code> and it expects one 224x224 RGB image. We are feeding in an image with all 0 values here for brevity, see <code>iree-run-module --help</code> for the format to specify concrete values.</p>","tags":["GPU","CUDA"]},{"location":"guides/deployment-configurations/gpu-vulkan/","title":"GPU Deployment using Vulkan","text":"<p>IREE can accelerate model execution on GPUs via Vulkan, a low-overhead graphics and compute API. Vulkan is cross-platform: it is available on many operating systems, including Android, Linux, and Windows. Vulkan is also cross-vendor: it is supported by most GPU vendors, including AMD, ARM, Intel, NVIDIA, and Qualcomm.</p>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#support-matrix","title":"Support matrix","text":"<p>As IREE and the compiler ecosystem it operates within matures, more target specific optimizations will be implemented. At this stage, expect reasonable performance across all GPUs and for improvements to be made over time for specific vendors and architectures.</p> GPU Vendor Category Performance Focus Architecture ARM Mali GPU Mobile Good Valhall Qualcomm Adreno GPU Mobile Reasonable 640+ AMD GPU Desktop/server Reasonable - NVIDIA GPU Desktop/server Good -","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#prerequisites","title":"Prerequisites","text":"<p>In order to use Vulkan to drive the GPU, you need to have a functional Vulkan environment. IREE requires Vulkan 1.1 on Android and 1.2 elsewhere. It can be verified by the following steps:</p> AndroidLinuxWindows <p>Android mandates Vulkan 1.1 support since Android 10. You just need to make sure the device's Android version is 10 or higher.</p> <p>Run the following command in a shell:</p> <pre><code>vulkaninfo | grep apiVersion\n</code></pre> <p>If <code>vulkaninfo</code> does not exist, you will need to install the latest Vulkan SDK. Installing via LunarG's package repository is recommended, as it places Vulkan libraries and tools under system paths so it's easy to discover.</p> <p>If the listed version is lower than Vulkan 1.2, you will need to update the driver for your GPU.</p> <p>Run the following command in a shell:</p> <pre><code>vulkaninfo | grep apiVersion\n</code></pre> <p>If <code>vulkaninfo</code> does not exist, you will need to install the latest Vulkan SDK.</p> <p>If the listed version is lower than Vulkan 1.2, you will need to update the driver for your GPU.</p>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#get-the-iree-compiler","title":"Get the IREE compiler","text":"<p>Vulkan expects the program running on GPU to be expressed by the SPIR-V binary exchange format, which the model must be compiled into.</p>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#download-the-compiler-from-a-release","title":"Download the compiler from a release","text":"<p>Python packages are regularly published to PyPI. See the Python Bindings page for more details. The core <code>iree-compiler</code> package includes the SPIR-V compiler:</p> <pre><code>python -m pip install iree-compiler\n</code></pre> <p>Tip</p> <p><code>iree-compile</code> is installed to your python module installation path. If you pip install with the user mode, it is under <code>${HOME}/.local/bin</code>, or <code>%APPDATA%Python</code> on Windows. You may want to include the path in your system's <code>PATH</code> environment variable:</p> <pre><code>export PATH=${HOME}/.local/bin:${PATH}\n</code></pre>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#build-the-compiler-from-source","title":"Build the compiler from source","text":"<p>Please make sure you have followed the Getting started page to build IREE for your host platform and the Android cross-compilation page if you are cross compiling for Android. The SPIR-V compiler backend is compiled in by default on all platforms.</p> <p>Ensure that the <code>IREE_TARGET_BACKEND_VULKAN_SPIRV</code> CMake option is <code>ON</code> when configuring for the host.</p> <p>Tip</p> <p><code>iree-compile</code> will be built under the <code>iree-build/tools/</code> directory. You may want to include this path in your system's <code>PATH</code> environment variable.</p>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#get-the-iree-runtime","title":"Get the IREE runtime","text":"<p>Next you will need to get an IREE runtime that supports the Vulkan HAL driver.</p> <p>You can check for Vulkan support by looking for a matching driver and device:</p> <pre><code>$ iree-run-module --list_drivers\n\n        cuda: CUDA (dynamic)\n  local-sync: Local execution using a lightweight inline synchronous queue\n  local-task: Local execution using the IREE multithreading task system\n      vulkan: Vulkan 1.x (dynamic)\n</code></pre> <pre><code>$ iree-run-module --list_devices\n\n  cuda://GPU-00000000-1111-2222-3333-444444444444\n  local-sync://\n  local-task://\n  vulkan://00000000-1111-2222-3333-444444444444\n</code></pre>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#build-the-runtime-from-source","title":"Build the runtime from source","text":"<p>Please make sure you have followed the Getting started page to build IREE for Linux/Windows and the Android cross-compilation page for Android. The Vulkan HAL driver is compiled in by default on non-Apple platforms.</p> <p>Ensure that the <code>IREE_HAL_DRIVER_VULKAN</code> CMake option is <code>ON</code> when configuring for the target.</p>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#compile-and-run-a-program","title":"Compile and run a program","text":"<p>With the SPIR-V compiler and Vulkan runtime, we can now compile programs and run them on GPUs.</p>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#compile-a-program","title":"Compile a program","text":"<p>The IREE compiler transforms a model into its final deployable format in many sequential steps. A model authored with Python in an ML framework should use the corresponding framework's import tool to convert into a format (i.e., MLIR) expected by the IREE compiler first.</p> <p>Using MobileNet v2 as an example, you can download the SavedModel with trained weights from TensorFlow Hub and convert it using IREE's TensorFlow importer. Then run the following command to compile with the <code>vulkan-spirv</code> target:</p> <pre><code>iree-compile \\\n--iree-hal-target-backends=vulkan-spirv \\\n--iree-vulkan-target-triple=&lt;...&gt; \\\nmobilenet_iree_input.mlir -o mobilenet_vulkan.vmfb\n</code></pre> <p>Note</p> <p>A target triple of the form <code>&lt;vendor/arch&gt;-&lt;product&gt;-&lt;os&gt;</code> is needed to compile towards each GPU architecture. If no triple is specified then a safe but more limited default will be used. We don't support the full spectrum here1; the following table summarizes the currently recognized ones:</p> GPU Vendor Target Triple ARM Mali GPU e.g., <code>valhall-g78-android30</code> Qualcomm Adreno GPU e.g., <code>adreno-unknown-android30</code> AMD GPU e.g., <code>rdna1-5700xt-linux</code> NVIDIA GPU e..g, <code>ampere-rtx3080-windows</code> SwiftShader CPU <code>cpu-swiftshader-unknown</code>","tags":["GPU","Vulkan"]},{"location":"guides/deployment-configurations/gpu-vulkan/#run-a-compiled-program","title":"Run a compiled program","text":"<p>In the build directory, run the following command:</p> <pre><code>tools/iree-run-module \\\n--device=vulkan \\\n--module=mobilenet_vulkan.vmfb \\\n--function=predict \\\n--input=\"1x224x224x3xf32=0\"\n</code></pre> <p>The above assumes the exported function in the model is named as <code>predict</code> and it expects one 224x224 RGB image. We are feeding in an image with all 0 values here for brevity, see <code>iree-run-module --help</code> for the format to specify concrete values.</p> <ol> <li> <p>It's also impossible to capture all details of a Vulkan implementation with a target triple, given the allowed variances on extensions, properties, limits, etc. So the target triple is just an approximation for usage.\u00a0\u21a9</p> </li> </ol>","tags":["GPU","Vulkan"]},{"location":"guides/ml-frameworks/","title":"ML frameworks","text":"<p>IREE supports popular machine learning frameworks using the same underlying technology.</p> <pre><code>graph LR\n  accTitle: ML framework to runtime deployment workflow overview\n  accDescr {\n    Programs start in some ML framework.\n    Programs are imported into MLIR.\n    The IREE compiler uses the imported MLIR.\n    Compiled programs are used by the runtime.\n  }\n\n  A[ML frameworks]\n  B[Imported MLIR]\n  C[IREE compiler]\n  D[Runtime deployment]\n\n  A --&gt; B\n  B --&gt; C\n  C --&gt; D</code></pre>"},{"location":"guides/ml-frameworks/#supported-frameworks","title":"Supported frameworks","text":"<p>See end-to-end examples of how to use each framework with IREE:</p> <ul> <li>TensorFlow and TensorFlow Lite</li> <li>JAX</li> <li>PyTorch</li> </ul> <p>Importing from other frameworks is planned - stay tuned!</p>"},{"location":"guides/ml-frameworks/#samples","title":"Samples","text":"<p>Check out the samples in IREE's <code>samples/</code> directory, as well as the iree-samples repository.</p>"},{"location":"guides/ml-frameworks/#exportimport","title":"Export/Import","text":"<p>Each machine learning framework has some \"export\" mechanism that snapshots the structure and data in your program. These exported programs can then be \"imported\" into IREE's compiler by using either a stable import format or one of IREE's importer tools.</p> <p>This export/import process is specific to each frontend and typically involves a number of stages:</p> <ol> <li>Capture/trace/freeze the ML model into a graph</li> <li>Write that graph to an interchange format (e.g. SavedModel, TorchScript)</li> <li>Load the saved program into an import tool and convert to MLIR</li> <li>Legalize the graph's operations so only IREE-compatible operations remain</li> <li>Write the imported MLIR to a file</li> </ol> <p>This fully imported form can then be compiled indepedently of the source language and framework.</p>"},{"location":"guides/ml-frameworks/#compilation","title":"Compilation","text":"<p>IREE compiles MLIR files for specified sets of backends (CPU, GPU, etc). Each backend generates optimized native code custom to the input program and intended target platform. Once compiled, modules can be executed using IREE's runtime.</p> <p>See the deployment configuration guides for details on selecting a compiler backend and tuning options for your choice of target platform(s) or device(s).</p>"},{"location":"guides/ml-frameworks/#execution","title":"Execution","text":"<p>Compiled modules can be executed by selecting what compute devices to use, loading the module, and then executing it with the intended inputs. IREE provides several language bindings for its runtime API.</p>"},{"location":"guides/ml-frameworks/jax/","title":"JAX Integration","text":"<p>Note</p> <p>IREE's JAX support is under active development. This page is still under construction.</p> <p>IREE offers two ways to interface with JAX programs:</p> <ul> <li>An API for extracting and compiling full models ahead of time (AOT) for   execution apart from JAX. This API is being developed in the   iree-org/iree-jax repository.</li> <li>A PJRT plugin that adapts IREE as a native JAX backend for online / just in   time (JIT) use. This plugin is being developed in the   openxla/openxla-pjrt-plugin repository.</li> </ul>","tags":["Python","JAX"]},{"location":"guides/ml-frameworks/pytorch/","title":"PyTorch Integration","text":"<p>IREE supports compiling and running PyTorch programs represented as <code>nn.Module</code> classes as well as models defined using <code>functorch</code>.</p> <pre><code>graph LR\n  accTitle: PyTorch to runtime deployment workflow overview\n  accDescr {\n    Programs start as either PyTorch nn.Module or functorch programs.\n    Programs are imported into MLIR as either StableHLO, TOSA, or Linalg.\n    The IREE compiler uses the imported MLIR.\n    Compiled programs are used by the runtime.\n  }\n\n  subgraph A[PyTorch]\n    direction TB\n    A1[nn.Module]\n    A2[functorch]\n\n    A1 --- A2\n  end\n\n  subgraph B[MLIR]\n    direction TB\n    B1[StableHLO]\n    B2[TOSA]\n    B3[Linalg]\n\n    B1 --- B2\n    B2 --- B3\n  end\n\n  C[IREE compiler]\n  D[Runtime deployment]\n\n  A -- torch_mlir --&gt; B\n  B --&gt; C\n  C --&gt; D</code></pre>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#prerequisites","title":"Prerequisites","text":"<p>Install IREE pip packages, either from pip or by building from source:</p> <pre><code>pip install \\\niree-compiler \\\niree-runtime\n</code></pre> <p>Install <code>torch-mlir</code>, necessary for compiling PyTorch models to a format IREE is able to execute:</p> <pre><code>pip install --pre torch-mlir \\\n-f https://llvm.github.io/torch-mlir/package-index/\n  --extra-index-url https://download.pytorch.org/whl/nightly/cpu\n</code></pre> <p>The command will also install the right version of <code>torch</code> that has been tested with the version of <code>torch-mlir</code> being installed.</p>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#running-a-model","title":"Running a model","text":"<p>Going from a loaded PyTorch model to one that's executing on IREE happens in four steps:</p> <ol> <li>Compile the model to MLIR</li> <li>Compile the MLIR to IREE VM flatbuffer</li> <li>Load the VM flatbuffer into IREE</li> <li>Execute the model via IREE</li> </ol> <p>Note</p> <p>In the following steps, we'll be borrowing the model from this BERT colab and assuming it is available as <code>model</code>.</p>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#compile-the-model-to-mlir","title":"Compile the model to MLIR","text":"<p>First, we need to trace and compile our model to MLIR:</p> <pre><code>model = # ... the model we're compiling\nexample_input = # ... an input to the model with the expected shape and dtype\nmlir = torch_mlir.compile(\n    model,\n    example_input,\n    output_type=\"linalg-on-tensors\",\n    use_tracing=True)\n</code></pre> <p>The full list of available output types can be found in the source code, and includes <code>linalg-on-tensors</code>, <code>stablehlo</code>, and <code>tosa</code>.</p>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#compile-the-mlir-to-an-iree-vm-flatbuffer","title":"Compile the MLIR to an IREE VM flatbuffer","text":"<p>Next, we compile the resulting MLIR to IREE's deployable file format:</p> <pre><code>iree_backend = \"llvm-cpu\"\niree_input_type = \"tm_tensor\"\nbytecode_stream = io.BytesIO()\nmlir.operation.write_bytecode(bytecode_stream)\niree_vmfb = ireec.compile_str(bytecode_stream.getvalue(),\n                              target_backends=[iree_backend],\n                              input_type=iree_input_type)\n</code></pre> <p>Here we have a choice of backend we want to target. See the deployment configuration guides for more details about specific targets and configurations.</p> <p>The generated flatbuffer can now be serialized and stored for another time or loaded and executed immediately.</p> <p>Note</p> <p>The input type <code>tm_tensor</code> corresponds to the <code>linalg-on-tensors</code> output type of <code>torch-mlir</code>.</p> <p>Note</p> <p>The conversion to bytecode before passing the module to IREE is needed to cross the border from the Torch-MLIR MLIR C API to the IREE MLIR C API.</p>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#load-the-vm-flatbuffer-into-iree","title":"Load the VM flatbuffer into IREE","text":"<p>Next, we load the flatbuffer into the IREE runtime:</p> <pre><code>config = ireert.Config(driver_name=\"local-sync\")\nctx = ireert.SystemContext(config=config)\nvm_module = ireert.VmModule.from_flatbuffer(ctx.instance, flatbuffer)\nctx.add_vm_module(vm_module)\ninvoker = ctx.modules.module\n</code></pre>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#execute-the-model-via-iree","title":"Execute the model via IREE","text":"<p>Finally, we can execute the loaded model:</p> <pre><code>result = invoker.forward(example_input.numpy())\nnumpy_result = np.asarray(result)\n</code></pre>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#training","title":"Training","text":"<p>Training with PyTorch in IREE is supported via <code>functorch</code>. The steps for loading the model into IREE, once defined, are nearly identical to the above example.</p> <p>You can find a full end-to-end example of defining a basic regression model, training with it, and running inference on it here.</p>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#native-on-device-training","title":"Native / On-device Training","text":"<p>A small (~100-250KB), self-contained binary can be built for deploying to resource-constrained environments. An example illustrating this can be found in this example. This binary runs a model without a Python interpreter.</p>","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/pytorch/#samples","title":"Samples","text":"Colab notebooks Inference on BERT Example scripts Basic Inference and Training Example Native On-device Training Example","tags":["Python","PyTorch"]},{"location":"guides/ml-frameworks/tensorflow/","title":"TensorFlow Integration","text":"<p>IREE supports compiling and running TensorFlow programs represented as <code>tf.Module</code> classes or stored in the <code>SavedModel</code> format.</p> <pre><code>graph LR\n  accTitle: TensorFlow to runtime deployment workflow overview\n  accDescr {\n    Programs start as either TensorFlow SavedModel or tf.Module programs.\n    Programs are imported into MLIR as StableHLO.\n    The IREE compiler uses the imported MLIR.\n    Compiled programs are used by the runtime.\n  }\n\n  subgraph A[TensorFlow]\n    direction TB\n    A1[SavedModel]\n    A2[tf.Module]\n\n    A1 --- A2\n  end\n\n  subgraph B[MLIR]\n    B1[StableHLO]\n  end\n\n  C[IREE compiler]\n  D[Runtime deployment]\n\n  A -- iree-import-tf --&gt; B\n  B --&gt; C\n  C --&gt; D</code></pre>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#prerequisites","title":"Prerequisites","text":"<p>Install TensorFlow by following the official documentation:</p> <pre><code>python -m pip install tf-nightly\n</code></pre> <p>Install IREE pip packages, either from pip or by building from source:</p> <pre><code>python -m pip install \\\niree-compiler \\\niree-runtime \\\niree-tools-tf\n</code></pre> <p>Caution</p> <p>The TensorFlow package is currently only available on Linux and macOS. It is not available on Windows yet (see this issue).</p>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#importing-models","title":"Importing models","text":"<p>IREE compilers transform a model into its final deployable format in several sequential steps. The first step for a TensorFlow model is to use either the <code>iree-import-tf</code> command-line tool or IREE's Python APIs to import the model into a format (i.e., MLIR) compatible with the generic IREE compilers.</p>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#from-savedmodel-on-tensorflow-hub","title":"From SavedModel on TensorFlow Hub","text":"<p>IREE supports importing and using SavedModels from TensorFlow Hub.</p>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#using-the-command-line-tool","title":"Using the command-line tool","text":"<p>First download the SavedModel and load it to get the serving signature, which is used as the entry point for IREE compilation flow:</p> <pre><code>import tensorflow.compat.v2 as tf\nloaded_model = tf.saved_model.load('/path/to/downloaded/model/')\nprint(list(loaded_model.signatures.keys()))\n</code></pre> <p>Note</p> <p>If there are no serving signatures in the original SavedModel, you may add them by yourself by following \"Missing serving signature in SavedModel\".</p> <p>Then you can import the model with <code>iree-import-tf</code>. You can read the options supported via <code>iree-import-tf -help</code>. Using MobileNet v2 as an example and assuming the serving signature is <code>predict</code>:</p> <pre><code>iree-import-tf\n  --tf-import-type=savedmodel_v1 \\\n--tf-savedmodel-exported-names=predict \\\n/path/to/savedmodel -o iree_input.mlir\n</code></pre> <p>Tip</p> <p><code>iree-import-tf</code> is installed as <code>/path/to/python/site-packages/iree/tools/tf/iree-import-tf</code>. You can find out the full path to the <code>site-packages</code> directory via the <code>python -m site</code> command.</p> <p>Tip</p> <p><code>-tf-import-type</code> needs to match the SavedModel version. You can try both v1 and v2 if you see one of them gives an empty dump.</p> <p>Next, you can compile the model in <code>iree_input.mlir</code> for one of IREE's supported targets by following one of the deployment configuration guides.</p>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#samples","title":"Samples","text":"Colab notebooks Training an MNIST digits classifier Edge detection module Pretrained ResNet50 inference TensorFlow Hub Import <p>End-to-end execution tests can be found in IREE's integrations/tensorflow/e2e/ directory.</p>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#troubleshooting","title":"Troubleshooting","text":"","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tensorflow/#missing-serving-signature-in-savedmodel","title":"Missing serving signature in SavedModel","text":"<p>Sometimes SavedModels are exported without explicit serving signatures. This happens by default for TensorFlow Hub SavedModels. However, serving signatures are required as entry points for IREE compilation flow. You can use Python to load and re-export the SavedModel to give it serving signatures. For example, for MobileNet v2, assuming we want the serving signature to be <code>predict</code> and operating on a 224x224 RGB image:</p> <pre><code>import tensorflow.compat.v2 as tf\nloaded_model = tf.saved_model.load('/path/to/downloaded/model/')\ncall = loaded_model.__call__.get_concrete_function(\n         tf.TensorSpec([1, 224, 224, 3], tf.float32))\nsignatures = {'predict': call}\ntf.saved_model.save(loaded_model,\n  '/path/to/resaved/model/', signatures=signatures)\n</code></pre> <p>The above will create a new SavedModel with a serving signature, <code>predict</code>, and save it to <code>/path/to/resaved/model/</code>.</p>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/","title":"TFLite Integration","text":"<p>IREE supports compiling and running TensorFlow Lite programs stored as TFLite FlatBuffers. These files can be imported into an IREE-compatible format then compiled to a series of backends.</p> <pre><code>graph LR\n  accTitle: TFLite to runtime deployment workflow overview\n  accDescr {\n    Programs start as TensorFlow Lite FlatBuffers.\n    Programs are imported into MLIR's TOSA dialect using iree-import-tflite.\n    The IREE compiler uses the imported MLIR.\n    Compiled programs are used by the runtime.\n  }\n\n  subgraph A[TFLite]\n    A1[FlatBuffer]\n  end\n\n  subgraph B[MLIR]\n    B1[TOSA]\n  end\n\n  C[IREE compiler]\n  D[Runtime deployment]\n\n  A -- iree-import-tflite --&gt; B\n  B --&gt; C\n  C --&gt; D</code></pre>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/#prerequisites","title":"Prerequisites","text":"<p>Install TensorFlow by following the official documentation:</p> <pre><code>python -m pip install tf-nightly\n</code></pre> <p>Install TensorFlow-Lite specific dependencies using pip:</p> <pre><code>python -m pip install \\\niree-compiler \\\niree-runtime \\\niree-tools-tflite\n</code></pre>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/#importing-and-compiling","title":"Importing and Compiling","text":"<p>IREE's tooling is divided into two components: import and compilation.</p> <ol> <li>The import tool converts the TFLite FlatBuffer to an IREE compatible form,   validating that only IREE compatible operations remain. Containing a combination   of TOSA and IREE operations.</li> <li>The compilation stage generates the bytecode module for a list of targets,   which can be executed by IREE.</li> </ol>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/#using-command-line-tools","title":"Using Command Line Tools","text":"<p>These two stages can be completed entirely via the command line.</p> <pre><code>WORKDIR=\"/tmp/workdir\"\nTFLITE_URL=\"https://storage.googleapis.com/iree-model-artifacts/tflite-integration-tests/posenet_i8.tflite\"\nTFLITE_PATH=${WORKDIR}/model.tflite\nIMPORT_PATH=${WORKDIR}/tosa.mlir\nMODULE_PATH=${WORKDIR}/module.vmfb\n\n# Fetch the sample model\nwget ${TFLITE_URL} -O ${TFLITE_PATH}\n\n# Import the sample model to an IREE compatible form\niree-import-tflite ${TFLITE_PATH} -o ${IMPORT_PATH}\n\n# Compile for the CPU backend\niree-compile \\\n--iree-input-type=tosa \\\n--iree-hal-target-backends=llvm-cpu \\\n${IMPORT_PATH} \\\n-o ${MODULE_PATH}\n</code></pre>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/#using-the-python-api","title":"Using the Python API","text":"<p>The example below demonstrates downloading, compiling, and executing a TFLite model using the Python API. This includes some initial setup to declare global variables, download the sample module, and download the sample inputs.</p> <p>Declaration of absolute paths for the sample repo and import all required libraries. The default setup uses the CPU backend as the only target. This can be reconfigured to select alternative targets.</p> <pre><code>import iree.compiler.tflite as iree_tflite_compile\nimport iree.runtime as iree_rt\nimport numpy\nimport os\nimport urllib.request\n\nfrom PIL import Image\n\nworkdir = \"/tmp/workdir\"\nos.makedirs(workdir, exist_ok=True)\n\ntfliteFile = \"/\".join([workdir, \"model.tflite\"])\njpgFile = \"/\".join([workdir, \"input.jpg\"])\ntfliteIR = \"/\".join([workdir, \"tflite.mlir\"])\ntosaIR = \"/\".join([workdir, \"tosa.mlir\"])\nbytecodeModule = \"/\".join([workdir, \"iree.vmfb\"])\n\nbackends = [\"llvm-cpu\"]\nconfig = \"local-task\"\n</code></pre> <p>The TFLite sample model and input are downloaded locally.</p> <pre><code>tfliteUrl = \"https://storage.googleapis.com/iree-model-artifacts/tflite-integration-tests/posenet_i8.tflite\"\njpgUrl = \"https://storage.googleapis.com/iree-model-artifacts/tflite-integration-tests/posenet_i8_input.jpg\"\n\nurllib.request.urlretrieve(tfliteUrl, tfliteFile)\nurllib.request.urlretrieve(jpgUrl, jpgFile)\n</code></pre> <p>Once downloaded we can compile the model for the selected backends. Both the TFLite and TOSA representations of the model are saved for debugging purposes. This is optional and can be omitted.</p> <pre><code>iree_tflite_compile.compile_file(\n  tfliteFile,\n  input_type=\"tosa\",\n  output_file=bytecodeModule,\n  save_temp_tfl_input=tfliteIR,\n  save_temp_iree_input=tosaIR,\n  target_backends=backends,\n  import_only=False)\n</code></pre> <p>After compilation is completed we configure the VmModule using the local-task configuration and compiled IREE module.</p> <pre><code>config = iree_rt.Config(\"local-task\")\ncontext = iree_rt.SystemContext(config=config)\nwith open(bytecodeModule, 'rb') as f:\n  vm_module = iree_rt.VmModule.from_flatbuffer(config.vm_instance, f.read())\n  context.add_vm_module(vm_module)\n</code></pre> <p>Finally, the IREE module is loaded and ready for execution. Here we load the sample image, manipulate to the expected input size, and execute the module. By default TFLite models include a single function named 'main'. The final results are printed.</p> <pre><code>im = numpy.array(Image.open(jpgFile).resize((192, 192))).reshape((1, 192, 192, 3))\nargs = [im]\n\ninvoke = context.modules.module[\"main\"]\niree_results = invoke(*args)\nprint(iree_results)\n</code></pre>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/#troubleshooting","title":"Troubleshooting","text":"<p>Failures during the import step usually indicate a failure to lower from TensorFlow Lite's operations to TOSA, the intermediate representation used by IREE. Many TensorFlow Lite operations are not fully supported, particularly those than use dynamic shapes. File an issue to IREE's TFLite model support project.</p>","tags":["Python","TensorFlow"]},{"location":"guides/ml-frameworks/tflite/#additional-samples","title":"Additional Samples","text":"<ul> <li> <p>The tflitehub folder in the iree-samples repository contains test scripts to compile, run, and compare various TensorFlow Lite models sourced from TensorFlow Hub.</p> </li> <li> <p>An example smoke test of the TensorFlow Lite C API is available here.</p> </li> </ul> Colab notebooks Text classification with TFLite and IREE <p>Todo</p> <p>Issue#3954: Add documentation for an Android demo using the Java TFLite bindings, once it is complete at not-jenni/iree-android-tflite-demo.</p>","tags":["Python","TensorFlow"]},{"location":"reference/","title":"Reference pages","text":""},{"location":"reference/#api-bindings","title":"API bindings","text":"<p>IREE offers API bindings for compiling and running programs from various languages.</p> <ul> <li>Index page</li> </ul>"},{"location":"reference/#mlir-dialects","title":"MLIR dialects","text":"<p>Automatically generated documentation for the MLIR dialects defined in the IREE repository.</p> <ul> <li>Index page</li> </ul>"},{"location":"reference/#other-topics","title":"Other topics","text":"<ul> <li>Glossary</li> <li>Optimization options</li> <li>Extensions</li> </ul>"},{"location":"reference/extensions/","title":"Extension mechanisms","text":"<p>Note</p> <p>Much of this describes provisions for extension within IREE but until the core of the system has settled little work will be done to fully flesh-out and document them in detail. A large majority of things that would make someone want to extend IREE can instead be accomplished much easier and performantly using native MLIR dialects that are then processed by the IREE compiler.</p>"},{"location":"reference/extensions/#guidelines","title":"Guidelines","text":"<p>IREE has a compiler and runtime separation, a multi-layered architecture, and split between execution of \"host code\" that schedules compute-heavy work and SPMD \"device code\" that performs the bulk of compute operations. Each axis has a different set of extension mechanisms that can be used independently or combined.</p>"},{"location":"reference/extensions/#extension-philosophy","title":"Extension philosophy","text":"<p>Organized below are some of the mechanisms IREE provides for extending the core compiler and runtime and when they should(n't) be used. The goal of these progressively lower-level extension mechanisms is to make it easier for users to fall into the pit of success:</p> <p>Quote</p> <p>\"a well-designed system makes it easy to do the right things and annoying (but not impossible) to do the wrong things.\" - Jeff Atwood</p> <p>The amount of engineering complexity for initial bring-up and maintenance increases with each subsequently lower-level approach and it is best to start from the top and exit as fast as possible: this is a choose-your-own-adventure where you're trying to escape the dungeon with both the loot and your limbs . Avoid the temptation of immediately dropping down to making external C calls at runtime because that's how it's been done before as it's easier, more robust, and more performant to use the system as it is intended to be used.</p>"},{"location":"reference/extensions/#when-to-extend","title":"When to extend","text":"<p>The primary goal when extending any framework should first be to avoid extending it at all. There is no mechanism that is free - whether in terms of engineering effort to develop and maintain over time, include in compiler deployments, or include in runtime deployments. As a system scales in deployment configurations the available mechanisms for extension increase but so too does the chaos introduced by extensions that do not also scale with that design. Users are the only ones who can determine the tradeoffs they are willing to accept: for example, the mechanism to extend device code with a custom runtime call to a C function does not work on GPUs and gets significantly more complicated on CPUs as sandboxes/enclaves are used - but if the user scenario is for local process CPU-only execution that may not matter.</p>"},{"location":"reference/extensions/#where-to-extend-inputscompilerruntime","title":"Where to extend (inputs/compiler/runtime)","text":"<p>Consider in normal software development when one would choose to write more code (possibly packaging it into a reusable library) vs. changing the programming language or compiler they are using to compile their code vs. changing the operating systems their code runs on. The further one gets from the problem they are trying to solve the more work, coordination, and maintenance is involved and though there are reasons to make changes across the stack they should be done only when a simpler solution would not suffice.</p> <p>An author will retain more control over their logic the closer they sit to the inputs to the compiler. IREE provides several mechanisms that try to keep control with the author and robust to changes in IREE or MLIR internals and it is strongly encouraged that those looking to extend take those routes first. Contributions that help everyone are very welcome but do have a higher cost and it's often much easier to design and justify upstream changes with working examples in forks or at higher levels of the stack.</p>"},{"location":"reference/extensions/#where-to-extend-hostdevice","title":"Where to extend (host/device)","text":"<p>From a performance perspective the rule is to colocate code with the data it is acting on: tensor data, for example, should almost exclusively be manipulated by device code as tensors live on device. Attempting to use tensor data with host code will result in synchronization points and host/device transfers that can decimate performance. This can lead to seemingly paradoxical situations where swapping out compiler-generated code for a human-authored \"fast path\" can be slower than even the most naive compiler results. An important thing to keep in mind with compilers is that it is exceedingly difficult to produce code by hand that is consistently more performant across a broad range of deployments and the first temptation should always be to improve the compiler - extending it via other mechanisms when not required by the task is often just premature optimization.</p>"},{"location":"reference/extensions/#1-target-iree-input-dialects","title":"1. Target IREE input dialects","text":"<p>TL;DR</p> <p>Convert your custom ops into standard MLIR dialects.</p> <pre><code>+------------+      +--------+      +---------------+\n| Your input | -+-&gt; |  iree  | -+-&gt; | IREE compiler |\n+------------+  |   +--------+  |   +---------------+\n                |   +--------+  |\n                +-&gt; | linalg | -+\n                |   +--------+  |\n                |      ....     |\n</code></pre> <p>The easiest, cleanest, and most robust path to extend IREE is to make use of what MLIR is designed for: composing dialects and converting between them. IREE supports several input dialects such as <code>tosa</code>, <code>mhlo</code>, <code>linalg</code>, and the standard <code>arith</code>, <code>math</code>, <code>tensor</code>, and <code>scf</code> dialects. Any source IR that can be turned into that mix of dialects (directly or transitively) will work with the whole IREE pipeline for all deployment configurations and targets. If possible to express the computation in this form it will always be the best route to getting small deployments without the need to modify or include any additional code at runtime and run on all device types and execution modes.</p> <p>This mechanism can also be layered with any of the subsequent lower-level ones: if some part of the operation runs on the host and some part on device then decomposing it such that it contains as many standard ops for flow control as possible and linear algebra/custom ops for the dense math will reduce the engineering effort required on both sides and lead to an easier to maintain solution even if lower-level extension is required.</p> <p>A large majority of classic ML \"custom ops\" can be accomplished with this approach. When bringing up projects built on IREE it's best to concisely describe the operation in more elemental mathematical representations and then add optimizations where required knowing that things will still work even if those optimizations never happen.</p>"},{"location":"reference/extensions/#pros","title":"Pros","text":"<ul> <li>No IREE compiler or runtime code changes required.<ul> <li>Can use standard IREE packaged releases and tools.</li> <li>No versioning issues at runtime.</li> </ul> </li> <li>IREE's host/device partitioning can partition your code.</li> <li>Fusion and other compiler techniques (CSE/DCE/inlining/etc) work on your code.</li> <li>All target backends (CPU/GPU/accelerators/enclaves/etc) work.</li> </ul>"},{"location":"reference/extensions/#cons","title":"Cons","text":"<ul> <li>Input dialects cannot natively represent all possible programs (such as file   IO and other syscalls).</li> <li>Performance-sensitive host code (b-trees and other in-memory databases) will   run through the slower VM paths if not authored as dense compute.</li> </ul>"},{"location":"reference/extensions/#when-to-use","title":"When to use","text":"<ul> <li> Targeting multiple MLIR toolchains of which IREE is just   one (as little to no IREE-specific code is required).</li> <li> Operation represents host code in addition to device code.</li> <li> All code is known statically or symbolically at   compile-time (instead of independently versioned libraries at runtime).</li> <li> Complex high-performance code not representable as linear algebra.</li> <li> External runtime interactions (file/network/user IO). Use   custom modules.</li> </ul>"},{"location":"reference/extensions/#implementation","title":"Implementation","text":"<p>To make use of this approach one just needs to follow the standard MLIR dialect conversion behavior: add a dialect with ops, add a conversion pass, and run that pass before providing the resulting IR to the IREE compiler. See Creating a Dialect.</p> <p>Think of this like authoring C++ sources with templates that you compile into your application: Clang (and LLVM beyond) don't know about your library details and instead just process it as it would any other code. You can take the same source and pass it to GCC and it'll be robust to underlying changes in the system.</p>"},{"location":"reference/extensions/#2-extend-host-code-with-custom-modules","title":"2. Extend host code with custom modules","text":"<p>TL;DR</p> <p>Import MLIR functions in the compiler and custom modules at runtime.</p> <pre><code>// Main user module compiled by IREE:\nmodule @model {\n  // Declare a synchronous external function:\n  func.func private @my_custom_module.sync_func(%input: tensor&lt;?xf32&gt;) -&gt; i32\n  // Declare an asynchronous external function:\n  func.func private @my_custom_module.async_func(%input: tensor&lt;?xf32&gt;) -&gt; tensor&lt;?xf32&gt; attributes {\n    iree.abi.model = \"coarse-fences\",\n    nosideeffects\n  }\n  func.func @predict() {\n    ...\n    // Call a synchronous/blocking external function:\n    %sync_result = call @my_custom_module.sync_func(%sync_input) : (tensor&lt;?xf32&gt;) -&gt; i32\n    ...\n    ...\n    // Call an asynchronous/non-blocking external function:\n    %async_result = call @my_custom_module.async_func(%async_input) : (tensor&lt;?xf32&gt;) -&gt; tensor&lt;?xf32&gt;\n    ...\n  }\n}\n</code></pre> <p>IREE provides dynamic linking at runtime via its VM interfaces. For code that runs on the host and requires syscalls or calling out to existing libraries - such as file IO, text processing, and JPEG decoding - this is an easy way to interop without paying attention to the more complex details of device code. An IREE module compiled using custom modules is portable and dynamically deployable so long as the custom module is registered at runtime.</p> <p>This approach conceptually matches what normal native binaries do in an OS: imports are declared and at runtime they are resolved based on the available exports of modules in the system. Just as with normal systems engineering design of the API between modules is up to the user and depending on rigor can have several pitfalls but these problems and their solutions are not IREE specific and anyone who has designed a shared library interface can apply the same rules here in IREE around versioning, performance, etc. One does not add 2 integers via a syscall and the same holds here: custom modules and the functions within should perform a large amount of work to hide overheads involved in the cross-module calls and users must be aware that the compiler cannot optimize across the call boundaries.</p> <p>See the synchronous tensor I/O and asynchronous tensor I/O samples.</p>"},{"location":"reference/extensions/#pros_1","title":"Pros","text":"<ul> <li>No IREE compiler code changes required.</li> <li>Produced artifacts are portable across IREE deployment configurations.</li> <li>Full system access is allowed - the VM just calls external functions.</li> <li>Runtime modules can be implemented (via shims) in other languages/runtimes.</li> </ul>"},{"location":"reference/extensions/#cons_1","title":"Cons","text":"<ul> <li>Custom modules must be registered at runtime by the user.</li> <li>The VM custom module ABI goo must be authored by the user (such as with JNI or   pybind to move between java/python and C).</li> <li>All custom module code must be compiled and deployed regardless of how much   any modules use. The granularity of modules and their versioning is up to the   user.</li> <li>Custom module code cannot be optimized by the IREE compiler to avoid   host/device readbacks and unnecessary data type conversion.</li> </ul>"},{"location":"reference/extensions/#when-to-use_1","title":"When to use","text":"<ul> <li> Interactions with large libraries or system calls.</li> <li> Performance-sensitive host code that cannot easily be   represented as device code (like UTF-8 string transformation using libicu).</li> <li> Extensively using tensor resources.</li> </ul>"},{"location":"reference/extensions/#implementation_1","title":"Implementation","text":"<p>The runtime portion requires that the code be exported to the VM system by way of an <code>iree_vm_module_t</code> interface. A low-level native interface exists with minimal overhead and is used for example by the IREE HAL itself. There is also a C++ wrapper that is significantly easier to work with however it needs some performance improvements.</p> <p>Full end-to-end examples can be found under <code>samples/custom_modules/</code>:</p> <ul> <li>The basic sample shows how to add VM modules with custom types and take advantage of ABI features like fallback functions and optional imports.</li> <li>The synchronous tensor I/O sample shows a call taking and returning a tensor and performing blocking work.</li> <li>The asynchronous tensor I/O sample shows the same thing but with fences for asynchronous scheduling.</li> </ul>"},{"location":"reference/extensions/#3-extend-target-specific-device-conversion-patterns","title":"3. Extend target-specific device conversion patterns","text":"<p>TL;DR</p> <p>Add patterns to <code>iree/Compiler/Codegen/</code> to emit target code.</p> <p>The easiest and most robust path for specializations of device code is to emit such code mixed with the IREE compiler generated code at the highest possible level of abstraction within the target pipeline. For example, if the code can be represented with the <code>vector</code> dialect then inserting conversion patterns between <code>linalg</code> and <code>vector</code> enables the emitted code to be specialized further based on user configuration and optimized with the full set of available passes that run in the pipeline. For each level lower one goes the more flexibility they gain such as being able to emit inline assembly blocks that do anything while trading off generality and multi-targeting applicability.</p> <p>How much the tradeoff matters is based on the behavior of the extension. If a pattern changing a transcendental function to an approximation can operate at the vector level then all IREE deployment targets can benefit from the pattern and as new targets are made available they will automatically receive the benefits. In contrast, a pattern at the vector level that turns generic vector operations into architecture-specific LLVM intrinsics by its nature only pertains to a single target family and can be done at a lower level. As a rule of thumb if a particular pattern is going to need ~N implementations for ~N targets that are all mostly the same it's better to try to move that higher in the stack.</p> <p>At this point the complexity of extending things is still fairly constrained: a C++ pass or pattern is verified with normal lit tests and can be upstreamed easily either into MLIR or IREE (a large number of IREE patterns are upstreamed, benefiting all users of MLIR). Cross-compilation and versioning are not a factor and the IREE artifacts can be considered durable at a coarse level (outside of major target architectural changes).</p> <p>Note that depending on the target there are various mechanisms for representing code in MLIR, up to including inline assembly snippets in IR via <code>llvm.inline_asm</code>.</p>"},{"location":"reference/extensions/#pros_2","title":"Pros","text":"<ul> <li>Not limited to what is possible to represent in any particular MLIR dialect.</li> <li>Rich target configuration available; multiple passes can contribute info.</li> <li>Produced executable binaries are hermetic and no runtime changes are required.</li> <li>Specialization can happen in MLIR dialects like <code>linalg</code> or <code>vector</code> as well   as target-specific representations like SPIR-V and LLVM IR.</li> <li>The compiler can perform deep optimizations across both the generated code and   the provided code (hoisting/loop invariant code motion/cse/etc).</li> </ul>"},{"location":"reference/extensions/#cons_2","title":"Cons","text":"<ul> <li>Requires implementing the patterns as code in the IREE compiler or via TBD   interfaces.</li> </ul>"},{"location":"reference/extensions/#when-to-use_2","title":"When to use","text":"<ul> <li> Code that must be emitted during target lowering - such as   something optimizing for a particular CPU architecture.</li> <li> Hot code mixed with generated code at a fine granularity   (within the innermost loop).</li> <li> External existing hand-authored libraries. Either statically   or dynamically link instead.</li> </ul>"},{"location":"reference/extensions/#implementation_2","title":"Implementation","text":"<p>There are several ways to author patterns and passes in MLIR. As examples:</p> <ul> <li>A majority of patterns are authored in C++ using PatternRewriter.</li> <li>PDL is an MLIR-based way to   express rewrite operations with strong typing, compile-time verification, and   easily-readable and less-verbose IR.</li> <li><code>linalg</code> uses a python-based DSL   for defining some of its extended ops.</li> </ul> <p>There are many examples within both MLIR and IREE, one specifically being the polynomial approximation expansion patterns.</p>"},{"location":"reference/extensions/#4-include-external-target-specific-device-code","title":"4. Include external target-specific device code","text":"<p>TL;DR</p> <p>Statically link external object files into IREE executables.</p> <p>For large bodies of existing device code or library calls that are available for static linkage the work involved to reimplement them at higher levels of the stack can be cost prohibitive even if it leads to better results. In these cases just as with a normal toolchain one would just want to declare an external function, call it, and add the object file to the linker command line. In IREE the same can be performed by way of taking compatible bitcode or native object files and linking them in with the generated code. An MLIR pattern would declare and emit the call and the target-specific IREE linker would pull in the objects.</p> <p>As the linking behavior varies per target (for example, some targets like SPIR-V don't have traditional linkers) how this is performed is up to the IREE target backends. The complexity involved in producing the object files to link will also vary per-backend and the complexity of the deployment: cross-compiling for multiple architectures or compilation modes (ASAN, etc) will require unique copies of the object files matching that precise configuration.</p> <p>At this point generality is largely out as is the ability to cleanly upstream such files. It should be apparent how a few dozen lines of C++ or PDL that avoids the need for any of this complexity is more appealing. In extremely specific cases of a single platform/architecture/version for a single program deployed via a specific artifact composition it's not so bad but IREE is designed such that extreme specificity is an optional mode of the more general solution. This does not mean this mechanism is not useful in some situations and only that it should be a last-resort when one of the easier to manage solutions is not viable - not a shortcut to avoid writing some C++ patterns.</p>"},{"location":"reference/extensions/#pros_3","title":"Pros","text":"<ul> <li>Works with hand-authored code in compatible object files from any toolchain.</li> <li>No IREE runtime changes required.<ul> <li>All deployment modes still work, including multi-targeting.</li> <li>No versioning concerns as custom code is included in artifacts.</li> </ul> </li> </ul>"},{"location":"reference/extensions/#cons_3","title":"Cons","text":"<ul> <li>Users must provide per-target precompiled object files on disk.</li> <li>IREE compiler changes are still needed for generating the external calls.</li> <li>Though LTO may be able to optimize across the calls it is not guaranteed.</li> </ul>"},{"location":"reference/extensions/#when-to-use_3","title":"When to use","text":"<ul> <li> Existing math libraries or architecture-specific functions   that cannot be ported into a more MLIR-friendly form.</li> <li> Mixing in hand-authored code written in C/rust/etc with   generated code from MLIR.</li> <li> External code can be represented as either <code>linalg</code>,   <code>vector</code>, or LLVM IR. Use target-specific conversion patterns instead.</li> <li> External code size is large and unlikely to benefit from   link-time optimizations (such as something like libjpeg). Dynamically link   instead.</li> </ul>"},{"location":"reference/extensions/#implementation_3","title":"Implementation","text":"<p>As the linking behavior varies per target backend there is no general solution at this level: if targeting the CPU then the system native linker or lld need to be provided the object files, while SPIR-V will need to merge the SPIR-V binaries directly, and Metal shader libraries will need to be constructed with the Apple-specific <code>metallib</code> tooling. Producing these files and performing the linking is outside the scope of IREE.</p> <p>If the files can be acquired then compiler changes will be required to emit calls to them and invoke the linker with the the files.</p> <p>On the CPU an alternative is to use the static library output mode where IREE produces an object file and then the user invokes the linker themselves; this still requires the compiler changes to emit the calls but avoids needing to teach the compiler how to link the files.</p>"},{"location":"reference/extensions/#5-dynamically-link-target-specific-device-code-cpu-only","title":"5. Dynamically link target-specific device code (CPU only)","text":"<p>TL;DR</p> <p>Dynamically link external C functions at runtime from device code.</p> <p>It is pitch black. You are likely to be eaten by a grue.</p> <p>This is the lowest-level integration in the system and is designed to act as an escape hatch and - as with any emergency escape hatch - it's not designed for ergonomics. Users should try first to come in through the door and attempting to use this mechanism should trigger alarms about the approach being attempted.</p> <p>IREE's execution model for device code and native machine binary deployment mechanisms are designed with several constraints in order to make all of the above approaches possible and performant. Calling arbitrary C functions from deep within the system can introduce subtle (and not-so-subtle) bugs that are extremely difficult to track down and versioning between the compiler emitting the calls and the runtime providing the implementations can cause skew unless held carefully. Consider the methods added here like syscalls in that they must be extremely focused and if they are ever likely to change (including being removed) then care will be needed just as with versioning or redirecting a syscall. Designing good stable interfaces is hard and a classic pit of failure.</p> <p>Some things to note:</p> <ul> <li>Device code executes in a tiled fashion and single dispatches may invoke the   same function many times from many threads concurrently to perform   the larger work.</li> <li>Tiles may execute in any order and on any thread; performing fine-grained   locking within the tile can lead to deadlocks.</li> <li>Device code is stateless in order to allow for access restrictions and caching   across multiple loaded models - any library state required must be externally   managed via process globals.</li> <li>Device code may be running out-of-process (sandbox/enclave) and the library   functions must be available where the dispatches run and not where they are   launched (such as being linked into the sandbox binary, if separate from the   main process binary).</li> <li>The stack must be used to pass arguments/results to external calls via a   single pointer and there is no libffi-like functionality for magically calling   arbitrary C functions. Users must provide the shims they need.</li> <li>Thread-local storage is unavailable in the called code (it may be usable, but   it is not guaranteed it'll work on all platforms and leaks are likely).</li> <li>No heap allocator is provided and the use of libc malloc is unsupported.</li> </ul> <p>Most of the constraints here come from the SPMD parallelism model, platform-agnostic deployment format, and overall data-oriented design of IREE. Code operating in this fashion has a certain shape and that is usually not the same as big legacy single-threaded CPU-focused BLAS libraries that perform their own caching, internal thread and state management, and other shenanigans. IREE is not designed to wrap such things and if any of these notes are issues it is more an indicator that the approach needs adjustment than anything else. Trying to bypass or workaround the constraints is possible - after all IREE is an open source project and any user is welcome to fork it - but unsupported by the core IREE team.</p>"},{"location":"reference/extensions/#pros_4","title":"Pros","text":"<ul> <li>Function resolution at runtime is orthogonal to compiler target specification.</li> <li>Machine code can be shared between the application and IREE artifacts.</li> </ul>"},{"location":"reference/extensions/#cons_4","title":"Cons","text":"<ul> <li>IREE compiler and runtime must both be modified.</li> <li>Deeper integration with the IREE codegen compiler infrastructure required.</li> <li>ABI versioning complexity between compiler and runtime.</li> <li>Runtimes must ship the imports for the lifetime of any artifact compiled to   use them.<ul> <li>Humans are bad at predicting the future.</li> <li>Using the same artifact in different binaries at runtime requires changes   to each binary - including those that may not be owned by the person   producing the artifact.</li> <li>Weak imports and conditional usage can help but still leads to bloat.</li> </ul> </li> </ul>"},{"location":"reference/extensions/#when-to-use_4","title":"When to use","text":"<ul> <li> Calling into opaque closed-source BLAS-like microkernel   libraries.</li> <li> Any other cases covered above can be used, especially   microkernels that can be represented in MLIR or as statically linked   libraries.</li> </ul>"},{"location":"reference/extensions/#implementation_4","title":"Implementation","text":"<p>The compiler is changed to produce calls to imports via a dynamic import table provided to each dispatch function. The import table is declared in the executable library for use at runtime. Runtime applications register an import provider to resolve named symbols in the import table to C functions that marshal arguments and results.</p> <p>The compiler-side needs some additional work but an example is included here: Issue 7504. The runtime-side is complete and resolution is performed by a user-supplied <code>iree_hal_executable_import_provider_t</code>.</p>"},{"location":"reference/glossary/","title":"Glossary","text":"<p>IREE exists in an ecosystem of projects and acts as a bridge between machine learning frameworks and a variety of hardware platforms. This glossary outlines some of those projects and technologies.</p> <p>Something missing?</p> <p>Don't see a project of technology here that you think should be? We welcome contributions on our GitHub page!</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#jax","title":"JAX","text":"<p>JAX is Python framework supporting high-performance machine learning research by bridging automatic differentiation and ML compilers like XLA and IREE.</p> <p>See the JAX Integration guide for details on how to use JAX programs with IREE.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#mlir","title":"MLIR","text":"<p>Multi-Level Intermediate Representation (MLIR) is the compiler framework that IREE is built around. Beyond the tooling this includes a set of common dialects and transformations that IREE utilizes for its code generation system.</p> <p>For general discussion on MLIR see the project's discourse forum.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#linalg","title":"Linalg","text":"<p>Linalg is an MLIR dialect that defines Linear Algebra operations in a generalized fashion by modeling iteration spaces together with compute payloads. Linalg includes a set of commonly used operations as well as generic interfaces.</p> <p>IREE uses the Linalg dialect during its code generation pipeline to define tensor operations then generate loop structures for its various backend targets.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#openxla","title":"OpenXLA","text":"<p>OpenXLA is a community-driven, open source ML compiler ecosystem.</p> <p>IREE is one project under the OpenXLA GitHub Organization, and it interfaces with many of the other projects, such as StableHLO.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#pytorch","title":"PyTorch","text":"<p>PyTorch is an optimized tensor library for deep learning.</p> <p>PyTorch uses the Torch-MLIR project to interface with projects like IREE. See the PyTorch Integration guide for details on how to use PyTorch programs with IREE.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#spir-v","title":"SPIR-V","text":"<p>SPIR-V is a shader and kernel intermediate language for expressing parallel computation typically used for GPUs. It serves as a hardware agnostic assembly format for distributing complex, computationally intensive programs.</p> <p>IREE uses the SPIR-V MLIR Dialect in its code generation pipeline for Vulkan and other compute APIs.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#stablehlo","title":"StableHLO","text":"<p>StableHLO is a set of versioned high-level operations (HLOs) for ML models with backward and forward compatibility guarantees. StableHLO aims to improve interoperability between frameworks (such as TensorFlow, JAX, and PyTorch) and ML compilers.</p> <p>StableHLO has both a specification and an MLIR dialect.</p> <p>IREE uses the StableHLO MLIR Dialect as one of its input formats.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#tosa","title":"TOSA","text":"<p>Tensor Operator Set Architecture (TOSA) provides a set of tensor operations commonly employed by Deep Neural Networks. TOSA defines accuracy and compatibility constraints so frameworks that use it can trust that applications will produce similar results on a variety of hardware targets.</p> <p>TOSA has both a specification and an MLIR dialect.</p> <p>IREE uses the TOSA MLIR dialect as one of its input formats.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/glossary/#tflite","title":"TFLite","text":"<p>TensorFlow Lite (TFLite) is a library for deploying models on mobile and other edge devices.</p> <p>IREE supports running TFLite programs that have been imported into MLIR using the TOSA dialect. See the TFLite Integration guide for details on how to use TFLite programs with IREE.</p> <p>IREE also has bindings for the TFLite C API, see the <code>runtime/bindings/tflite/</code> directory for details.</p>","tags":["JAX","PyTorch","TensorFlow"]},{"location":"reference/optimization-options/","title":"Optimization options","text":"<p>This page documents various supported flags for optimizing IREE programs. Each is presented with its English name, flag to enable/disable, and default state.</p> <p>These flags can be passed to the:</p> <ul> <li><code>iree-compile</code> command line tool</li> <li><code>extra_args=[\"--flag\"]</code> argument to <code>iree.compiler.tools</code> Python wrappers</li> <li>In-process Python compiler API   <code>iree.compiler.transforms.iree-compile.CompilerOptions(\"--flag\", \"--flag2\")</code>   constructor</li> <li><code>ireeCompilerOptionsSetFlags()</code> compiler C API function</li> </ul>"},{"location":"reference/optimization-options/#high-level-program-optimizations","title":"High level program optimizations","text":""},{"location":"reference/optimization-options/#constant-evaluation-iree-opt-const-eval-off","title":"Constant evaluation (<code>--iree-opt-const-eval</code> (off))","text":"<p>Performs compile-time evaluation of any global initializers which produce the initial values for global constants, storing the global directly in the program as constant data. This extracts such constant program fragments and recursively compiles them, using the runtime to evaluate the results.</p> <p>Note that this only has any effect on computations in module initializer functions, not free-standing operations in the program which may produce constant-derived results. See <code>--iree-opt-const-expr-hoisting</code> for options to optimize these.</p>"},{"location":"reference/optimization-options/#constant-expression-hoisting-iree-opt-const-expr-hoisting-off","title":"Constant expression hoisting (<code>--iree-opt-const-expr-hoisting</code> (off))","text":"<p>Identifies all trees of constant expressions in the program and uses a heuristic to determine which would be profitable to hoist into global initializers for evaluation at module load. Together with <code>--iree-opt-const-eval</code>, this will convert eligible trees of expressions to purely static data embedded in the module.</p> <p>The heuristic is currently relatively primitive, using static information to disable hoisting of leaf operations which are metadata only (i.e. broadcasts, etc) or are expected to fold away as part of operator fusion. Notably, the current heuristic is likely to pessimize module size in the case of complicated programs with trees of constant, large tensors.</p>"},{"location":"reference/optimization-options/#numeric-precision-reduction-iree-opt-numeric-precision-reduction-off","title":"Numeric precision reduction (<code>--iree-opt-numeric-precision-reduction</code> (off))","text":"<p>Analyzes program constant data and program flow to identify math operations which can be safely evaluated with reduced precision (currently with a minimum of 8bit integers but being extended to infer any bit depth) and inserts appropriate casts. In conjunction with Constant Expression Hoisting, Constant Evaluation and other automatic optimizations, this can produce programs where large amounts (up to the whole) have had their numeric operations and constant data rewritten to lower precision types.</p> <p>This feature is actively evolving and will be the subject of dedicated documentation when ready.</p>"},{"location":"reference/optimization-options/#strip-debug-assertions-iree-opt-strip-assertions-off","title":"Strip Debug Assertions (<code>--iree-opt-strip-assertions</code> (off))","text":"<p>Strips all <code>std.assert</code> ops in the input program after useful information for optimization analysis has been extracted. Assertions provide useful user-visible error messages but can prevent critical optimizations. Assertions are not, however, a substitution for control flow and frontends that want to check errors in optimized release builds should do so via actual code - similar to when one would <code>if (foo) return false;</code> vs. <code>assert(foo);</code> in a normal program.</p>"},{"location":"reference/bindings/","title":"API bindings","text":"<p>API bindings allow for programmatic use of IREE's compiler and runtime components. The core IREE project is written in C1, allowing for API bindings to be written in a variety of other languages.</p> <p>Something missing?</p> <p>Want to use another language? Looking for something specific out of one of those already listed?</p> <p>We welcome discussions on our communication channels and contributions on our GitHub page!</p>"},{"location":"reference/bindings/#official-api-bindings","title":"Official API bindings","text":"<p>Members of the core project team and OpenXLA partners maintain these official bindings:</p> Language Compiler API? Runtime API? Published packages? C/C++  Supported  Supported  Unsupported Python  Supported  Supported  Supported JavaScript  Experimental  Experimental  Unsupported"},{"location":"reference/bindings/#cc","title":"C/C++","text":"<p>See the C API reference page.</p>"},{"location":"reference/bindings/#python","title":"Python","text":"<p>See the Python reference page.</p>"},{"location":"reference/bindings/#javascript","title":"JavaScript","text":"<ul> <li>JavaScript bindings for WebAssembly and WebGPU are under development in IREE's <code>experimental/web/</code> directory.</li> </ul>"},{"location":"reference/bindings/#unofficial-api-bindings","title":"Unofficial API bindings","text":"<p>Members of our developer community have authored bindings using other languages:</p> Language Compiler API? Runtime API? Published packages? Julia  Experimental  Experimental  Unsupported Rust  Unsupported  Experimental  Experimental"},{"location":"reference/bindings/#julia","title":"Julia","text":"<ul> <li>Coil.jl is an experimental package to lower and execute Julia tensor operations to IREE.</li> </ul>"},{"location":"reference/bindings/#rust","title":"Rust","text":"<ul> <li>iree-rs is a crate containing rustic bindings for the IREE runtime.</li> </ul> <ol> <li> <p>with some C++ tools and utilities\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/bindings/c-api/","title":"C API bindings","text":""},{"location":"reference/bindings/c-api/#overview","title":"Overview","text":"<p>The IREE compiler and IREE runtime both have their own C/C++ APIs for use in other projects.</p> <p>Note</p> <p>There are multiple ways to distribute and depend on C/C++ projects, each with varying levels of portability, flexibility, and toolchain compatibility. IREE aims to support common configurations and platforms.</p>"},{"location":"reference/bindings/c-api/#compiler-api","title":"Compiler API","text":"<p>The IREE compiler is structured as a monolithic shared object with a dynamic plugin system allowing for extensions. The shared object exports symbols for versioned API functions.</p> <pre><code>graph TD\n  accTitle: IREE compiler linkage model diagram\n  accDescr {\n    The libIREECompiler.so or IREECompiler.dll shared object contains pipelines,\n    target backends, and general passes as private implementation details.\n    Compiler plugins interface with the compiler shared object to extend it with\n    custom targets, dialects, etc.\n    Applications interface with the compiler shared object through the compiler\n    C API's exported symbols.\n  }\n\n  subgraph compiler[libIREECompiler.so / IREECompiler.dll]\n    pipelines(\"Pipelines\n\n    \u2022 Flow\n    \u2022 Stream\n    \u2022 etc.\")\n\n    targets(\"Target backends\n\n    \u2022 llvm-cpu\n    \u2022 vulkan-spirv\n    \u2022 etc.\")\n\n    passes(\"General passes\n\n    \u2022 Const eval\n    \u2022 DCE\n    \u2022 etc.\")\n  end\n\n  plugins(\"Compiler plugins\n\n    \u2022 Custom targets\n    \u2022 Custom dialects\n    \u2022 etc.\")\n\n  application(Your application)\n\n  compiler &lt;-- \"Plugin API&lt;br&gt;(static or dynamic linking)\" --&gt; plugins\n  compiler -. \"Compiler C API&lt;br&gt;(exported symbols)\" .-&gt; application</code></pre> <p>API definitions can be found in the following locations:</p> Source location Overview <code>iree/compiler/embedding_api.h</code> Top-level IREE compiler embedding API <code>iree/compiler/PluginAPI/</code> directory IREE compiler plugin API <code>mlir/include/mlir-c/</code> directory MLIR C API headers"},{"location":"reference/bindings/c-api/#concepts","title":"Concepts","text":"<p>The compiler API is centered around running pipelines to translate inputs to artifacts. These are modeled via sessions, invocations, sources, and outputs.</p> <pre><code>stateDiagram-v2\n  accTitle: IREE compiler session and invocation state diagram\n  accDescr {\n    Input files are opened (or buffers are wrapped) as sources in a session.\n    Sources are parsed into invocations, which run pipelines.\n    Output files are written (or buffers are mapped) for compilation artifacts.\n  }\n\n  direction LR\n  InputFile --&gt; Source1 : open file\n  InputBuffer --&gt; Source2 : wrap buffer\n\n  state Session {\n    Source1 --&gt; Invocation1\n    Source1 --&gt; Invocation2\n    Source2 --&gt; Invocation3\n    Invocation1 --&gt; Invocation1 : run pipeline\n    Invocation2 --&gt; Invocation2 : run pipeline\n    Invocation3 --&gt; Invocation3 : run pipeline\n  }\n\n  Invocation1 --&gt; OutputFile1   : write file\n  Invocation2 --&gt; OutputBuffer1 : map memory\n  Invocation3 --&gt; OutputBuffer2 : map memory</code></pre>"},{"location":"reference/bindings/c-api/#sessions","title":"Sessions","text":"<p>A session represents a scope where one or more invocations can be executed.</p> <ul> <li>Internally, sessions consist of an <code>MLIRContext</code> and a private set of   options.</li> <li>Sessions may activate available plugins based on their options.</li> </ul>"},{"location":"reference/bindings/c-api/#invocations","title":"Invocations","text":"<p>An invocation represents a discrete run of the compiler.</p> <ul> <li>Invocations run pipelines, consisting of passes, to translate from   sources to outputs.</li> </ul>"},{"location":"reference/bindings/c-api/#sources","title":"Sources","text":"<p>A source represents an input program, including operations and data.</p> <ul> <li>Sources may refer to files or buffers in memory.</li> </ul>"},{"location":"reference/bindings/c-api/#outputs","title":"Outputs","text":"<p>An output represents a compilation artifact.</p> <ul> <li>Outputs can be standalone files or more advanced streams.</li> </ul>"},{"location":"reference/bindings/c-api/#plugins","title":"Plugins","text":"<p>A plugin extends the compiler with some combination of target backends, options, passes, or pipelines.</p>"},{"location":"reference/bindings/c-api/#usage","title":"Usage","text":"<p>Under construction, more coming soon</p> <p>Tip - building from source</p> <p>When building from source, some components may be disabled to reduce binary size and improve build time. There are also options for using your own LLVM or linking in external target backends.</p>"},{"location":"reference/bindings/c-api/#samples","title":"Samples","text":"Project Source Description openxla-pjrt-plugin <code>iree_compiler.cc</code> JIT engine connecting TensorFlow and JAX to IREE"},{"location":"reference/bindings/c-api/#runtime-api","title":"Runtime API","text":"<p>The IREE runtime is structured as a modular set of library components. Each component is designed to be linked into applications directly and compiled with LTO style optimizations.</p> <p>The low level library components can be used directly or through a higher level API.</p> High level APILow level API <p>The high level 'runtime' API sits on top of the low level components. It is relatively terse but does not expose the full flexibility of the underlying systems.</p> <pre><code>graph TD\n  accTitle: IREE runtime high level API diagram\n  accDescr {\n  The IREE runtime includes 'base', 'HAL', and 'VM' components, each with\n  their own types and API methods.\n  A high level \"runtime API\" sits on top of these component APIs.\n  Applications can interface indirectly with the IREE runtime via this\n  high level runtime API.\n  }\n\n  subgraph iree_runtime[IREE Runtime]\n    subgraph base\n      base_types(\"Types\n\n      \u2022 allocator\n      \u2022 status\n      \u2022 etc.\")\n    end\n\n    subgraph hal[HAL]\n      hal_types(\"Types\n\n      \u2022 buffer\n      \u2022 device\n      \u2022 etc.\")\n\n      hal_drivers(\"Drivers\n\n      \u2022 local-*\n      \u2022 vulkan\n      \u2022 etc.\")\n    end\n\n    subgraph vm[VM]\n      vm_types(\"Types\n\n      \u2022 context\n      \u2022 invocation\n      \u2022 etc.\")\n    end\n\n    runtime_api(\"Runtime API\n\n    \u2022 instance\n    \u2022 session\n    \u2022 call\")\n\n    base_types &amp; hal_types &amp; hal_drivers &amp; vm_types --&gt; runtime_api\n  end\n\n  application(Your application)\n\n  runtime_api --&gt; application</code></pre> <p>Each runtime component has its own low level API. The low level APIs are typically verbose as they expose the full flexibility of each underlying system.</p> <pre><code>graph TD\n  accTitle: IREE runtime low level API diagram\n  accDescr {\n    The IREE runtime includes 'base', 'HAL', and 'VM' components, each with\n    their own types and API methods.\n    Applications can interface directly with the IREE runtime via the low\n    level component APIs.\n  }\n\n  subgraph iree_runtime[IREE Runtime]\n    subgraph base\n      base_types(\"Types\n\n      \u2022 allocator\n      \u2022 status\n      \u2022 etc.\")\n    end\n    subgraph hal[HAL]\n      hal_types(\"Types\n\n      \u2022 buffer\n      \u2022 device\n      \u2022 etc.\")\n\n      hal_drivers(\"Drivers\n\n      \u2022 local-*\n      \u2022 vulkan\n      \u2022 etc.\")\n    end\n    subgraph vm[VM]\n      vm_types(\"Types\n\n      \u2022 context\n      \u2022 invocation\n      \u2022 etc.\")\n    end\n  end\n\n  application(Your application)\n\n  base_types &amp; hal_types &amp; hal_drivers &amp; vm_types --&gt; application</code></pre> <p>Runtime API header files are organized by component:</p> Component header file Overview <code>iree/runtime/api.h</code> High level runtime API <code>iree/base/api.h</code> Core API, type definitions, ownership policies, utilities <code>iree/vm/api.h</code> VM APIs: loading modules, I/O, calling functions <code>iree/hal/api.h</code> HAL APIs: device management, synchronization, accessing hardware features"},{"location":"reference/bindings/c-api/#concepts_1","title":"Concepts","text":""},{"location":"reference/bindings/c-api/#high-level-session","title":"High level - Session","text":"<p>Under construction, more coming soon</p>"},{"location":"reference/bindings/c-api/#high-level-instance","title":"High level - Instance","text":"<p>Under construction, more coming soon</p>"},{"location":"reference/bindings/c-api/#high-level-call","title":"High level - Call","text":"<p>Under construction, more coming soon</p>"},{"location":"reference/bindings/c-api/#low-level-vm","title":"Low level - VM","text":"<p>By default, IREE uses its own tiny Virtual Machine (VM) at runtime to interpret program instructions on the host system. VM instructions may also be lowered further to LLVM IR, C, or other representations for static or resource constrained deployment.</p> <p>The VM supports generic operations like loads, stores, arithmetic, function calls, and control flow. The VM builds streams of more complex program logic and dense math into HAL command buffers that are dispatched to hardware backends.</p> <ul> <li>VM instances can serve multiple isolated execution contexts</li> <li>VM contexts are effectively sandboxes for loading modules and running   programs</li> <li>VM modules provide extra functionality to execution contexts, such as   access to hardware accelerators through the HAL. Compiled user programs are   also modules.</li> </ul>"},{"location":"reference/bindings/c-api/#low-level-hal","title":"Low level - HAL","text":"<ul> <li>HAL drivers are used to enumerate and create HAL devices</li> <li>HAL devices interface with hardware, such as by allocating device memory,   preparing executables, recording and dispatching command buffers, and   synchronizing with the host</li> <li>HAL buffers and buffer views represent storage and shaped/typed views   into that storage (aka \"tensors\")</li> </ul>"},{"location":"reference/bindings/c-api/#usage_1","title":"Usage","text":"<p>Under construction, more coming soon</p>"},{"location":"reference/bindings/c-api/#samples_1","title":"Samples","text":"Source location Description iree <code>runtime/demo/</code> In-tree demos of the high level runtime API iree <code>samples/</code> In-tree sample applications iree-template-runtime-cmake Template repository for runtime applications iree-template-cpp Demonstration of integration into a downstream project iree-samples <code>runtime-library/</code> Shared runtime library builder"},{"location":"reference/bindings/c-api/#compiler-runtime-jit","title":"Compiler + Runtime = JIT","text":"<p>The compiler and runtime APIs may be used together to build a \"just in time\" (JIT) execution engine. JIT compilation allows for last-minute specialization with no prior knowledge of target devices and avoids issues with version drift, but it can also constrain deployment options and usage scenarios.</p>"},{"location":"reference/bindings/python/","title":"Python bindings","text":"<p>Info</p> <p>API reference pages for IREE's runtime and compiler Python APIs are hosted on readthedocs.</p>","tags":["Python"]},{"location":"reference/bindings/python/#overview","title":"Overview","text":"<p>IREE offers Python bindings split into several packages, covering different components:</p> PIP package name Description <code>iree-compiler</code> IREE's generic compiler tools and helpers <code>iree-runtime</code> IREE's runtime, including CPU and GPU backends <code>iree-tools-tf</code> Tools for importing from TensorFlow <code>iree-tools-tflite</code> Tools for importing from TensorFlow Lite <code>iree-jax</code> Tools for importing from JAX <p>Collectively, these packages allow for importing from frontends, compiling towards various targets, and executing compiled code on IREE's backends.</p> <p>Caution - Operating system support</p> <p>Packages are currently only available on Linux and macOS. They are not available on Windows yet (see this issue).</p>","tags":["Python"]},{"location":"reference/bindings/python/#prerequisites","title":"Prerequisites","text":"<p>To use IREE's Python bindings, you will first need to install Python 3 and pip, as needed.</p> Tip - Virtual environments <p>We recommend using virtual environments to manage python packages, such as through <code>venv</code> (about, tutorial):</p> LinuxmacOSWindows <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre> <pre><code>python -m venv .venv\nsource .venv/bin/activate\n</code></pre> <pre><code>python -m venv .venv\n.venv\\Scripts\\activate.bat\n</code></pre> <p>When done, run <code>deactivate</code>.</p>","tags":["Python"]},{"location":"reference/bindings/python/#installing-iree-packages","title":"Installing IREE packages","text":"","tags":["Python"]},{"location":"reference/bindings/python/#prebuilt-packages","title":"Prebuilt packages","text":"Stable releases Nightly releases <p>Stable release packages are published to PyPI.</p> <pre><code>python -m pip install \\\niree-compiler \\\niree-runtime\n</code></pre> <p>Nightly releases are published on GitHub releases.</p> <pre><code>python -m pip install \\\n--find-links https://openxla.github.io/iree/pip-release-links.html \\\n--upgrade \\\niree-compiler \\\niree-runtime\n</code></pre>","tags":["Python"]},{"location":"reference/bindings/python/#building-from-source","title":"Building from source","text":"<p>See Building Python bindings page for instructions for building from source.</p>","tags":["Python"]},{"location":"reference/bindings/python/#using-the-python-bindings","title":"Using the Python bindings","text":"<p>API reference pages for IREE's runtime and compiler Python APIs are hosted on readthedocs.</p> <p>Check out the samples in IREE's samples/colab/ directory and the iree-samples repository for examples using the Python APIs.</p>","tags":["Python"]},{"location":"reference/bindings/python/#quickstart","title":"Quickstart","text":"<p>Compile a program:</p> <pre><code>from iree import compiler as ireec\n\n# Compile a module.\nINPUT_MLIR = \"\"\"\nmodule @arithmetic {\n  func.func @simple_mul(%arg0: tensor&lt;4xf32&gt;, %arg1: tensor&lt;4xf32&gt;) -&gt; tensor&lt;4xf32&gt; {\n    %0 = arith.mulf %arg0, %arg1 : tensor&lt;4xf32&gt;\n    return %0 : tensor&lt;4xf32&gt;\n  }\n}\n\"\"\"\n\n# Compile using the vmvx (reference) target:\ncompiled_flatbuffer = ireec.tools.compile_str(\n    INPUT_MLIR,\n    target_backends=[\"vmvx\"])\n</code></pre> <p>Run a compiled program:</p> <pre><code>from iree import runtime as ireert\n\n# Register the module with a runtime context.\n# Use the \"local-task\" CPU driver, which can load the vmvx executable:\nconfig = ireert.Config(\"local-task\")\nctx = ireert.SystemContext(config=config)\nvm_module = ireert.VmModule.copy_buffer(ctx.instance, compiled_flatbuffer)\nctx.add_vm_module(vm_module)\n\n# Invoke the function and print the result.\nprint(\"INVOKE simple_mul\")\narg0 = np.array([1., 2., 3., 4.], dtype=np.float32)\narg1 = np.array([4., 5., 6., 7.], dtype=np.float32)\nf = ctx.modules.arithmetic[\"simple_mul\"]\nresults = f(arg0, arg1).to_host()\nprint(\"Results:\", results)\n</code></pre>","tags":["Python"]},{"location":"reference/mlir-dialects/","title":"MLIR dialects","text":"<p>These pages contain automatically generated documentation for the MLIR dialects defined in the IREE repository. IREE also makes extensive use of dialects from the upstream MLIR repository, which are documented at https://mlir.llvm.org/docs/Dialects/.</p>"},{"location":"reference/mlir-dialects/#iree-internal-dialects","title":"IREE internal dialects","text":"<p>These dialects are an implementation detail of the IREE compiler, though they can be used by plugins and other advanced integrations. The sources for most of these dialects can be found in the <code>iree/compiler/Dialect/</code> directory.</p> Dialect Description Check Defines assertions for IREE tests Flow Models execution data flow and partitioning HAL Represents operations against the IREE HAL1 HALInline Inline HAL interop runtime module dialect HALLoader HAL inline executable loader runtime module dialect Stream Model execution partitioning and scheduling Util Types and ops common across IREE subdialects VM Represents operations against an abstract virtual machine VMVX Virtual Machine Vector Extensions"},{"location":"reference/mlir-dialects/#iree-public-dialects","title":"IREE public dialects","text":"<p>The ops in these dialects are legal to include in compiler inputs. The sources for these dialects can be found in the <code>llvm-external-projects/iree-dialects/</code> directory that is designed to be used from other projects via LLVM's external projects mechanism.</p> Dialect Description IREEInput Structural ops legal as input to IREE's compiler IREELinalgExt Extensions to the Linalg dialect for specific operations <ol> <li> <p>Hardware Abstraction Layer\u00a0\u21a9</p> </li> </ol>"},{"location":"reference/mlir-dialects/Check/","title":"Check","text":""},{"location":"reference/mlir-dialects/Check/#check-dialect","title":"'check' Dialect","text":"<p>A dialect implementing test assertions for IREE modules.</p> <ul> <li>'check' Dialect<ul> <li>Operation definition<ul> <li>check.expect_all_true (Check::ExpectAllTrueOp)</li> <li>check.expect_almost_eq (Check::ExpectAlmostEqOp)</li> <li>check.expect_almost_eq_const (Check::ExpectAlmostEqConstOp)</li> <li>check.expect_eq (Check::ExpectEqOp)</li> <li>check.expect_eq_const (Check::ExpectEqConstOp)</li> <li>check.expect_false (Check::ExpectFalseOp)</li> <li>check.expect_true (Check::ExpectTrueOp)</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/mlir-dialects/Check/#operation-definition","title":"Operation definition","text":""},{"location":"reference/mlir-dialects/Check/#checkexpect_all_true-checkexpectalltrueop","title":"<code>check.expect_all_true</code> (Check::ExpectAllTrueOp)","text":"<p>Checks that the operand contains only values that are true</p> <p>Syntax:</p> <pre><code>operation ::= `check.expect_all_true` `(` $operand `)` attr-dict `:` type($operand)\n</code></pre> <p>Verifies that the operand contains true values, which are represented by any non-zero integer.</p> <p>Issues a non-fatal failure if the verification fails.</p> <pre><code>check.expect_all_true(%arg0) : !hal.buffer_view\ncheck.expect_all_true(%arg1) : tensor&lt;2x2xi32&gt;\n</code></pre>"},{"location":"reference/mlir-dialects/Check/#operands","title":"Operands:","text":"Operand Description <code>operand</code> buffer_view or tensor of signless integer values"},{"location":"reference/mlir-dialects/Check/#checkexpect_almost_eq-checkexpectalmosteqop","title":"<code>check.expect_almost_eq</code> (Check::ExpectAlmostEqOp)","text":"<p>Checks that the operands are almost equal</p> <p>Syntax:</p> <pre><code>operation ::= `check.expect_almost_eq` `(` $lhs `,` $rhs `)` attr-dict `:` type($lhs)\n</code></pre> <p>Verifies that the buffer view or tensor operands with float elements are almost equal to within an implementation-defined \"reasonable\" tolerance.</p> <p>Issues a non-fatal failure if the verification fails.</p> <pre><code>check.expect_almost_eq(%arg0, %arg1) : tensor&lt;5xf32&gt;\n</code></pre> <p>Traits: SameTypeOperands</p>"},{"location":"reference/mlir-dialects/Check/#operands_1","title":"Operands:","text":"Operand Description <code>lhs</code> buffer_view or tensor of floating-point values <code>rhs</code> buffer_view or tensor of floating-point values"},{"location":"reference/mlir-dialects/Check/#checkexpect_almost_eq_const-checkexpectalmosteqconstop","title":"<code>check.expect_almost_eq_const</code> (Check::ExpectAlmostEqConstOp)","text":"<p>Checks that the tensor operand is almost equal to some constant</p> <p>Syntax:</p> <pre><code>operation ::= `check.expect_almost_eq_const` `(` $lhs `,` $value `)` attr-dict `:` type($lhs)\n</code></pre> <p>Verifies that the tensor operand with float elements is almost equal to the constant attribute within an implementation-defined \"reasonable\" tolerance.</p> <p>Issues a non-fatal failure if the verification fails.</p> <p>This op is just a convenience wrapper around the expect_almost_eq op.</p> <pre><code>check.expect_almost_eq_const(%const0, dense&lt;[0.999999, 2.0]&gt; : tensor&lt;5xf32&gt;) : tensor&lt;5xf32&gt;\n</code></pre>"},{"location":"reference/mlir-dialects/Check/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>value</code> ::mlir::ElementsAttr constant vector/tensor attribute"},{"location":"reference/mlir-dialects/Check/#operands_2","title":"Operands:","text":"Operand Description <code>lhs</code> tensor of floating-point values"},{"location":"reference/mlir-dialects/Check/#checkexpect_eq-checkexpecteqop","title":"<code>check.expect_eq</code> (Check::ExpectEqOp)","text":"<p>Checks that the tensor or buffer view operands are equal</p> <p>Syntax:</p> <pre><code>operation ::= `check.expect_eq` `(` $lhs `,` $rhs `)` attr-dict `:` type($lhs)\n</code></pre> <p>Verifies that the operands are exactly equal.</p> <p>Issues a non-fatal failure if the verification fails.</p> <pre><code>check.expect_eq(%arg0, %arg1) : tensor&lt;5xi32&gt;\n</code></pre> <p>Traits: SameTypeOperands</p>"},{"location":"reference/mlir-dialects/Check/#operands_3","title":"Operands:","text":"Operand Description <code>lhs</code> buffer_view or tensor of any type values <code>rhs</code> buffer_view or tensor of any type values"},{"location":"reference/mlir-dialects/Check/#checkexpect_eq_const-checkexpecteqconstop","title":"<code>check.expect_eq_const</code> (Check::ExpectEqConstOp)","text":"<p>Checks that the tensor operand is equal to some constant</p> <p>Syntax:</p> <pre><code>operation ::= `check.expect_eq_const` `(` $lhs `,` $value `)` attr-dict `:` type($lhs)\n</code></pre> <p>Verifies that the tensor operand is exactly equal to a constant attribute.</p> <p>Issues a non-fatal failure if the verification fails.</p> <p>This op is just a convenience wrapper around the expect_eq op.</p> <pre><code>check.expect_eq_const(%arg0, dense&lt;[1, 2]&gt; : tensor&lt;2xi32&gt;) : tensor&lt;2xi32&gt;\n</code></pre>"},{"location":"reference/mlir-dialects/Check/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>value</code> ::mlir::ElementsAttr constant vector/tensor attribute"},{"location":"reference/mlir-dialects/Check/#operands_4","title":"Operands:","text":"Operand Description <code>lhs</code> tensor of any type values"},{"location":"reference/mlir-dialects/Check/#checkexpect_false-checkexpectfalseop","title":"<code>check.expect_false</code> (Check::ExpectFalseOp)","text":"<p>Checks that the operand is false</p> <p>Syntax:</p> <pre><code>operation ::= `check.expect_false` `(` $operand `)` attr-dict `:` type($operand)\n</code></pre> <p>Verifies that the operand contains a false value, which is represented by zero.</p> <p>Issues a non-fatal failure if the verification fails.</p> <pre><code>check.expect_false(%arg0) : i32\n</code></pre>"},{"location":"reference/mlir-dialects/Check/#operands_5","title":"Operands:","text":"Operand Description <code>operand</code> signless integer"},{"location":"reference/mlir-dialects/Check/#checkexpect_true-checkexpecttrueop","title":"<code>check.expect_true</code> (Check::ExpectTrueOp)","text":"<p>Checks that the operand is true</p> <p>Syntax:</p> <pre><code>operation ::= `check.expect_true` `(` $operand `)` attr-dict `:` type($operand)\n</code></pre> <p>Verifies that the operand contains a true value, which is represented by any non-zero integer.</p> <p>Issues a non-fatal failure if the verification fails.</p> <pre><code>check.expect_true(%arg0) : i32\n</code></pre>"},{"location":"reference/mlir-dialects/Check/#operands_6","title":"Operands:","text":"Operand Description <code>operand</code> signless integer"},{"location":"reference/mlir-dialects/Flow/","title":"Flow","text":""},{"location":"reference/mlir-dialects/Flow/#flow-dialect","title":"'flow' Dialect","text":"<p>A dialect designed to model execution data flow and partitioning.</p> <p>The flow dialect is used to model regions of dense computation and the data flow between them. MLIR value-semantic tensors are used as the primary data type to allow SSA use-def to provide a bulk of the infrastructure required to perform the computation partitioning and outlining.</p> <p>The dialect is designed to ingest relatively high-level linear algebra via XLA HLO ops (that also operate on the value-semantic tensor types) and optionally MLIR standard ops for control flow and other actions. After conversion of any higher-level ops that have special semantics in the flow dialect, such as global variables, the rest are partitioned into regions containing simple and compatible computations. Finally, outlining moves the computations into executables and leaves only the execution flow encoded via dispatch operations.</p> <p>The primary unit of interest is a \"dispatch region\" containing compatible computations that can be scheduled together efficiently (and safely). \"Compatible\" here is specified as similarly shaped workloads that indicate how many invocations a computation can be parallelized across when running in a SPMD execution model. Though it depends on the particular runtime backends this more concretely means things like the untiled workload (or tiled workgroups) used in GPU dispatches or similar thread pool executors.</p> <p>After identification of the dispatchable regions a set of transformations performs folding and simplification to reduce the total number of dispatches. Heuristics are used in certain cases to more efficiently schedule special ops (such as GEMM) and the design is amenable to profile- guided analysis that can be added in the future.</p> <p>The resulting outlined executable modules containing the dispatchable code can be translated to one or more backends (such as SPIR-V for Vulkan, or LLVM IR for running on the CPU, etc). The IR that is outlined is untouched and in the input format (such as XLA HLO ops) allowing conversion using any MLIR target that supports ingesting such input. A few special ops are used to communicate statically available information such as the expected workload size, shapes of inputs and outputs, etc.</p> <ul> <li>'flow' Dialect<ul> <li>Operation definition<ul> <li>Collective communication ops<ul> <li>flow.channel.count (Flow::ChannelCountOp)</li> <li>flow.channel.default (Flow::ChannelDefaultOp)</li> <li>flow.channel.rank (Flow::ChannelRankOp)</li> <li>flow.channel.split (Flow::ChannelSplitOp)</li> <li>flow.collective.all_gather (Flow::CollectiveAllGatherOp)</li> <li>flow.collective.all_reduce (Flow::CollectiveAllReduceOp)</li> <li>flow.collective.all_to_all (Flow::CollectiveAllToAllOp)</li> <li>flow.collective.reduce_scatter (Flow::CollectiveReduceScatterOp)</li> <li>flow.collective.send_recv (Flow::CollectiveSendRecvOp)</li> </ul> </li> <li>Dispatch ops<ul> <li>flow.dispatch (Flow::DispatchOp)</li> </ul> </li> <li>Executable ops<ul> <li>flow.executable_end (Flow::ExecutableEndOp)</li> <li>flow.executable.export (Flow::ExecutableExportOp)</li> <li>flow.executable (Flow::ExecutableOp)</li> </ul> </li> <li>Partitioned region ops<ul> <li>flow.dispatch.region (Flow::DispatchRegionOp)</li> <li>flow.dispatch.tensor.load (Flow::DispatchTensorLoadOp)</li> <li>flow.dispatch.tensor.store (Flow::DispatchTensorStoreOp)</li> <li>flow.dispatch.tie_shape (Flow::DispatchTieShapeOp)</li> <li>flow.dispatch.workgroup.count (Flow::DispatchWorkgroupCountOp)</li> <li>flow.dispatch.workgroup.id (Flow::DispatchWorkgroupIDOp)</li> <li>flow.dispatch.workgroup.size (Flow::DispatchWorkgroupSizeOp)</li> <li>flow.dispatch.workgroups (Flow::DispatchWorkgroupsOp)</li> <li>flow.return (Flow::ReturnOp)</li> </ul> </li> <li>Streamable call ops<ul> <li>flow.call (Flow::CallOp)</li> <li>flow.func (Flow::FuncOp)</li> </ul> </li> <li>Tensor ops<ul> <li>flow.dispatch.workgroup_count_from_dag_root (Flow::DispatchWorkgroupCountFromDagRootOp)</li> <li>flow.dispatch.workgroup_count_from_slice (Flow::DispatchWorkgroupCountFromSliceOp)</li> <li>flow.dispatch.workload.ordinal (Flow::DispatchWorkloadOrdinalOp)</li> <li>flow.tensor.alloca (Flow::TensorAllocaOp)</li> <li>flow.tensor.clone (Flow::TensorCloneOp)</li> <li>flow.tensor.constant (Flow::TensorConstantOp)</li> <li>flow.tensor.empty (Flow::TensorEmptyOp)</li> <li>flow.tensor.load (Flow::TensorLoadOp)</li> <li>flow.tensor.reshape (Flow::TensorReshapeOp)</li> <li>flow.tensor.slice (Flow::TensorSliceOp)</li> <li>flow.tensor.splat (Flow::TensorSplatOp)</li> <li>flow.tensor.store (Flow::TensorStoreOp)</li> <li>flow.tensor.tie_shape (Flow::TensorTieShapeOp)</li> <li>flow.tensor.trace (Flow::TensorTraceOp)</li> <li>flow.tensor.update (Flow::TensorUpdateOp)</li> </ul> </li> </ul> </li> <li>Attribute definition<ul> <li>DummyAttr</li> </ul> </li> <li>Type constraint definition<ul> <li>dispatch.tensor</li> <li>dispatch.tensor</li> <li>dispatch.tensor</li> </ul> </li> <li>Type definition<ul> <li>ChannelType</li> <li>DummyType</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/mlir-dialects/Flow/#operation-definition","title":"Operation definition","text":""},{"location":"reference/mlir-dialects/Flow/#collective-communication-ops","title":"Collective communication ops","text":""},{"location":"reference/mlir-dialects/Flow/#flowchannelcount-flowchannelcountop","title":"<code>flow.channel.count</code> (Flow::ChannelCountOp)","text":"<p>Returns the total number of participants in the group</p> <p>Syntax:</p> <pre><code>operation ::= `flow.channel.count` $channel `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the total participant count in the collective communicator group.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands","title":"Operands:","text":"Operand Description <code>channel</code> a collecive communication channel"},{"location":"reference/mlir-dialects/Flow/#results","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/Flow/#flowchanneldefault-flowchanneldefaultop","title":"<code>flow.channel.default</code> (Flow::ChannelDefaultOp)","text":"<p>Returns a default collective communication channel</p> <p>Syntax:</p> <pre><code>operation ::= `flow.channel.default` ($group^)?\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns a channel initialized using the runtime environment.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>group</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/Flow/#results_1","title":"Results:","text":"Result Description <code>result</code> a collecive communication channel"},{"location":"reference/mlir-dialects/Flow/#flowchannelrank-flowchannelrankop","title":"<code>flow.channel.rank</code> (Flow::ChannelRankOp)","text":"<p>Returns the rank of the local participant in the group</p> <p>Syntax:</p> <pre><code>operation ::= `flow.channel.rank` $channel `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the rank the channel represents as a participant in a collective group in <code>[0, count)</code>.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_1","title":"Operands:","text":"Operand Description <code>channel</code> a collecive communication channel"},{"location":"reference/mlir-dialects/Flow/#results_2","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/Flow/#flowchannelsplit-flowchannelsplitop","title":"<code>flow.channel.split</code> (Flow::ChannelSplitOp)","text":"<p>Splits a collective communication channel</p> <p>Syntax:</p> <pre><code>operation ::= `flow.channel.split` $channel `,` $color `,` $key\n              `:` type($channel) `-&gt;` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Partitions the group associated with the given channel into disjoint subgroups for each unique value of color. Each new subgroup contains all participants of the same color and within each subgroup the key argument is used to define the rank order. When multiple participants in a group use the same key the tie will be broken using their rank in the parent group.</p> <p>Interfaces: InferTypeOpInterface, OpAsmOpInterface</p>"},{"location":"reference/mlir-dialects/Flow/#operands_2","title":"Operands:","text":"Operand Description <code>channel</code> a collecive communication channel <code>color</code> index <code>key</code> index"},{"location":"reference/mlir-dialects/Flow/#results_3","title":"Results:","text":"Result Description <code>result</code> a collecive communication channel"},{"location":"reference/mlir-dialects/Flow/#flowcollectiveall_gather-flowcollectiveallgatherop","title":"<code>flow.collective.all_gather</code> (Flow::CollectiveAllGatherOp)","text":"<p>Performs all-gather operation</p> <p>Syntax:</p> <pre><code>operation ::= `flow.collective.all_gather` $element_type `,` $target `,` $source `,` $channel `:`\n              `(` type($target) `,` type($source) `,` type($channel) `)` `-&gt;`\n              custom&lt;ShapedTiedResult&gt;(type($result), $target_dims, $tied_operands)\n              attr-dict-with-keyword\n</code></pre> <p>It gathers data from all ranks and concatenates them on the 0-th dimension. Interfaces: InferTypeOpInterface, TiedOpInterface</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>element_type</code> ::mlir::iree_compiler::IREE::Flow::CollectiveElementTypeAttr valid CollectiveElementType <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute"},{"location":"reference/mlir-dialects/Flow/#operands_3","title":"Operands:","text":"Operand Description <code>target</code> ranked tensor of any type values <code>target_dims</code> index <code>source</code> ranked tensor of any type values <code>channel</code> a collecive communication channel"},{"location":"reference/mlir-dialects/Flow/#results_4","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowcollectiveall_reduce-flowcollectiveallreduceop","title":"<code>flow.collective.all_reduce</code> (Flow::CollectiveAllReduceOp)","text":"<p>Performs all-reduce operation</p> <p>Syntax:</p> <pre><code>operation ::= `flow.collective.all_reduce` $reduction_op `,` $element_type `,` $target `,` $source `,` $channel `:`\n              `(` type($target) `,` type($source) `,` type($channel) `)` `-&gt;`\n              custom&lt;ShapedTiedResult&gt;(type($result), $target_dims, $tied_operands)\n              attr-dict-with-keyword\n</code></pre> <p>The operation reduces data across all the ranks in the channel. Interfaces: InferTypeOpInterface, TiedOpInterface</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_2","title":"Attributes:","text":"Attribute MLIR Type Description <code>reduction_op</code> mlir::iree_compiler::IREE::Flow::CollectiveReductionOpAttr valid CollectiveReductionOp <code>element_type</code> ::mlir::iree_compiler::IREE::Flow::CollectiveElementTypeAttr valid CollectiveElementType <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute"},{"location":"reference/mlir-dialects/Flow/#operands_4","title":"Operands:","text":"Operand Description <code>target</code> ranked tensor of any type values <code>target_dims</code> index <code>source</code> ranked tensor of any type values <code>channel</code> a collecive communication channel"},{"location":"reference/mlir-dialects/Flow/#results_5","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowcollectiveall_to_all-flowcollectivealltoallop","title":"<code>flow.collective.all_to_all</code> (Flow::CollectiveAllToAllOp)","text":"<p>Performs all-to-all operation</p> <p>Syntax:</p> <pre><code>operation ::= `flow.collective.all_to_all` $element_type `,` $target `,` $source `,` $channel `:`\n              `(` type($target) `,` type($source) `,` type($channel) `)` `-&gt;`\n              custom&lt;ShapedTiedResult&gt;(type($result), $target_dims, $tied_operands)\n              attr-dict-with-keyword\n</code></pre> <p>This operation mutually exchanges data acrosss all of the ranks in the channel. Interfaces: InferTypeOpInterface, TiedOpInterface</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_3","title":"Attributes:","text":"Attribute MLIR Type Description <code>element_type</code> ::mlir::iree_compiler::IREE::Flow::CollectiveElementTypeAttr valid CollectiveElementType <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute"},{"location":"reference/mlir-dialects/Flow/#operands_5","title":"Operands:","text":"Operand Description <code>target</code> ranked tensor of any type values <code>target_dims</code> index <code>source</code> ranked tensor of any type values <code>channel</code> a collecive communication channel"},{"location":"reference/mlir-dialects/Flow/#results_6","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowcollectivereduce_scatter-flowcollectivereducescatterop","title":"<code>flow.collective.reduce_scatter</code> (Flow::CollectiveReduceScatterOp)","text":"<p>Performs reduce and scatter operations</p> <p>Syntax:</p> <pre><code>operation ::= `flow.collective.reduce_scatter` $reduction_op `,` $element_type `,` $target `,` $source `,` $channel `:`\n              `(` type($target) `,` type($source) `,` type($channel) `)` `-&gt;`\n              custom&lt;ShapedTiedResult&gt;(type($result), $target_dims, $tied_operands)\n              attr-dict-with-keyword\n</code></pre> <p>The operation reduces data across all the ranks in the channel and     scatters the result to each rank. Interfaces: InferTypeOpInterface, TiedOpInterface</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_4","title":"Attributes:","text":"Attribute MLIR Type Description <code>reduction_op</code> mlir::iree_compiler::IREE::Flow::CollectiveReductionOpAttr valid CollectiveReductionOp <code>element_type</code> ::mlir::iree_compiler::IREE::Flow::CollectiveElementTypeAttr valid CollectiveElementType <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute"},{"location":"reference/mlir-dialects/Flow/#operands_6","title":"Operands:","text":"Operand Description <code>target</code> ranked tensor of any type values <code>target_dims</code> index <code>source</code> ranked tensor of any type values <code>channel</code> a collecive communication channel"},{"location":"reference/mlir-dialects/Flow/#results_7","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowcollectivesend_recv-flowcollectivesendrecvop","title":"<code>flow.collective.send_recv</code> (Flow::CollectiveSendRecvOp)","text":"<p>Performs a grouped send and receive operation</p> <p>Syntax:</p> <pre><code>operation ::= `flow.collective.send_recv` $element_type `,` $target `,` $source `,` $channel `,` $send `,` $recv `:`\n              `(` type($target) `,` type($source) `,` type($channel) `,` type($send) `,` type($recv) `)` `-&gt;`\n              custom&lt;ShapedTiedResult&gt;(type($result), $target_dims, $tied_operands)\n              attr-dict-with-keyword\n</code></pre> <p>The operation sends data to the rank specificied by send     and receives data from the rank specified by recv. If send is -1, this rank     will not send any data. If recv is -1, this rank will not receive any data     and the output will be all zeros. Interfaces: InferTypeOpInterface, TiedOpInterface</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_5","title":"Attributes:","text":"Attribute MLIR Type Description <code>element_type</code> ::mlir::iree_compiler::IREE::Flow::CollectiveElementTypeAttr valid CollectiveElementType <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute"},{"location":"reference/mlir-dialects/Flow/#operands_7","title":"Operands:","text":"Operand Description <code>target</code> ranked tensor of any type values <code>target_dims</code> index <code>source</code> ranked tensor of any type values <code>channel</code> a collecive communication channel <code>send</code> index <code>recv</code> index"},{"location":"reference/mlir-dialects/Flow/#results_8","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#dispatch-ops","title":"Dispatch ops","text":""},{"location":"reference/mlir-dialects/Flow/#flowdispatch-flowdispatchop","title":"<code>flow.dispatch</code> (Flow::DispatchOp)","text":"<p>A dispatch of workgroups across a grid</p> <p>Syntax:</p> <pre><code>operation ::= `flow.dispatch` $entry_point\n              (`[` $workload^ `]`)? ``\n              `(` $arguments `)` attr-dict `:`\n              custom&lt;ShapedFunctionType&gt;(ref($arguments),\n              type($arguments), $argument_dims,\n              type($results), $result_dims,\n              $tied_operands)\n</code></pre> <p>Dispatches workgroups across an grid defined by the captured workload parameters carrying the information required to compute the workgroup count at runtime. The function for converting the workload into a 3D workgroup count is attached to the dispatch entry point and may contain arbitrary host logic.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, FLOW_StreamableOp, NoMemoryEffect (MemoryEffectOpInterface), SymbolUserOpInterface, TiedOpInterface, Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_6","title":"Attributes:","text":"Attribute MLIR Type Description <code>entry_point</code> ::mlir::SymbolRefAttr symbol reference attribute <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute"},{"location":"reference/mlir-dialects/Flow/#operands_8","title":"Operands:","text":"Operand Description <code>workload</code> index <code>arguments</code> any type <code>argument_dims</code> index <code>result_dims</code> index"},{"location":"reference/mlir-dialects/Flow/#results_9","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"reference/mlir-dialects/Flow/#executable-ops","title":"Executable ops","text":"<p>Executables for outlined regions.</p>"},{"location":"reference/mlir-dialects/Flow/#flowexecutable_end-flowexecutableendop","title":"<code>flow.executable_end</code> (Flow::ExecutableEndOp)","text":"<p>Terminator pseudo-op for the executable op</p> <p>Syntax:</p> <pre><code>operation ::= `flow.executable_end` attr-dict\n</code></pre> <p>Traits: HasParent, Terminator"},{"location":"reference/mlir-dialects/Flow/#flowexecutableexport-flowexecutableexportop","title":"<code>flow.executable.export</code> (Flow::ExecutableExportOp)","text":"<p>Defines an executable entry point for dispatch operations</p> <p>Syntax:</p> <pre><code>operation ::= `flow.executable.export` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              custom&lt;SymbolAlias&gt;($sym_name, $function_ref)\n              custom&lt;WorkgroupCountRegion&gt;($workgroup_count)\n              attr-dict-with-keyword\n</code></pre> <p>Specifies an exported function with an externally-visible alias. Multiple exports can reference the same internal function.</p> <p>Each entry point can have a unique workgroup count calculation region. This region takes the workload parameters passed to each flow.dispatch and produces an XYZ workgroup count for the 3D grid dispatch.</p> <p>Traits: HasParent, IsolatedFromAbove <p>Interfaces: Symbol</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_7","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>function_ref</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute"},{"location":"reference/mlir-dialects/Flow/#flowexecutable-flowexecutableop","title":"<code>flow.executable</code> (Flow::ExecutableOp)","text":"<p>Generic executable module</p> <p>Syntax:</p> <pre><code>operation ::= `flow.executable` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              $sym_name\n              attr-dict-with-keyword\n              regions\n</code></pre> <p>An executable module containing one or more public functions. The contents of the functions are safe to dispatch and can be lowered further to target-specific backend IR representations.</p> <p>Traits: IsolatedFromAbove, SingleBlockImplicitTerminator, SymbolTable <p>Interfaces: Symbol</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_8","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/Flow/#partitioned-region-ops","title":"Partitioned region ops","text":""},{"location":"reference/mlir-dialects/Flow/#flowdispatchregion-flowdispatchregionop","title":"<code>flow.dispatch.region</code> (Flow::DispatchRegionOp)","text":"<p>A group of ops</p> <p>This op is a container/grouping of ops. It represents a fusion group before being lowered to a dispatch region. Ops are collected inside of the region body of the op. Values from parent regions can be captured. Results are yielded with a <code>return</code> terminator and returned from this op.</p> <p><code>dispatch.region</code> ops are lowered to <code>dispatch.workgroups</code> ops. Workgroups isolated from above. <code>dispatch.region</code> ops are a more lightweight abstraction for implementing fusion heuristics, i.e., the process of deciding which ops should form a dispatch region.</p> <p>This op also has a second region: <code>workload_count</code>. The arguments to the region represent the workload for the dispatch, and returns the number of workgroups for the dispatch. The region is lowered directly to <code>workload_count</code> region of <code>dispatch.workgroups</code>.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments, SingleBlockImplicitTerminator <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_9","title":"Operands:","text":"Operand Description <code>result_dims</code> index <code>workload</code> index"},{"location":"reference/mlir-dialects/Flow/#results_10","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/Flow/#flowdispatchtensorload-flowdispatchtensorloadop","title":"<code>flow.dispatch.tensor.load</code> (Flow::DispatchTensorLoadOp)","text":"<p>Loads a tensor from a dispatch input placeholder</p> <p>Syntax:</p> <pre><code>operation ::= `flow.dispatch.tensor.load` $source\n              `,` `offsets` `=` custom&lt;DynamicIndexList&gt;(\n              $offsets, $static_offsets)\n              `,` `sizes` `=` custom&lt;DynamicIndexList&gt;(\n              $sizes, $static_sizes)\n              `,` `strides` `=` custom&lt;DynamicIndexList&gt;(\n              $strides, $static_strides)\n              attr-dict `:` type($source) (`{` $source_dims^ `}`)?  `-&gt;` type($result)\n</code></pre> <p>Loads an input tensor or subtensor from an input placeholder. As each workgroup executes concurrently all workgroups will receive identical loaded results of regions that may overlap.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OffsetSizeAndStrideOpInterface, ReifyRankedShapedTypeOpInterface, TiedOpInterface, Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_9","title":"Attributes:","text":"Attribute MLIR Type Description <code>static_offsets</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute <code>static_sizes</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute <code>static_strides</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute"},{"location":"reference/mlir-dialects/Flow/#operands_10","title":"Operands:","text":"Operand Description <code>source</code> dispatch.tensor <code>source_dims</code> index <code>offsets</code> index <code>sizes</code> index <code>strides</code> index"},{"location":"reference/mlir-dialects/Flow/#results_11","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowdispatchtensorstore-flowdispatchtensorstoreop","title":"<code>flow.dispatch.tensor.store</code> (Flow::DispatchTensorStoreOp)","text":"<p>Stores a tensor into a dispatch output placeholder</p> <p>Syntax:</p> <pre><code>operation ::= `flow.dispatch.tensor.store` $value `,` $target\n              `,` `offsets` `=` custom&lt;DynamicIndexList&gt;(\n              $offsets, $static_offsets)\n              `,` `sizes` `=` custom&lt;DynamicIndexList&gt;(\n              $sizes, $static_sizes)\n              `,` `strides` `=` custom&lt;DynamicIndexList&gt;(\n              $strides, $static_strides)\n              attr-dict `:` type($value) `-&gt;` type($target) (`{` $target_dims^ `}`)?\n</code></pre> <p>Stores a tensor or subtensor into an output tensor placeholder. As each workgroup executes concurrently behavior is undefined if more than one workgroup stores into overlapping regions of the full output tensor.</p> <p>Traits: AttrSizedOperandSegments</p> <p>Interfaces: OffsetSizeAndStrideOpInterface, Util_ShapeAwareOp</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_10","title":"Attributes:","text":"Attribute MLIR Type Description <code>static_offsets</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute <code>static_sizes</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute <code>static_strides</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute"},{"location":"reference/mlir-dialects/Flow/#operands_11","title":"Operands:","text":"Operand Description <code>value</code> ranked tensor of any type values <code>target</code> dispatch.tensor <code>target_dims</code> index <code>offsets</code> index <code>sizes</code> index <code>strides</code> index"},{"location":"reference/mlir-dialects/Flow/#flowdispatchtie_shape-flowdispatchtieshapeop","title":"<code>flow.dispatch.tie_shape</code> (Flow::DispatchTieShapeOp)","text":"<p>Ties a runtime shape to a dispatch I/O argument</p> <p>Syntax:</p> <pre><code>operation ::= `flow.dispatch.tie_shape` $operand attr-dict\n              `:` type($result) (`{` $dynamic_dims^ `}`)?\n</code></pre> <p>Metadata op used to tie a runtime-computed shape with dynamic dimensions to a dispatch input/output argument. All uses of the argument should use the pass-through result of this op to allow for SSA-based shape resolution.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), ReifyRankedShapedTypeOpInterface, Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_12","title":"Operands:","text":"Operand Description <code>operand</code> dispatch.tensor <code>dynamic_dims</code> index"},{"location":"reference/mlir-dialects/Flow/#results_12","title":"Results:","text":"Result Description <code>result</code> dispatch.tensor"},{"location":"reference/mlir-dialects/Flow/#flowdispatchworkgroupcount-flowdispatchworkgroupcountop","title":"<code>flow.dispatch.workgroup.count</code> (Flow::DispatchWorkgroupCountOp)","text":"<p>Returns the total workgroup count of the grid</p> <p>Syntax:</p> <pre><code>operation ::= `flow.dispatch.workgroup.count` `[` $dimension `]` attr-dict `:` type($result)\n</code></pre> <p>The total number of workgroups along each dimension in the dispatch grid.</p> <p>Represented as a 3D grid classically written as XYZ. Corresponds to the <code>NumWorkgroups</code> SPIR-V built-in and the <code>gridDim</code> CUDA built-in variable.</p> <pre><code>%x = flow.dispatch.workgroup.count[0] : index\n%y = flow.dispatch.workgroup.count[1] : index\n%z = flow.dispatch.workgroup.count[2] : index\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_11","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/Flow/#results_13","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/Flow/#flowdispatchworkgroupid-flowdispatchworkgroupidop","title":"<code>flow.dispatch.workgroup.id</code> (Flow::DispatchWorkgroupIDOp)","text":"<p>Returns the index of the current workgroup in the grid</p> <p>Syntax:</p> <pre><code>operation ::= `flow.dispatch.workgroup.id` `[` $dimension `]` attr-dict `:` type($result)\n</code></pre> <p>The global workgroup ID of the current workgroup in the range of <code>[0, flow.dispatch.workgroup.count)</code> along each dimension.</p> <p>Represented as a 3D grid classically written as XYZ. Corresponds to the <code>WorkgroupId</code> SPIR-V built-in and the <code>blockIdx</code> CUDA built-in variable.</p> <pre><code>%x = flow.dispatch.workgroup.id[0] : index\n%y = flow.dispatch.workgroup.id[1] : index\n%z = flow.dispatch.workgroup.id[2] : index\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_12","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/Flow/#results_14","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/Flow/#flowdispatchworkgroupsize-flowdispatchworkgroupsizeop","title":"<code>flow.dispatch.workgroup.size</code> (Flow::DispatchWorkgroupSizeOp)","text":"<p>Returns the size of each workgroup in invocations</p> <p>Syntax:</p> <pre><code>operation ::= `flow.dispatch.workgroup.size` `[` $dimension `]` attr-dict `:` type($result)\n</code></pre> <p>The number of local invocations within the current workgroup along each dimension. Depending on backend this may map to the SIMT thread count or inner loop nest parameters.</p> <p>Workgroup sizes are not determined at the flow dialect level as they are dependent on the target backend determined when lowering into the HAL. It's still possible to use the symbolic workgroup size inside of dispatch executables as a placeholder for the resolved value once in the HAL.</p> <p>Represented as a 3D grid classically written as XYZ. Corresponds to the <code>WorkgroupSize</code> SPIR-V built-in and the <code>blockDim</code> CUDA built-in variable.</p> <pre><code>%x = flow.dispatch.workgroup.size[0] : index\n%y = flow.dispatch.workgroup.size[1] : index\n%z = flow.dispatch.workgroup.size[2] : index\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_13","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/Flow/#results_15","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/Flow/#flowdispatchworkgroups-flowdispatchworkgroupsop","title":"<code>flow.dispatch.workgroups</code> (Flow::DispatchWorkgroupsOp)","text":"<p>A dispatch of workgroups across a 3-dimensional grid</p> <p>Syntax:</p> <pre><code>operation ::= `flow.dispatch.workgroups` (`[` $workload^ `]`)? ``\n              `(` $arguments `)` `:`\n              custom&lt;ShapedFunctionType&gt;(ref($arguments),\n              type($arguments), $argument_dims,\n              type($results), $result_dims,\n              $tied_operands)\n              attr-dict-with-keyword\n              `=` `\\n` ` ` ` ` ` `\n              custom&lt;DispatchWorkgroupBody&gt;(ref(type($arguments)),\n              ref(type($results)),\n              $workgroup_body)\n              `` custom&lt;DispatchWorkgroupsCountRegion&gt;($workgroup_count)\n</code></pre> <p>Dispatches some number of workgroups across a 3-dimensional grid. The body region will be invoked for each workgroup with a unique <code>flow.dispatch.workgroup.id</code> in the range of <code>[0, flow.dispatch.workgroup.count)</code> (along each dimension XYZ).</p> <p>From the outside the dispatch operation has value semantics: some tensors (and optionally other primitive types) are consumed and one or more new result tensors are produced. Inside each workgroup, however, the input and output tensors are available for arbitrary loads and stores. In many cases each workgroup will load some particular tile(s) from the input tensors and store some particular tile(s) to the output tensors unique to that workgroup. Though it's possible for multiple workgroups to load the same regions of the input tensors behavior is undefined if multiple workgroups store to the same regions of the output tensors.</p> <p>Though the representation is similar to the GPU-style grid dispatch model here we still have not yet allocated buffers, determined the target device for execution, or even completed fully resolving shapes/types/etc. Because of this it's important that the workgroup body use the <code>flow.dispatch.workgroup.*</code> ops to query the workgroup ID/count/size instead of hardcoding them to a particular set of values. Assume that any workgroup dispatch may end up being specialized for several different target devices and even several different variants for a particular target device (differing workgroup sizes, etc).</p> <p>Because at this point in the layering devices have not yet been selected the workgroup count cannot be fully evaluated. Instead workload parameters are captured that are then passed to a function that when later evaluated computes the actual workgroup count based on target information. The workload is not limited to the 3D XYZ grid dispatch of the workgroup count and can contain any number of parameters used to compute it.</p> <pre><code>%r = flow.dispatch.workgroups[%c5, %c5](%0, %1)\n    : (tensor&lt;5x5xf32&gt;, tensor&lt;5xf32&gt;) -&gt; tensor&lt;5x5xf32&gt; =\n          (%arg0: !flow.dispatch.tensor&lt;readonly:tensor&lt;5x5xf32&gt;&gt;,\n           %arg1: !flow.dispatch.tensor&lt;readonly:tensor&lt;5xf32&gt;&gt;,\n           %arg2: !flow.dispatch.tensor&lt;writeonly:tensor&lt;5x5xf32&gt;&gt;) {\n  ...\n}\n</code></pre> <p>The number of results of the operation is equal to the number of results in the type signature (<code>(tensor&lt;5x5xf32&gt;, tensor&lt;5xf32&gt;) -&gt; tensor&lt;5x5xf32&gt;</code>). Each tensor argument and result in the type signature has a corresponding block argument of type <code>!flow.dispatch.tensor</code>. Furthermore, each argument has a corresponding <code>arguments</code> operand.</p> <p>There are no <code>arguments</code> operands for results, but a result can be tied an argument by writing the argument operand's SSA value instead of its type: E.g., in the above example, <code>-&gt; %0</code> would tie the first argument to the result. In that case, there would be no separate block argument for the result.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments, IsolatedFromAbove, SingleBlockImplicitTerminator <p>Interfaces: ClosureOpInterface, ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), TiedOpInterface, Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_14","title":"Attributes:","text":"Attribute MLIR Type Description <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute"},{"location":"reference/mlir-dialects/Flow/#operands_13","title":"Operands:","text":"Operand Description <code>workload</code> index <code>arguments</code> any type <code>argument_dims</code> index <code>result_dims</code> index"},{"location":"reference/mlir-dialects/Flow/#results_16","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"reference/mlir-dialects/Flow/#flowreturn-flowreturnop","title":"<code>flow.return</code> (Flow::ReturnOp)","text":"<p>Return from a flow.dispatch_region</p> <p>Syntax:</p> <pre><code>operation ::= `flow.return` attr-dict ($operands^ `:` type($operands))?\n</code></pre> <p>Returns the given values from the region and back to the host code.</p> <p>Traits: AlwaysSpeculatableImplTrait, ReturnLike, Terminator</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_14","title":"Operands:","text":"Operand Description <code>operands</code> any type"},{"location":"reference/mlir-dialects/Flow/#streamable-call-ops","title":"Streamable call ops","text":""},{"location":"reference/mlir-dialects/Flow/#flowcall-flowcallop","title":"<code>flow.call</code> (Flow::CallOp)","text":"<p>Calls a streamable external host function</p> <p>Syntax:</p> <pre><code>operation ::= `flow.call` $callee\n              `(` $arguments `)` attr-dict `:`\n              custom&lt;ShapedFunctionType&gt;(ref($arguments),\n              type($arguments), $argument_dims,\n              type($results), $result_dims,\n              $tied_operands)\n</code></pre> <p>Calls a function taking/returning tensor values with stream semantics. Tensors have their shapes captured and may be tied to denote in-place operations. Asynchronous calls must have no side-effects.</p> <p>Note that returned tensors must have their shapes declared prior to the call as this is what allows the call to be made on the stream. If external host logic is required to compute the shape (avoid at all costs!) a separate func.call can be used outside of the stream to do so. If shapes are unknowable until the operation is performed it should be made as a normal asynchronous host call with 'coarse-fences' instead.</p> <p>Traits: AttrSizedOperandSegments</p> <p>Interfaces: CallOpInterface, FLOW_StreamableOp, SymbolUserOpInterface, TiedOpInterface, Util_ShapeAwareOp</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_15","title":"Attributes:","text":"Attribute MLIR Type Description <code>callee</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute"},{"location":"reference/mlir-dialects/Flow/#operands_15","title":"Operands:","text":"Operand Description <code>arguments</code> any type <code>argument_dims</code> index <code>result_dims</code> index"},{"location":"reference/mlir-dialects/Flow/#results_17","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"reference/mlir-dialects/Flow/#flowfunc-flowfuncop","title":"<code>flow.func</code> (Flow::FuncOp)","text":"<p>Streamable function declaration</p> <p>Syntax:</p> <pre><code>operation ::= `flow.func` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              $sym_name\n              ``\n              custom&lt;ShapedFunctionSignature&gt;($function_type,\n              $tied_operands,\n              $arg_attrs,\n              $res_attrs)\n              attr-dict-with-keyword\n              ($body^)?\n</code></pre> <p>Declares a function that can be called as an asynchronous streaming operation via <code>flow.call</code>. Today only external functions are allowed.</p> <p>Traits: IsolatedFromAbove</p> <p>Interfaces: CallableOpInterface, FunctionOpInterface, Symbol</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_16","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_name</code> ::mlir::StringAttr string attribute <code>function_type</code> ::mlir::TypeAttr type attribute of function type <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>arg_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes <code>res_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes"},{"location":"reference/mlir-dialects/Flow/#tensor-ops","title":"Tensor ops","text":""},{"location":"reference/mlir-dialects/Flow/#flowdispatchworkgroup_count_from_dag_root-flowdispatchworkgroupcountfromdagrootop","title":"<code>flow.dispatch.workgroup_count_from_dag_root</code> (Flow::DispatchWorkgroupCountFromDagRootOp)","text":"<p>_     workgroup count computed based on iteration range of the root of the DAG     for ops within the dispatch.   _</p> <p>Syntax:</p> <pre><code>operation ::= `flow.dispatch.workgroup_count_from_dag_root` attr-dict $operands\n</code></pre> <p>When using tile + distribution of the root of the DAG (Directed Acyclic Graph) of ops within the dispatch to split the work amongst workgroups. The workload captured is the size of the iteration space of the root of the DAG. This op represents the computation that given the workload returns the number of workgroups to use. The backends are responsible for lowering this op into actual computation (typically based on the tile sizes used to tile and distribute the root of the DAG).</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_16","title":"Operands:","text":"Operand Description <code>operands</code> index"},{"location":"reference/mlir-dialects/Flow/#results_18","title":"Results:","text":"Result Description <code>x</code> index <code>y</code> index <code>z</code> index"},{"location":"reference/mlir-dialects/Flow/#flowdispatchworkgroup_count_from_slice-flowdispatchworkgroupcountfromsliceop","title":"<code>flow.dispatch.workgroup_count_from_slice</code> (Flow::DispatchWorkgroupCountFromSliceOp)","text":"<p>_     Place holder to signify default workgroup count calculation.   _</p> <p>Syntax:</p> <pre><code>operation ::= `flow.dispatch.workgroup_count_from_slice` attr-dict $operands\n</code></pre> <p>The default computation of the number of workgroups (or workgroup count) assumes that the dispatch + captured values is enough to compute the workgroup count. It does so by using a program slice of the values within the dispatch that represent the number of workgroups when available within the dispatch. Currently the arguments of index types captured by the <code>flow.dispatch.workgroups</code> is treated as the workload for the operation. It is a requirement that the slice of the program that computes the number of workgroups will need to have its leaves be these captured values.</p> <p>TODO: This could be generalized in future to allow the slices to encompass arbitrary computation. The computation of the workgroup count can then be done on the device itself, if this is data dependent. In such cases the workload could be more than just values of index types.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_17","title":"Operands:","text":"Operand Description <code>operands</code> index"},{"location":"reference/mlir-dialects/Flow/#results_19","title":"Results:","text":"Result Description <code>x</code> index <code>y</code> index <code>z</code> index"},{"location":"reference/mlir-dialects/Flow/#flowdispatchworkloadordinal-flowdispatchworkloadordinalop","title":"<code>flow.dispatch.workload.ordinal</code> (Flow::DispatchWorkloadOrdinalOp)","text":"<p>_     Annotates the values captured as workload within the body of     <code>flow.dispatch.workgroups</code> op.   _</p> <p>Syntax:</p> <pre><code>operation ::= `flow.dispatch.workload.ordinal` attr-dict $operand `,` $ordinal `:` type($operand)\n</code></pre> <p>The arguments that represent the captured/returned values of the `flow.dispatch.workgroups, i.e. the signature of the body of the op is not preserved during IREEs compilation. Since the workloads are derived from the operands captured by the operation, this op denotes the values captured as workloads. This can be used in the backends to map back to the workload values while materializing the workgroup count computation.</p> <p>TODO: Find a better way to represent this information, either by somehow propagating the signature of the created dispatch workgroup op through the compilation stack until the codegen backends, or as a separate list/attribute that can be plumbed through without using explicit ops.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_17","title":"Attributes:","text":"Attribute MLIR Type Description <code>ordinal</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/Flow/#operands_18","title":"Operands:","text":"Operand Description <code>operand</code> index"},{"location":"reference/mlir-dialects/Flow/#results_20","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/Flow/#flowtensoralloca-flowtensorallocaop","title":"<code>flow.tensor.alloca</code> (Flow::TensorAllocaOp)","text":"<p>An empty tensor allocation with undefined contents</p> <p>Syntax:</p> <pre><code>operation ::= `flow.tensor.alloca` `:` type($result) (`{` $result_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Returns a new transient tensor allocation with undefined contents. Subsequent writes must populate any ranges of the tensor that are later read. The resulting tensor may be long-lived and allocated as part of a dedicated allocation. Prefer using <code>flow.tensor.empty</code> whenever possible as this op disables nearly all allocation-related optimizations performed by the compiler. The presence of this op is often an indication of an improper lowering.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_19","title":"Operands:","text":"Operand Description <code>result_dims</code> index"},{"location":"reference/mlir-dialects/Flow/#results_21","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowtensorclone-flowtensorcloneop","title":"<code>flow.tensor.clone</code> (Flow::TensorCloneOp)","text":"<p>Performs a full tensor clone operation</p> <p>Syntax:</p> <pre><code>operation ::= `flow.tensor.clone` $operand `:` type($result) (`{` $argument_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Clones the input tensor into an identical output tensor.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, FLOW_StreamableOp, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_20","title":"Operands:","text":"Operand Description <code>operand</code> ranked tensor of any type values <code>argument_dims</code> index"},{"location":"reference/mlir-dialects/Flow/#results_22","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowtensorconstant-flowtensorconstantop","title":"<code>flow.tensor.constant</code> (Flow::TensorConstantOp)","text":"<p>Tensor constant that can have dynamic dimensions</p> <p>Syntax:</p> <pre><code>operation ::= `flow.tensor.constant` $value attr-dict `-&gt;` type($result)\n</code></pre> <p>Allows specifying a constant where the return value can erase shape information. This operation is declared as having side effects and has no folder, so will not be optimized away by the compiler. The underlying shape information should be hidden from the compiler and resolved at runtime.</p> <pre><code>%c = flow.tensor.constant tensor&lt;2x2xf32&gt; -&gt; tensor&lt;?x?xf32&gt;\n%res = math.absf %c : tensor&lt;?x?xf32&gt;\n</code></pre>"},{"location":"reference/mlir-dialects/Flow/#attributes_18","title":"Attributes:","text":"Attribute MLIR Type Description <code>value</code> ::mlir::ElementsAttr constant vector/tensor attribute"},{"location":"reference/mlir-dialects/Flow/#results_23","title":"Results:","text":"Result Description <code>result</code> tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowtensorempty-flowtensoremptyop","title":"<code>flow.tensor.empty</code> (Flow::TensorEmptyOp)","text":"<p>An empty tensor carrying metadata but no contents</p> <p>Syntax:</p> <pre><code>operation ::= `flow.tensor.empty` `:` type($result) (`{` $result_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Returns a tensor with undefined contents. Subsequent writes must populate any ranges of the tensor that are later read.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, FLOW_StreamableOp, NoMemoryEffect (MemoryEffectOpInterface), Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_21","title":"Operands:","text":"Operand Description <code>result_dims</code> index"},{"location":"reference/mlir-dialects/Flow/#results_24","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowtensorload-flowtensorloadop","title":"<code>flow.tensor.load</code> (Flow::TensorLoadOp)","text":"<p>Loads a value from a tensor element</p> <p>Syntax:</p> <pre><code>operation ::= `flow.tensor.load` $source (`[` $indices^ `]`)? `:`\n              type($source) (`{` $source_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Returns the element at the given location from within the tensor.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_22","title":"Operands:","text":"Operand Description <code>source</code> ranked tensor of any type values <code>source_dims</code> index <code>indices</code> index"},{"location":"reference/mlir-dialects/Flow/#results_25","title":"Results:","text":"Result Description <code>result</code> index or signless integer or floating-point or complex-type or vector of any type values"},{"location":"reference/mlir-dialects/Flow/#flowtensorreshape-flowtensorreshapeop","title":"<code>flow.tensor.reshape</code> (Flow::TensorReshapeOp)","text":"<p>Reshapes a tensor</p> <p>Syntax:</p> <pre><code>operation ::= `flow.tensor.reshape` $source `:`\n              type($source) (`{` $source_dims^ `}`)? `-&gt;`\n              type($result) (`{` $result_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Reshapes a tensor to a new shape without modifying the contents.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, FLOW_StreamableOp, NoMemoryEffect (MemoryEffectOpInterface), TiedOpInterface, Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_23","title":"Operands:","text":"Operand Description <code>source</code> ranked tensor of any type values <code>source_dims</code> index <code>result_dims</code> index"},{"location":"reference/mlir-dialects/Flow/#results_26","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowtensorslice-flowtensorsliceop","title":"<code>flow.tensor.slice</code> (Flow::TensorSliceOp)","text":"<p>Slices out a subregion of a tensor</p> <p>Syntax:</p> <pre><code>operation ::= `flow.tensor.slice` $source `[` $start_indices `for` $lengths `]` `:`\n              type($source) (`{` $source_dims^ `}`)? `-&gt;`\n              type($result) (`{` $result_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Clones a subregion of a tensor.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, FLOW_StreamableOp, NoMemoryEffect (MemoryEffectOpInterface), Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_24","title":"Operands:","text":"Operand Description <code>source</code> ranked tensor of any type values <code>source_dims</code> index <code>start_indices</code> index <code>lengths</code> index <code>result_dims</code> index"},{"location":"reference/mlir-dialects/Flow/#results_27","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowtensorsplat-flowtensorsplatop","title":"<code>flow.tensor.splat</code> (Flow::TensorSplatOp)","text":"<p>Splats a value into a shaped tensor</p> <p>Syntax:</p> <pre><code>operation ::= `flow.tensor.splat` $value `:` type($result) (`{` $result_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Returns a tensor initialized to the given primitive value.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, FLOW_StreamableOp, NoMemoryEffect (MemoryEffectOpInterface), Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_25","title":"Operands:","text":"Operand Description <code>value</code> index or signless integer or floating-point or complex-type <code>result_dims</code> index"},{"location":"reference/mlir-dialects/Flow/#results_28","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowtensorstore-flowtensorstoreop","title":"<code>flow.tensor.store</code> (Flow::TensorStoreOp)","text":"<p>Stores a value into a tensor element</p> <p>Syntax:</p> <pre><code>operation ::= `flow.tensor.store` $value `,` $target (`[` $indices^ `]`)? `:`\n              type($target) (`{` $target_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Returns a tensor with the element at the given index set to the given value.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_26","title":"Operands:","text":"Operand Description <code>value</code> index or signless integer or floating-point or complex-type or vector of any type values <code>target</code> ranked tensor of any type values <code>target_dims</code> index <code>indices</code> index"},{"location":"reference/mlir-dialects/Flow/#results_29","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowtensortie_shape-flowtensortieshapeop","title":"<code>flow.tensor.tie_shape</code> (Flow::TensorTieShapeOp)","text":"<p>Ties a runtime shape to a tensor value</p> <p>Syntax:</p> <pre><code>operation ::= `flow.tensor.tie_shape` $operand attr-dict\n              `:` type($result) (`{` $dynamic_dims^ `}`)?\n</code></pre> <p>Metadata op used to tie tensors with their runtime-computed dynamic dimensions. This only exists transiently in the IR as a witness to shape calculations and is removed during lowering.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), ReifyRankedShapedTypeOpInterface, Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_27","title":"Operands:","text":"Operand Description <code>operand</code> ranked tensor of any type values <code>dynamic_dims</code> index"},{"location":"reference/mlir-dialects/Flow/#results_30","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowtensortrace-flowtensortraceop","title":"<code>flow.tensor.trace</code> (Flow::TensorTraceOp)","text":"<p>Trace value(s) operation</p> <p>Syntax:</p> <pre><code>operation ::= `flow.tensor.trace` attr-dict ($operands^ `:` type($operands))?\n</code></pre> <p>Traces out to a runtime trace sink (console, log file, etc) the given tensors and titles them with the given key. The key is informational only and useful for titling/marking specific sets of tensors for easier searching.</p>"},{"location":"reference/mlir-dialects/Flow/#attributes_19","title":"Attributes:","text":"Attribute MLIR Type Description <code>key</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/Flow/#operands_28","title":"Operands:","text":"Operand Description <code>operands</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#flowtensorupdate-flowtensorupdateop","title":"<code>flow.tensor.update</code> (Flow::TensorUpdateOp)","text":"<p>Updates a tensor with the contents of another tensor</p> <p>Syntax:</p> <pre><code>operation ::= `flow.tensor.update` $update `,` $target `[` $start_indices `]` `:`\n              type($update) (`{` $update_dims^ `}`)? `-&gt;`\n              custom&lt;ShapedTiedResult&gt;(type($result), $target_dims)\n              attr-dict-with-keyword\n</code></pre> <p>Updates the target tensor with the contents of the update tensor at the given offset indices.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, FLOW_StreamableOp, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), TiedOpInterface, Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Flow/#operands_29","title":"Operands:","text":"Operand Description <code>target</code> ranked tensor of any type values <code>target_dims</code> index <code>start_indices</code> index <code>update</code> ranked tensor of any type values <code>update_dims</code> index"},{"location":"reference/mlir-dialects/Flow/#results_31","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/Flow/#attribute-definition","title":"Attribute definition","text":""},{"location":"reference/mlir-dialects/Flow/#dummyattr","title":"DummyAttr","text":"<p>Syntax: <code>#flow.dummy</code></p>"},{"location":"reference/mlir-dialects/Flow/#type-constraint-definition","title":"Type constraint definition","text":""},{"location":"reference/mlir-dialects/Flow/#dispatchtensor","title":"dispatch.tensor","text":"<p>A placeholder for a dispatch region input/output operand. This can be used to query the metadata about the tensor (such as its shape) as well as both load and store from the backing tensor representation.</p>"},{"location":"reference/mlir-dialects/Flow/#dispatchtensor_1","title":"dispatch.tensor","text":"<p>A placeholder for a dispatch region input operand. This can be used to query the metadata about the tensor (such as its shape) as well as load from the backing tensor representation.</p>"},{"location":"reference/mlir-dialects/Flow/#dispatchtensor_2","title":"dispatch.tensor","text":"<p>A placeholder for a dispatch region output operand. This can be used to query the metadata about the tensor (such as its shape) as well as store to the backing tensor representation.</p>"},{"location":"reference/mlir-dialects/Flow/#type-definition","title":"Type definition","text":""},{"location":"reference/mlir-dialects/Flow/#channeltype","title":"ChannelType","text":"<p>a collecive communication channel</p> <p>Syntax: <code>!flow.channel</code></p> <p>Represents a single participant in a collective clique. Multiple channels may exist within the same program to allow for partial operations or hierarchical operations.</p> <p>In programs that have already been partitioned prior to being compiled there will often exist only one channel and <code>flow.channel.default</code> can be used to reference it. In programs that model SPMD behavior internally channels can be created or provided by hosting applications.</p>"},{"location":"reference/mlir-dialects/Flow/#dummytype","title":"DummyType","text":"<p>Syntax: <code>!flow.dummy</code></p>"},{"location":"reference/mlir-dialects/HAL/","title":"HAL","text":""},{"location":"reference/mlir-dialects/HAL/#hal-dialect","title":"'hal' Dialect","text":"<p>A dialect representing operations against the IREE HAL.</p> <p>This can be thought of as a Vulkan-like model with all of the graphics bits chopped out.</p> <p>The type set is limited to those that can be represented in the IREE HAL design: buffers and views, synchronization primitives like semaphores, and and command buffers. The intent is that if a device could implement the HAL interface the sequencer ops could run on that device, such as being able to run on a GPU via indirect command buffers.</p> <p>Though this is mostly a 1:1 mapping to the iree::hal API there are some methods omitted as they are not likely to be needed in IR. It's assumed that either sequencer interfaces will encapsulate the logic (such as device resolution) or that certain features are unsafe to expose to user-defined input.</p> <ul> <li>'hal' Dialect<ul> <li>Operation definition<ul> <li>Allocator ops<ul> <li>hal.allocator.allocate.initialized (HAL::AllocatorAllocateInitializedOp)</li> <li>hal.allocator.allocate (HAL::AllocatorAllocateOp)</li> <li>hal.allocator.try_map (HAL::AllocatorTryMapOp)</li> </ul> </li> <li>Buffer ops<ul> <li>hal.buffer.assert (HAL::BufferAssertOp)</li> <li>hal.buffer.length (HAL::BufferLengthOp)</li> <li>hal.buffer.load (HAL::BufferLoadOp)</li> <li>hal.buffer.store (HAL::BufferStoreOp)</li> <li>hal.buffer.subspan (HAL::BufferSubspanOp)</li> </ul> </li> <li>Buffer view ops<ul> <li>hal.buffer_view.assert (HAL::BufferViewAssertOp)</li> <li>hal.buffer_view.buffer (HAL::BufferViewBufferOp)</li> <li>hal.buffer_view.create (HAL::BufferViewCreateOp)</li> <li>hal.buffer_view.dim (HAL::BufferViewDimOp)</li> <li>hal.buffer_view.element_type (HAL::BufferViewElementTypeOp)</li> <li>hal.buffer_view.encoding_type (HAL::BufferViewEncodingTypeOp)</li> <li>hal.buffer_view.rank (HAL::BufferViewRankOp)</li> <li>hal.buffer_view.trace (HAL::BufferViewTraceOp)</li> </ul> </li> <li>Channel ops<ul> <li>hal.channel.create (HAL::ChannelCreateOp)</li> <li>hal.channel.rank_and_count (HAL::ChannelRankAndCountOp)</li> <li>hal.channel.split (HAL::ChannelSplitOp)</li> </ul> </li> <li>Command buffer ops<ul> <li>hal.command_buffer.begin_debug_group (HAL::CommandBufferBeginDebugGroupOp)</li> <li>hal.command_buffer.collective (HAL::CommandBufferCollectiveOp)</li> <li>hal.command_buffer.copy_buffer (HAL::CommandBufferCopyBufferOp)</li> <li>hal.command_buffer.create (HAL::CommandBufferCreateOp)</li> <li>hal.command_buffer.device (HAL::CommandBufferDeviceOp)</li> <li>hal.command_buffer.dispatch.indirect (HAL::CommandBufferDispatchIndirectOp)</li> <li>hal.command_buffer.dispatch.indirect.symbol (HAL::CommandBufferDispatchIndirectSymbolOp)</li> <li>hal.command_buffer.dispatch (HAL::CommandBufferDispatchOp)</li> <li>hal.command_buffer.dispatch.symbol (HAL::CommandBufferDispatchSymbolOp)</li> <li>hal.command_buffer.end_debug_group (HAL::CommandBufferEndDebugGroupOp)</li> <li>hal.command_buffer.execution_barrier (HAL::CommandBufferExecutionBarrierOp)</li> <li>hal.command_buffer.fill_buffer (HAL::CommandBufferFillBufferOp)</li> <li>hal.command_buffer.finalize (HAL::CommandBufferFinalizeOp)</li> <li>hal.command_buffer.push_constants (HAL::CommandBufferPushConstantsOp)</li> <li>hal.command_buffer.push_descriptor_set (HAL::CommandBufferPushDescriptorSetOp)</li> </ul> </li> <li>Descriptor set layout ops<ul> <li>hal.descriptor_set_layout.create (HAL::DescriptorSetLayoutCreateOp)</li> <li>hal.descriptor_set_layout.lookup (HAL::DescriptorSetLayoutLookupOp)</li> </ul> </li> <li>Device ops<ul> <li>hal.device.allocator (HAL::DeviceAllocatorOp)</li> <li>hal.device.query (HAL::DeviceQueryOp)</li> <li>hal.device.queue.alloca (HAL::DeviceQueueAllocaOp)</li> <li>hal.device.queue.dealloca (HAL::DeviceQueueDeallocaOp)</li> <li>hal.device.queue.execute (HAL::DeviceQueueExecuteOp)</li> <li>hal.device.queue.flush (HAL::DeviceQueueFlushOp)</li> <li>hal.device.switch (HAL::DeviceSwitchOp)</li> <li>hal.return (HAL::ReturnOp)</li> </ul> </li> <li>Executable ops<ul> <li>hal.executable.binary (HAL::ExecutableBinaryOp)</li> <li>hal.executable.calculate_workgroups (HAL::ExecutableCalculateWorkgroupsOp)</li> <li>hal.executable.constant.block (HAL::ExecutableConstantBlockOp)</li> <li>hal.executable.constant.load (HAL::ExecutableConstantLoadOp)</li> <li>hal.executable.create (HAL::ExecutableCreateOp)</li> <li>hal.executable_end (HAL::ExecutableEndOp)</li> <li>hal.executable.export (HAL::ExecutableExportOp)</li> <li>hal.executable.lookup (HAL::ExecutableLookupOp)</li> <li>hal.executable (HAL::ExecutableOp)</li> <li>hal.executable.source_end (HAL::ExecutableSourceEndOp)</li> <li>hal.executable.source (HAL::ExecutableSourceOp)</li> <li>hal.executable.variant_end (HAL::ExecutableVariantEndOp)</li> <li>hal.executable.variant (HAL::ExecutableVariantOp)</li> </ul> </li> <li>Experimental ops<ul> <li>hal.ex.shared_device (HAL::ExSharedDeviceOp)</li> </ul> </li> <li>Fence ops<ul> <li>hal.fence.await (HAL::FenceAwaitOp)</li> <li>hal.fence.create (HAL::FenceCreateOp)</li> <li>hal.fence.fail (HAL::FenceFailOp)</li> <li>hal.fence.join (HAL::FenceJoinOp)</li> <li>hal.fence.query (HAL::FenceQueryOp)</li> <li>hal.fence.signal (HAL::FenceSignalOp)</li> </ul> </li> <li>Instrument ops<ul> <li>hal.instrument.memory.load (HAL::InstrumentMemoryLoadOp)</li> <li>hal.instrument.memory.store (HAL::InstrumentMemoryStoreOp)</li> <li>hal.instrument.print (HAL::InstrumentPrintOp)</li> <li>hal.instrument.value (HAL::InstrumentValueOp)</li> <li>hal.instrument.workgroup (HAL::InstrumentWorkgroupOp)</li> </ul> </li> <li>Interface ops<ul> <li>hal.interface.binding.subspan (HAL::InterfaceBindingSubspanOp)</li> <li>hal.interface.constant.load (HAL::InterfaceConstantLoadOp)</li> <li>hal.interface.workgroup.count (HAL::InterfaceWorkgroupCountOp)</li> <li>hal.interface.workgroup.id (HAL::InterfaceWorkgroupIDOp)</li> <li>hal.interface.workgroup.size (HAL::InterfaceWorkgroupSizeOp)</li> </ul> </li> <li>Pipeline layout ops<ul> <li>hal.pipeline_layout.create (HAL::PipelineLayoutCreateOp)</li> <li>hal.pipeline_layout.lookup (HAL::PipelineLayoutLookupOp)</li> </ul> </li> <li>Pseudo Ops<ul> <li>hal.tensor.barrier (HAL::TensorBarrierOp)</li> <li>hal.tensor.export (HAL::TensorExportOp)</li> <li>hal.tensor.import (HAL::TensorImportOp)</li> </ul> </li> </ul> </li> <li>Attribute definition<ul> <li>AffinityQueueAttr</li> <li>CollectiveAttr</li> <li>DescriptorSetBindingAttr</li> <li>DescriptorSetLayoutAttr</li> <li>DescriptorTypeAttr</li> <li>DeviceMatchArchitectureAttr</li> <li>DeviceMatchExecutableFormatAttr</li> <li>DeviceMatchFeatureAttr</li> <li>DeviceMatchIDAttr</li> <li>DeviceTargetAttr</li> <li>ExecutableObjectAttr</li> <li>ExecutableObjectsAttr</li> <li>ExecutableTargetAttr</li> <li>InterfaceBindingAttr</li> <li>MatchAllAttr</li> <li>MatchAlwaysAttr</li> <li>MatchAnyAttr</li> <li>PipelineLayoutAttr</li> </ul> </li> <li>Type constraint definition<ul> <li>allocator</li> <li>buffer</li> <li>buffer_view</li> <li>collective.channel</li> <li>command_buffer</li> <li>descriptor_set_layout</li> <li>device</li> <li>event</li> <li>executable</li> <li>fence</li> <li>pipeline_layout</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/mlir-dialects/HAL/#operation-definition","title":"Operation definition","text":""},{"location":"reference/mlir-dialects/HAL/#allocator-ops","title":"Allocator ops","text":"<p>Ops for <code>!hal.allocator</code> / <code>iree_hal_allocator_t</code>.</p>"},{"location":"reference/mlir-dialects/HAL/#halallocatorallocateinitialized-halallocatorallocateinitializedop","title":"<code>hal.allocator.allocate.initialized</code> (HAL::AllocatorAllocateInitializedOp)","text":"<p>Allocator-supported host buffer wrapping operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.allocator.allocate.initialized` `&lt;` $allocator `:` type($allocator) `&gt;`\n              `source` `(` $source `:` type($source) `)` `` `[` $offset `,` $length `]`\n              `type` `(` $memory_types `)`\n              `usage` `(` $buffer_usage `)`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Wraps a !hal.buffer around host read-only memory backed by the given byte buffer. The returned buffer may be host-only and not directly usable on devices.</p> <p>Interfaces: OpAsmOpInterface, SizeAwareOpInterface</p>"},{"location":"reference/mlir-dialects/HAL/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>memory_types</code> mlir::iree_compiler::IREE::HAL::MemoryTypeBitfieldAttr valid MemoryType <code>buffer_usage</code> mlir::iree_compiler::IREE::HAL::BufferUsageBitfieldAttr valid BufferUsage"},{"location":"reference/mlir-dialects/HAL/#operands","title":"Operands:","text":"Operand Description <code>allocator</code> allocator <code>source</code> a reference counted byte buffer <code>offset</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/HAL/#results","title":"Results:","text":"Result Description <code>result</code> buffer"},{"location":"reference/mlir-dialects/HAL/#halallocatorallocate-halallocatorallocateop","title":"<code>hal.allocator.allocate</code> (HAL::AllocatorAllocateOp)","text":"<p>Empty buffer allocation operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.allocator.allocate` `&lt;` $allocator `:` type($allocator) `&gt;`\n              `type` `(` $memory_types `)`\n              `usage` `(` $buffer_usage `)`\n              `:` custom&lt;SizeAwareType&gt;(type($result), $result_size)\n              attr-dict-with-keyword\n</code></pre> <p>Allocates a buffer of the given size from the allocator. The size of the buffer returned may be larger than the requested size if the allocator has specific alignment requirements or minimum allocation sizes.</p> <p>Interfaces: OpAsmOpInterface, SizeAwareOpInterface</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>memory_types</code> mlir::iree_compiler::IREE::HAL::MemoryTypeBitfieldAttr valid MemoryType <code>buffer_usage</code> mlir::iree_compiler::IREE::HAL::BufferUsageBitfieldAttr valid BufferUsage"},{"location":"reference/mlir-dialects/HAL/#operands_1","title":"Operands:","text":"Operand Description <code>allocator</code> allocator <code>result_size</code> index"},{"location":"reference/mlir-dialects/HAL/#results_1","title":"Results:","text":"Result Description <code>result</code> buffer"},{"location":"reference/mlir-dialects/HAL/#halallocatortry_map-halallocatortrymapop","title":"<code>hal.allocator.try_map</code> (HAL::AllocatorTryMapOp)","text":"<p>Allocator-supported host buffer wrapping operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.allocator.try_map` `&lt;` $allocator `:` type($allocator) `&gt;`\n              `source` `(` $source `:` type($source) `)` `` `[` $offset `,` $length `]`\n              `type` `(` $memory_types `)`\n              `usage` `(` $buffer_usage `)`\n              `:` type($did_map) `,` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Tries wrapping a !hal.buffer around host read-only memory backed by the given byte buffer. The returned buffer may be host-only and not directly usable on devices. If the mapping cannot be completed (such as trying to map the host memory as device-local on devices with discrete memory) then did_map will indicate that the returned buffer is null.</p> <p>Interfaces: OpAsmOpInterface, SizeAwareOpInterface</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_2","title":"Attributes:","text":"Attribute MLIR Type Description <code>memory_types</code> mlir::iree_compiler::IREE::HAL::MemoryTypeBitfieldAttr valid MemoryType <code>buffer_usage</code> mlir::iree_compiler::IREE::HAL::BufferUsageBitfieldAttr valid BufferUsage"},{"location":"reference/mlir-dialects/HAL/#operands_2","title":"Operands:","text":"Operand Description <code>allocator</code> allocator <code>source</code> a reference counted byte buffer <code>offset</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/HAL/#results_2","title":"Results:","text":"Result Description <code>did_map</code> 1-bit signless integer <code>result</code> buffer"},{"location":"reference/mlir-dialects/HAL/#buffer-ops","title":"Buffer ops","text":"<p>Ops for <code>!hal.buffer</code> / <code>iree_hal_buffer_t</code>.</p>"},{"location":"reference/mlir-dialects/HAL/#halbufferassert-halbufferassertop","title":"<code>hal.buffer.assert</code> (HAL::BufferAssertOp)","text":"<p>Buffer compatibility assertion</p> <p>Syntax:</p> <pre><code>operation ::= `hal.buffer.assert` `&lt;` $buffer `:` type($buffer) `&gt;`\n              `message` `(` $message `)`\n              `allocator` `(` $allocator `:` type($allocator) `)`\n              `minimum_length` `(` $minimum_length `)`\n              `type` `(` $memory_types `)`\n              `usage` `(` $buffer_usage `)`\n              attr-dict-with-keyword\n</code></pre> <p>Asserts that the buffer is compatible with the given allocator and usage. Program execution will abort as if <code>std.assert</code> had been used.</p> <p>This only checks that the buffer can be used and not that it matches the given parameters exactly. Buffers may be from other allocators so long as the allocators are compatible (devices can address each other's memory), the type and usage contain all the requested bits (having more bits is ok), and the length is at least the requested minimum (as padding may be ignored).</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_3","title":"Attributes:","text":"Attribute MLIR Type Description <code>message</code> ::mlir::StringAttr string attribute <code>memory_types</code> mlir::iree_compiler::IREE::HAL::MemoryTypeBitfieldAttr valid MemoryType <code>buffer_usage</code> mlir::iree_compiler::IREE::HAL::BufferUsageBitfieldAttr valid BufferUsage"},{"location":"reference/mlir-dialects/HAL/#operands_3","title":"Operands:","text":"Operand Description <code>buffer</code> buffer <code>allocator</code> allocator <code>minimum_length</code> index"},{"location":"reference/mlir-dialects/HAL/#halbufferlength-halbufferlengthop","title":"<code>hal.buffer.length</code> (HAL::BufferLengthOp)","text":"<p>Buffer byte length accessor</p> <p>Syntax:</p> <pre><code>operation ::= `hal.buffer.length` `&lt;` $buffer `:` type($buffer) `&gt;`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the allocated size of a buffer in bytes. May be less than the underlying buffer allocation if this is a subspan or view into another buffer.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#operands_4","title":"Operands:","text":"Operand Description <code>buffer</code> buffer"},{"location":"reference/mlir-dialects/HAL/#results_3","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/HAL/#halbufferload-halbufferloadop","title":"<code>hal.buffer.load</code> (HAL::BufferLoadOp)","text":"<p>Buffer element load operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.buffer.load` `&lt;` $source_buffer `:` type($source_buffer) `&gt;`\n              `` `[` $source_offset `]`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Loads a value from a buffer by mapping it.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#operands_5","title":"Operands:","text":"Operand Description <code>source_buffer</code> buffer <code>source_offset</code> index"},{"location":"reference/mlir-dialects/HAL/#results_4","title":"Results:","text":"Result Description <code>result</code> index or signless integer or floating-point or complex-type or vector of any type values"},{"location":"reference/mlir-dialects/HAL/#halbufferstore-halbufferstoreop","title":"<code>hal.buffer.store</code> (HAL::BufferStoreOp)","text":"<p>Buffer element store operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.buffer.store` `&lt;` $target_buffer `:` type($target_buffer) `&gt;`\n              `` `[` $target_offset `]`\n              `value` `(` $value `:` type($value) `)`\n              attr-dict-with-keyword\n</code></pre> <p>Stores a value into a buffer by mapping it.</p>"},{"location":"reference/mlir-dialects/HAL/#operands_6","title":"Operands:","text":"Operand Description <code>value</code> index or signless integer or floating-point or complex-type or vector of any type values <code>target_buffer</code> buffer <code>target_offset</code> index"},{"location":"reference/mlir-dialects/HAL/#halbuffersubspan-halbuffersubspanop","title":"<code>hal.buffer.subspan</code> (HAL::BufferSubspanOp)","text":"<p>Buffer subspan operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.buffer.subspan` `&lt;` $source_buffer `:` type($source_buffer) `&gt;`\n              `` `[` $source_offset `,` $length `]`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns a reference to a subspan of the buffer.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, SizeAwareOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#operands_7","title":"Operands:","text":"Operand Description <code>source_buffer</code> buffer <code>source_offset</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/HAL/#results_5","title":"Results:","text":"Result Description <code>result</code> buffer"},{"location":"reference/mlir-dialects/HAL/#buffer-view-ops","title":"Buffer view ops","text":"<p>Ops for <code>!hal.buffer_view</code> / <code>iree_hal_buffer_view_t</code>.</p>"},{"location":"reference/mlir-dialects/HAL/#halbuffer_viewassert-halbufferviewassertop","title":"<code>hal.buffer_view.assert</code> (HAL::BufferViewAssertOp)","text":"<p>Buffer view contents assertion</p> <p>Syntax:</p> <pre><code>operation ::= `hal.buffer_view.assert` `&lt;` $buffer_view `:` type($buffer_view) `&gt;`\n              `message` `(` $message `)`\n              `shape` `(` `[` $shape `]` `)`\n              `type` `(` $element_type `)`\n              `encoding` `(` $encoding_type `)`\n              attr-dict-with-keyword\n</code></pre> <p>Asserts that the buffer view contains a data compatible tensor with the given encoding. Program execution will abort as if <code>std.assert</code> had been used.</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_4","title":"Attributes:","text":"Attribute MLIR Type Description <code>message</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/HAL/#operands_8","title":"Operands:","text":"Operand Description <code>buffer_view</code> buffer_view <code>element_type</code> 32-bit signless integer <code>encoding_type</code> 32-bit signless integer <code>shape</code> index"},{"location":"reference/mlir-dialects/HAL/#halbuffer_viewbuffer-halbufferviewbufferop","title":"<code>hal.buffer_view.buffer</code> (HAL::BufferViewBufferOp)","text":"<p>Buffer view buffer accessor</p> <p>Syntax:</p> <pre><code>operation ::= `hal.buffer_view.buffer` `&lt;` $buffer_view `:` type($buffer_view) `&gt;`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the buffer backing this view's contents.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#operands_9","title":"Operands:","text":"Operand Description <code>buffer_view</code> buffer_view"},{"location":"reference/mlir-dialects/HAL/#results_6","title":"Results:","text":"Result Description <code>result</code> buffer"},{"location":"reference/mlir-dialects/HAL/#halbuffer_viewcreate-halbufferviewcreateop","title":"<code>hal.buffer_view.create</code> (HAL::BufferViewCreateOp)","text":"<p>Buffer view reference initializer</p> <p>Syntax:</p> <pre><code>operation ::= `hal.buffer_view.create` `buffer` `(` $source_buffer `:` type($source_buffer) `)`\n              `` `[` $source_offset `,` $source_length `]`\n              `shape` `(` `[` $shape `]` `)`\n              `type` `(` $element_type `)`\n              `encoding` `(` $encoding_type `)`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Creates a reference to a buffer with a particular shape and element type. The buffer is not copied and both the original and view references must be synchronized. This makes it easier to associate commonly-carried metadata along with the contents.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#operands_10","title":"Operands:","text":"Operand Description <code>source_buffer</code> buffer <code>source_offset</code> index <code>source_length</code> index <code>element_type</code> 32-bit signless integer <code>encoding_type</code> 32-bit signless integer <code>shape</code> index"},{"location":"reference/mlir-dialects/HAL/#results_7","title":"Results:","text":"Result Description <code>result</code> buffer_view"},{"location":"reference/mlir-dialects/HAL/#halbuffer_viewdim-halbufferviewdimop","title":"<code>hal.buffer_view.dim</code> (HAL::BufferViewDimOp)","text":"<p>Buffer view dimension value query</p> <p>Syntax:</p> <pre><code>operation ::= `hal.buffer_view.dim` `&lt;` $buffer_view `:` type($buffer_view) `&gt;`\n              `` `[` $index `]`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the value of the given dimension.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_5","title":"Attributes:","text":"Attribute MLIR Type Description <code>index</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/HAL/#operands_11","title":"Operands:","text":"Operand Description <code>buffer_view</code> buffer_view"},{"location":"reference/mlir-dialects/HAL/#results_8","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/HAL/#halbuffer_viewelement_type-halbufferviewelementtypeop","title":"<code>hal.buffer_view.element_type</code> (HAL::BufferViewElementTypeOp)","text":"<p>Buffer view element type query</p> <p>Syntax:</p> <pre><code>operation ::= `hal.buffer_view.element_type` `&lt;` $buffer_view `:` type($buffer_view) `&gt;`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the element type of the buffer view.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#operands_12","title":"Operands:","text":"Operand Description <code>buffer_view</code> buffer_view"},{"location":"reference/mlir-dialects/HAL/#results_9","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HAL/#halbuffer_viewencoding_type-halbufferviewencodingtypeop","title":"<code>hal.buffer_view.encoding_type</code> (HAL::BufferViewEncodingTypeOp)","text":"<p>Buffer view encoding type query</p> <p>Syntax:</p> <pre><code>operation ::= `hal.buffer_view.encoding_type` `&lt;` $buffer_view `:` type($buffer_view) `&gt;`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the encoding type of the buffer view.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#operands_13","title":"Operands:","text":"Operand Description <code>buffer_view</code> buffer_view"},{"location":"reference/mlir-dialects/HAL/#results_10","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HAL/#halbuffer_viewrank-halbufferviewrankop","title":"<code>hal.buffer_view.rank</code> (HAL::BufferViewRankOp)","text":"<p>Buffer view rank query</p> <p>Syntax:</p> <pre><code>operation ::= `hal.buffer_view.rank` `&lt;` $buffer_view `:` type($buffer_view) `&gt;`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the rank of the buffer view.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#operands_14","title":"Operands:","text":"Operand Description <code>buffer_view</code> buffer_view"},{"location":"reference/mlir-dialects/HAL/#results_11","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/HAL/#halbuffer_viewtrace-halbufferviewtraceop","title":"<code>hal.buffer_view.trace</code> (HAL::BufferViewTraceOp)","text":"<p>Trace value(s) operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.buffer_view.trace` $operands `:` type($operands)\n              attr-dict-with-keyword\n</code></pre> <p>Traces out to a runtime trace sink (console, log file, etc) the given buffer views and titles them with the given key. The key is informational only and useful for titling/marking specific sets of buffers for easier searching.</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_6","title":"Attributes:","text":"Attribute MLIR Type Description <code>key</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/HAL/#operands_15","title":"Operands:","text":"Operand Description <code>operands</code> buffer_view"},{"location":"reference/mlir-dialects/HAL/#channel-ops","title":"Channel ops","text":"<p>Ops for <code>!hal.channel</code> / <code>iree_hal_channel_t</code>.</p>"},{"location":"reference/mlir-dialects/HAL/#halchannelcreate-halchannelcreateop","title":"<code>hal.channel.create</code> (HAL::ChannelCreateOp)","text":"<p>Creates a new channel for collective communication</p> <p>Syntax:</p> <pre><code>operation ::= `hal.channel.create` `device` `(` $device `:` type($device) `)`\n              `affinity` `(` $queue_affinity `)`\n              `flags` `(` $flags `)`\n              `id` `(` $id `)`\n              `group` `(` $group `)`\n              `rank` `(` $rank `)`\n              `count` `(` $count `)`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns a new channel with the given rank associated with the given device queue. Collective operations using this channel must only be submitted on compatible queues.</p> <p>The group and ID are optional and may be null. A rank or count of -1 can be used to indicate a default inherited from the environment or device configuration.</p> <p>Interfaces: OpAsmOpInterface</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_7","title":"Attributes:","text":"Attribute MLIR Type Description <code>flags</code> ::mlir::IntegerAttr 32-bit signless integer attribute"},{"location":"reference/mlir-dialects/HAL/#operands_16","title":"Operands:","text":"Operand Description <code>device</code> device <code>queue_affinity</code> 64-bit signless integer <code>id</code> a reference counted byte buffer <code>group</code> a reference counted byte buffer <code>rank</code> 32-bit signless integer <code>count</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HAL/#results_12","title":"Results:","text":"Result Description <code>result</code> collective.channel"},{"location":"reference/mlir-dialects/HAL/#halchannelrank_and_count-halchannelrankandcountop","title":"<code>hal.channel.rank_and_count</code> (HAL::ChannelRankAndCountOp)","text":"<p>Returns the rank of the local participant in the group</p> <p>Syntax:</p> <pre><code>operation ::= `hal.channel.rank_and_count` `&lt;` $channel `:` type($channel) `&gt;`\n              `:` type($rank) `,` type($count)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the rank the channel represents as a participant in a collective group in <code>[0, count)</code> and the total participant count.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#operands_17","title":"Operands:","text":"Operand Description <code>channel</code> collective.channel"},{"location":"reference/mlir-dialects/HAL/#results_13","title":"Results:","text":"Result Description <code>rank</code> 32-bit signless integer <code>count</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HAL/#halchannelsplit-halchannelsplitop","title":"<code>hal.channel.split</code> (HAL::ChannelSplitOp)","text":"<p>Splits a collective communication channel</p> <p>Syntax:</p> <pre><code>operation ::= `hal.channel.split` `&lt;` $channel `:` type($channel) `&gt;`\n              `color` `(` $color `)`\n              `key` `(` $key `)`\n              `flags` `(` $flags `)`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Partitions the group associated with the given channel into disjoint subgroups for each unique value of color. Each new subgroup contains all participants of the same color and within each subgroup the key argument is used to define the rank order. When multiple participants in a group use the same key the tie will be broken using their rank in the parent group. A color of -1 indicates that the rank does not participate in any subgroup and will return a null channel.</p> <p>Interfaces: OpAsmOpInterface</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_8","title":"Attributes:","text":"Attribute MLIR Type Description <code>flags</code> ::mlir::IntegerAttr 32-bit signless integer attribute"},{"location":"reference/mlir-dialects/HAL/#operands_18","title":"Operands:","text":"Operand Description <code>channel</code> collective.channel <code>color</code> 32-bit signless integer <code>key</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HAL/#results_14","title":"Results:","text":"Result Description <code>result</code> collective.channel"},{"location":"reference/mlir-dialects/HAL/#command-buffer-ops","title":"Command buffer ops","text":"<p>Ops for <code>!hal.command_buffer</code> / <code>iree_hal_command_buffer_t</code>.</p>"},{"location":"reference/mlir-dialects/HAL/#halcommand_bufferbegin_debug_group-halcommandbufferbegindebuggroupop","title":"<code>hal.command_buffer.begin_debug_group</code> (HAL::CommandBufferBeginDebugGroupOp)","text":"<p>Pushes a command buffer debug group label</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.begin_debug_group` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              `label` `(` $label `)`\n              attr-dict-with-keyword\n</code></pre> <p>Pushes a new debug group with the given label. All commands between this and a mandatory matching call to <code>hal.command_buffer.end_debug_group</code> will be grouped together with the given label.</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_9","title":"Attributes:","text":"Attribute MLIR Type Description <code>label</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/HAL/#operands_19","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer"},{"location":"reference/mlir-dialects/HAL/#halcommand_buffercollective-halcommandbuffercollectiveop","title":"<code>hal.command_buffer.collective</code> (HAL::CommandBufferCollectiveOp)","text":"<p>Command buffer collective dispatch recording operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.collective` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              `channel` `(` $channel `:` type($channel) `)`\n              `op` `(` $op `)`\n              (`param` `(` $param^ `:` type($param) `)`)?\n              (`send` `(` $send_buffer^ `:` type($send_buffer) `)`\n              `` `[` $send_offset `,` $send_length `]`)?\n              (`recv` `(` $recv_buffer^ `:` type($recv_buffer) `)`\n              `` `[` $recv_offset `,` $recv_length `]`)?\n              `count` `(` $element_count `)`\n              attr-dict-with-keyword\n</code></pre> <p>Dispatches a collective operation defined by op using the given buffers.</p> <p>Traits: AttrSizedOperandSegments</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_10","title":"Attributes:","text":"Attribute MLIR Type Description <code>op</code> ::mlir::iree_compiler::IREE::HAL::CollectiveAttr collective operation and specification"},{"location":"reference/mlir-dialects/HAL/#operands_20","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer <code>channel</code> collective.channel <code>element_count</code> index <code>param</code> 32-bit signless integer <code>send_buffer</code> buffer <code>send_offset</code> index <code>send_length</code> index <code>recv_buffer</code> buffer <code>recv_offset</code> index <code>recv_length</code> index"},{"location":"reference/mlir-dialects/HAL/#halcommand_buffercopy_buffer-halcommandbuffercopybufferop","title":"<code>hal.command_buffer.copy_buffer</code> (HAL::CommandBufferCopyBufferOp)","text":"<p>Command buffer buffer copy recording operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.copy_buffer` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              `source` `(` $source_buffer `:` type($source_buffer) `)`\n              `` `[` $source_offset `]`\n              `target` `(` $target_buffer `:` type($target_buffer) `)`\n              `` `[` $target_offset `]`\n              `length` `(` $length `)`\n              attr-dict-with-keyword\n</code></pre> <p>Copies a range of one buffer to another.</p>"},{"location":"reference/mlir-dialects/HAL/#operands_21","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer <code>source_buffer</code> buffer <code>source_offset</code> index <code>target_buffer</code> buffer <code>target_offset</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/HAL/#halcommand_buffercreate-halcommandbuffercreateop","title":"<code>hal.command_buffer.create</code> (HAL::CommandBufferCreateOp)","text":"<p>Command buffer allocation operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.create` `device` `(` $device `:` type($device) `)`\n              `mode` `(` $modes `)`\n              `categories` `(` $command_categories `)`\n              (`bindings` `(` $binding_capacity^ `)`)?\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns a command buffer from the device pool ready to begin recording.</p> <p>Interfaces: OpAsmOpInterface</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_11","title":"Attributes:","text":"Attribute MLIR Type Description <code>modes</code> mlir::iree_compiler::IREE::HAL::CommandBufferModeBitfieldAttr valid CommandBufferMode <code>command_categories</code> mlir::iree_compiler::IREE::HAL::CommandCategoryBitfieldAttr valid CommandCategory"},{"location":"reference/mlir-dialects/HAL/#operands_22","title":"Operands:","text":"Operand Description <code>device</code> device <code>binding_capacity</code> index"},{"location":"reference/mlir-dialects/HAL/#results_15","title":"Results:","text":"Result Description <code>result</code> command_buffer"},{"location":"reference/mlir-dialects/HAL/#halcommand_bufferdevice-halcommandbufferdeviceop","title":"<code>hal.command_buffer.device</code> (HAL::CommandBufferDeviceOp)","text":"<p>Command buffer device query operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.device` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              `:` type($device)\n              attr-dict-with-keyword\n</code></pre> <p>Used during conversion to access the device used to create a command buffer.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#operands_23","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer"},{"location":"reference/mlir-dialects/HAL/#results_16","title":"Results:","text":"Result Description <code>device</code> device"},{"location":"reference/mlir-dialects/HAL/#halcommand_bufferdispatchindirect-halcommandbufferdispatchindirectop","title":"<code>hal.command_buffer.dispatch.indirect</code> (HAL::CommandBufferDispatchIndirectOp)","text":"<p>Command buffer indirect dispatch recording operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.dispatch.indirect` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              `target` `(` $executable `:` type($executable) `)`\n              `` `[` $entry_point `]`\n              `workgroups` `(` $workgroups_buffer `:` type($workgroups_buffer) `)`\n              `` `[` $workgroups_offset `]`\n              attr-dict-with-keyword\n</code></pre> <p>Dispatches an execution request with the dispatch parameters loaded from the given buffer.</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_12","title":"Attributes:","text":"Attribute MLIR Type Description <code>entry_point</code> ::mlir::IntegerAttr size_t"},{"location":"reference/mlir-dialects/HAL/#operands_24","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer <code>executable</code> executable <code>workgroups_buffer</code> buffer <code>workgroups_offset</code> index"},{"location":"reference/mlir-dialects/HAL/#halcommand_bufferdispatchindirectsymbol-halcommandbufferdispatchindirectsymbolop","title":"<code>hal.command_buffer.dispatch.indirect.symbol</code> (HAL::CommandBufferDispatchIndirectSymbolOp)","text":"<p>Command buffer indirect dispatch recording operation, using symbolref</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.dispatch.indirect.symbol` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              `target` `(` $entry_point `)`\n              `workgroups` `(` $workgroups_buffer `:` type($workgroups_buffer) `)`\n              `` `[` $workgroups_offset `]`\n              attr-dict-with-keyword\n</code></pre> <p>Dispatches an execution request with the dispatch parameters loaded from the given buffer, using using a nested symbol reference to the entry point.</p> <pre><code>hal.command_buffer.dispatch.indirect.symbol %cmd, @executable::@target::@entry,\n                                            workgroups = %buffer[%offset]\n</code></pre>"},{"location":"reference/mlir-dialects/HAL/#attributes_13","title":"Attributes:","text":"Attribute MLIR Type Description <code>entry_point</code> ::mlir::SymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/HAL/#operands_25","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer <code>workgroups_buffer</code> buffer <code>workgroups_offset</code> index"},{"location":"reference/mlir-dialects/HAL/#halcommand_bufferdispatch-halcommandbufferdispatchop","title":"<code>hal.command_buffer.dispatch</code> (HAL::CommandBufferDispatchOp)","text":"<p>Command buffer dispatch recording operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.dispatch` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              `target` `(` $executable `:` type($executable) `)`\n              `` `[` $entry_point `]`\n              `workgroups` `(` `[`\n              $workgroup_x `,`\n              $workgroup_y `,`\n              $workgroup_z\n              `]` `)`\n              attr-dict-with-keyword\n</code></pre> <p>Dispatches an execution request.</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_14","title":"Attributes:","text":"Attribute MLIR Type Description <code>entry_point</code> ::mlir::IntegerAttr size_t"},{"location":"reference/mlir-dialects/HAL/#operands_26","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer <code>executable</code> executable <code>workgroup_x</code> index <code>workgroup_y</code> index <code>workgroup_z</code> index"},{"location":"reference/mlir-dialects/HAL/#halcommand_bufferdispatchsymbol-halcommandbufferdispatchsymbolop","title":"<code>hal.command_buffer.dispatch.symbol</code> (HAL::CommandBufferDispatchSymbolOp)","text":"<p>Command buffer dispatch recording operation, using symbolref</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.dispatch.symbol` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              `target` `(` $entry_point `)`\n              `workgroups` `(` `[`\n              $workgroup_x `,`\n              $workgroup_y `,`\n              $workgroup_z\n              `]` `)`\n              attr-dict-with-keyword\n</code></pre> <p>Dispatches an execution request, using a nested symbol reference to the entry point.</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_15","title":"Attributes:","text":"Attribute MLIR Type Description <code>entry_point</code> ::mlir::SymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/HAL/#operands_27","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer <code>workgroup_x</code> index <code>workgroup_y</code> index <code>workgroup_z</code> index"},{"location":"reference/mlir-dialects/HAL/#halcommand_bufferend_debug_group-halcommandbufferenddebuggroupop","title":"<code>hal.command_buffer.end_debug_group</code> (HAL::CommandBufferEndDebugGroupOp)","text":"<p>Pops a command buffer debug group label</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.end_debug_group` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              attr-dict-with-keyword\n</code></pre> <p>Pops a debug group from the stack.</p>"},{"location":"reference/mlir-dialects/HAL/#operands_28","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer"},{"location":"reference/mlir-dialects/HAL/#halcommand_bufferexecution_barrier-halcommandbufferexecutionbarrierop","title":"<code>hal.command_buffer.execution_barrier</code> (HAL::CommandBufferExecutionBarrierOp)","text":"<p>Command buffer execution barrier recording operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.execution_barrier` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              `source` `(` $source_stage_mask `)`\n              `target` `(` $target_stage_mask `)`\n              `flags` `(` $flags `)`\n              attr-dict-with-keyword\n</code></pre> <p>Defines an execution dependency between all commands recorded before the barrier and all commands recorded after the barrier. Only the stages provided will be affected.</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_16","title":"Attributes:","text":"Attribute MLIR Type Description <code>source_stage_mask</code> mlir::iree_compiler::IREE::HAL::ExecutionStageBitfieldAttr valid ExecutionStage <code>target_stage_mask</code> mlir::iree_compiler::IREE::HAL::ExecutionStageBitfieldAttr valid ExecutionStage <code>flags</code> mlir::iree_compiler::IREE::HAL::ExecutionBarrierFlagBitfieldAttr valid ExecutionBarrierFlag"},{"location":"reference/mlir-dialects/HAL/#operands_29","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer"},{"location":"reference/mlir-dialects/HAL/#halcommand_bufferfill_buffer-halcommandbufferfillbufferop","title":"<code>hal.command_buffer.fill_buffer</code> (HAL::CommandBufferFillBufferOp)","text":"<p>Command buffer buffer fill recording operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.fill_buffer` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              `target` `(` $target_buffer `:` type($target_buffer) `)`\n              `` `[` $target_offset `,` $length `]`\n              `pattern` `(` $pattern `:` type($pattern) `)`\n              attr-dict-with-keyword\n</code></pre> <p>Fills the target buffer with the given repeating value.</p>"},{"location":"reference/mlir-dialects/HAL/#operands_30","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer <code>target_buffer</code> buffer <code>target_offset</code> index <code>length</code> index <code>pattern</code> 8-bit signless integer or 16-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/HAL/#halcommand_bufferfinalize-halcommandbufferfinalizeop","title":"<code>hal.command_buffer.finalize</code> (HAL::CommandBufferFinalizeOp)","text":"<p>Finalizes command buffer recording</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.finalize` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              attr-dict-with-keyword\n</code></pre> <p>Ends recording into the command buffer and prepares it for submission. No more commands may be recorded into the command buffer.</p>"},{"location":"reference/mlir-dialects/HAL/#operands_31","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer"},{"location":"reference/mlir-dialects/HAL/#halcommand_bufferpush_constants-halcommandbufferpushconstantsop","title":"<code>hal.command_buffer.push_constants</code> (HAL::CommandBufferPushConstantsOp)","text":"<p>Command buffer push constants operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.push_constants` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              `layout` `(` $pipeline_layout `:` type($pipeline_layout) `)`\n              `offset` `(` $offset `)`\n              `values` `(` `[` $values `]` `)`\n              `:` type($values)\n              attr-dict-with-keyword\n</code></pre> <p>Pushes an inline set of constants that can be accessed by subsequent dispatches using a compatible pipeline layout.</p> <p>Push constants are always 4-byte values and treated as opaque, meaning that they may be bit-casted floats, bit-packed booleans, etc.</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_17","title":"Attributes:","text":"Attribute MLIR Type Description <code>offset</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/HAL/#operands_32","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer <code>pipeline_layout</code> pipeline_layout <code>values</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HAL/#halcommand_bufferpush_descriptor_set-halcommandbufferpushdescriptorsetop","title":"<code>hal.command_buffer.push_descriptor_set</code> (HAL::CommandBufferPushDescriptorSetOp)","text":"<p>Command buffer descriptor set push binding operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.command_buffer.push_descriptor_set` `&lt;` $command_buffer `:` type($command_buffer) `&gt;`\n              `layout` `(` $pipeline_layout `:` type($pipeline_layout) `)`\n              `` `[` $set `]`\n              `bindings` `(` `[`\n              custom&lt;DescriptorSetBindings&gt;($binding_ordinals,\n              $binding_buffers,\n              type($binding_buffers),\n              $binding_offsets,\n              $binding_lengths)\n              `]` `)`\n              attr-dict-with-keyword\n</code></pre> <p>Pushes an inline-defined descriptor set to the command buffer. The provided buffers may either be HAL buffers or indirect references into the command buffer binding table.</p> <p>Traits: SameVariadicOperandSize</p>"},{"location":"reference/mlir-dialects/HAL/#operands_33","title":"Operands:","text":"Operand Description <code>command_buffer</code> command_buffer <code>pipeline_layout</code> pipeline_layout <code>set</code> index <code>binding_ordinals</code> index <code>binding_buffers</code> index or buffer <code>binding_offsets</code> index <code>binding_lengths</code> index"},{"location":"reference/mlir-dialects/HAL/#descriptor-set-layout-ops","title":"Descriptor set layout ops","text":"<p>Ops for <code>!hal.descriptor_set_layout</code> / <code>iree_hal_descriptor_set_layout_t</code>.</p>"},{"location":"reference/mlir-dialects/HAL/#haldescriptor_set_layoutcreate-haldescriptorsetlayoutcreateop","title":"<code>hal.descriptor_set_layout.create</code> (HAL::DescriptorSetLayoutCreateOp)","text":"<p>Creates a descriptor set layout</p> <p>Syntax:</p> <pre><code>operation ::= `hal.descriptor_set_layout.create` `device` `(` $device `:` type($device) `)`\n              `flags` `(` $flags `)`\n              `bindings` `(` $bindings `)`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Creates a descriptor set layout that defines the bindings used within a set. The same descriptor set layout may be shared with many different executable layouts and by doing so some runtime binding overhead when switching between executables that use the same set layouts can be reduced.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_18","title":"Attributes:","text":"Attribute MLIR Type Description <code>flags</code> ::mlir::iree_compiler::IREE::HAL::DescriptorSetLayoutFlagsAttr valid DescriptorSetLayout flags <code>bindings</code> ::mlir::ArrayAttr HAL descriptor set layout binding array attribute"},{"location":"reference/mlir-dialects/HAL/#operands_34","title":"Operands:","text":"Operand Description <code>device</code> device"},{"location":"reference/mlir-dialects/HAL/#results_17","title":"Results:","text":"Result Description <code>result</code> descriptor_set_layout"},{"location":"reference/mlir-dialects/HAL/#haldescriptor_set_layoutlookup-haldescriptorsetlayoutlookupop","title":"<code>hal.descriptor_set_layout.lookup</code> (HAL::DescriptorSetLayoutLookupOp)","text":"<p>Descriptor set layout cache lookup pseudo-op</p> <p>Syntax:</p> <pre><code>operation ::= `hal.descriptor_set_layout.lookup` `device` `(` $device `:` type($device) `)`\n              `flags` `(` $flags `)`\n              `bindings` `(` $bindings `)`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Used during conversion to provide a placeholder for a globally cached and possibly lazy-initialized descriptor set layout.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_19","title":"Attributes:","text":"Attribute MLIR Type Description <code>flags</code> ::mlir::iree_compiler::IREE::HAL::DescriptorSetLayoutFlagsAttr valid DescriptorSetLayout flags <code>bindings</code> ::mlir::ArrayAttr HAL descriptor set layout binding array attribute"},{"location":"reference/mlir-dialects/HAL/#operands_35","title":"Operands:","text":"Operand Description <code>device</code> device"},{"location":"reference/mlir-dialects/HAL/#results_18","title":"Results:","text":"Result Description <code>result</code> descriptor_set_layout"},{"location":"reference/mlir-dialects/HAL/#device-ops","title":"Device ops","text":"<p>Ops for <code>!hal.device</code> / <code>iree_hal_device_t</code>.</p>"},{"location":"reference/mlir-dialects/HAL/#haldeviceallocator-haldeviceallocatorop","title":"<code>hal.device.allocator</code> (HAL::DeviceAllocatorOp)","text":"<p>Device allocator accessor operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.device.allocator` `&lt;` $device `:` type($device) `&gt;` `:` type($result) attr-dict-with-keyword\n</code></pre> <p>Returns the allocator that can be used to allocate buffers compatible with the device.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#operands_36","title":"Operands:","text":"Operand Description <code>device</code> device"},{"location":"reference/mlir-dialects/HAL/#results_19","title":"Results:","text":"Result Description <code>result</code> allocator"},{"location":"reference/mlir-dialects/HAL/#haldevicequery-haldevicequeryop","title":"<code>hal.device.query</code> (HAL::DeviceQueryOp)","text":"<p>Returns a runtime configuration parameter from the device</p> <p>Syntax:</p> <pre><code>operation ::= `hal.device.query` `&lt;` $device `:` type($device) `&gt;`\n              `key` `(` $category `:` `` `:` $key `)`\n              `:` type($ok) `,` type($value)\n              (`=` $default_value^)?\n              attr-dict-with-keyword\n</code></pre> <p>Queries a device configuration parameter with the given key. Returns a status indicating whether the pair was recognized/available and if it was the value converted to the specified type. Queries must return the same value for the lifetime of the module though may vary from run to run.</p> <p>This is roughly equivalent to the <code>sysconf</code> linux syscall (https://man7.org/linux/man-pages/man3/sysconf.3.html) in that the exact set of keys available and their interpretation is target-dependent. If there is a HAL match attribute (<code>#hal.device.match.*</code>) or op (<code>hal.device.match.*</code>) prefer to use that in order to get compile-time propagation when the target is specified and elide the runtime query and get compile-time verification when a runtime query is required.</p> <p>Users of the op must check the <code>ok</code> result before using the value as what set of keys is available may change over time. If in doubt: don't use this. Each key used adds additional versioning and testing complexity as runtime code path changes will explode combinatorially and should be treated with as much care as a binary file format change. Keys should be prefixed with <code>ex.</code> when experimental indicating that they are not expected to be present forever; all non-experimental keys should be vetted.</p> <p>Well-known keys:</p> <ul> <li> <p>hal.executable.format :: {some format}   Returns 1 if the given format is supported by the device loader.</p> </li> <li> <p>hal.device :: concurrency   The maximum concurrently executable submissions, mapping roughly to the   queue count. The actual concurrency available may be less than this based   on dynamic runtime parameters such as power/thermal modes, quota limits,   or user choice.</p> </li> <li> <p>hal.dispatch :: concurrency   The maximum concurrently executable workgroups for a particular dispatch.   The actual concurrency available may be less depending on device state.</p> </li> </ul> <p>Traits: AlwaysSpeculatableImplTrait, HAL_DeviceQuery</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_20","title":"Attributes:","text":"Attribute MLIR Type Description <code>category</code> ::mlir::StringAttr string attribute <code>key</code> ::mlir::StringAttr string attribute <code>default_value</code> ::mlir::TypedAttr TypedAttr instance"},{"location":"reference/mlir-dialects/HAL/#operands_37","title":"Operands:","text":"Operand Description <code>device</code> device"},{"location":"reference/mlir-dialects/HAL/#results_20","title":"Results:","text":"Result Description <code>ok</code> 1-bit signless integer <code>value</code> any type"},{"location":"reference/mlir-dialects/HAL/#haldevicequeuealloca-haldevicequeueallocaop","title":"<code>hal.device.queue.alloca</code> (HAL::DeviceQueueAllocaOp)","text":"<p>Allocates a queue-ordered transient buffer</p> <p>Syntax:</p> <pre><code>operation ::= `hal.device.queue.alloca` `&lt;` $device `:` type($device) `&gt;`\n              `affinity` `(` $queue_affinity `)`\n              `wait` `(` $wait_fence `)`\n              `signal` `(` $signal_fence `)`\n              `pool` `(` $pool `)`\n              `type` `(` $memory_types `)`\n              `usage` `(` $buffer_usage `)`\n              `:` custom&lt;SizeAwareType&gt;(type($result), $result_size)\n              attr-dict-with-keyword\n</code></pre> <p>Returns a queue-ordered transient buffer that will be available for use when the signal fence is reached. The allocation will not be made until the wait fence has been reached.</p> <p>The size of the buffer returned may be larger than the requested size if the allocator has specific alignment requirements or minimum allocation sizes.</p> <p>The buffer handle will remain live so long as there are retainers but the contents are undefined before the allocation signal fence has been signaled and after the deallocation wait fence has been reached.</p> <p>Interfaces: OpAsmOpInterface, SizeAwareOpInterface</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_21","title":"Attributes:","text":"Attribute MLIR Type Description <code>memory_types</code> mlir::iree_compiler::IREE::HAL::MemoryTypeBitfieldAttr valid MemoryType <code>buffer_usage</code> mlir::iree_compiler::IREE::HAL::BufferUsageBitfieldAttr valid BufferUsage"},{"location":"reference/mlir-dialects/HAL/#operands_38","title":"Operands:","text":"Operand Description <code>device</code> device <code>queue_affinity</code> 64-bit signless integer <code>wait_fence</code> fence <code>signal_fence</code> fence <code>pool</code> 64-bit signless integer <code>result_size</code> index"},{"location":"reference/mlir-dialects/HAL/#results_21","title":"Results:","text":"Result Description <code>result</code> buffer"},{"location":"reference/mlir-dialects/HAL/#haldevicequeuedealloca-haldevicequeuedeallocaop","title":"<code>hal.device.queue.dealloca</code> (HAL::DeviceQueueDeallocaOp)","text":"<p>Deallocates a queue-ordered transient buffer</p> <p>Syntax:</p> <pre><code>operation ::= `hal.device.queue.dealloca` `&lt;` $device `:` type($device) `&gt;`\n              `affinity` `(` $queue_affinity `)`\n              `wait` `(` $wait_fence `)`\n              `signal` `(` $signal_fence `)`\n              `buffer` `(` $buffer `:` type($buffer) `)`\n              attr-dict-with-keyword\n</code></pre> <p>Deallocates a queue-ordered transient buffer. The deallocation will not be made until the wait fence has been reached and once the storage is available for reuse the signal fence will be signaled.</p> <p>After deallocation the contents of the buffer may still be accessible but will have undefined contents as other operations reuse the memory.</p>"},{"location":"reference/mlir-dialects/HAL/#operands_39","title":"Operands:","text":"Operand Description <code>device</code> device <code>queue_affinity</code> 64-bit signless integer <code>wait_fence</code> fence <code>signal_fence</code> fence <code>buffer</code> buffer"},{"location":"reference/mlir-dialects/HAL/#haldevicequeueexecute-haldevicequeueexecuteop","title":"<code>hal.device.queue.execute</code> (HAL::DeviceQueueExecuteOp)","text":"<p>Enqueues command buffer execution</p> <p>Syntax:</p> <pre><code>operation ::= `hal.device.queue.execute` `&lt;` $device `:` type($device) `&gt;`\n              `affinity` `(` $queue_affinity `)`\n              `wait` `(` $wait_fence `)`\n              `signal` `(` $signal_fence `)`\n              (`commands` `(` `[` $command_buffers^ `]` `)`)?\n              attr-dict-with-keyword\n</code></pre> <p>Executes one or more command buffers on a device queue. The command buffers are executed in order as if they were recorded as one. No commands will execute until the wait fence has been reached and the signal fence will be signaled when all commands have completed.</p>"},{"location":"reference/mlir-dialects/HAL/#operands_40","title":"Operands:","text":"Operand Description <code>device</code> device <code>queue_affinity</code> 64-bit signless integer <code>wait_fence</code> fence <code>signal_fence</code> fence <code>command_buffers</code> command_buffer"},{"location":"reference/mlir-dialects/HAL/#haldevicequeueflush-haldevicequeueflushop","title":"<code>hal.device.queue.flush</code> (HAL::DeviceQueueFlushOp)","text":"<p>Flushes locally-pending submissions to the queue</p> <p>Syntax:</p> <pre><code>operation ::= `hal.device.queue.flush` `&lt;` $device `:` type($device) `&gt;`\n              `affinity` `(` $queue_affinity `)`\n              attr-dict-with-keyword\n</code></pre> <p>Flushes any locally-pending submissions in the queue. When submitting many queue operations this can be used to eagerly flush earlier submissions while later ones are still being constructed. This may be a no-op.</p>"},{"location":"reference/mlir-dialects/HAL/#operands_41","title":"Operands:","text":"Operand Description <code>device</code> device <code>queue_affinity</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/HAL/#haldeviceswitch-haldeviceswitchop","title":"<code>hal.device.switch</code> (HAL::DeviceSwitchOp)","text":"<p>Runtime device switch pseudo op</p> <p>Switches between multiple regions based on the runtime device type. The provided regions are matched against the runtime backend of the given device and executed only when the device matches the conditions.</p> <p>Conditions can match on wildcards and be folded to enable conditions that have similar bodies to be folded. The patterns themselves are only matched once at startup and then the results are cached; the runtime overhead is equivalent to a normal switch statement. In cases where the compiler can statically identify the device type entire cases can be folded away.</p> <p>Supported conditions: * <code>#hal.match...</code>: execute the region if the expression matches.</p> <p>Supported match expressions: * <code>#hal.match.always</code>: always matches; useful for defaults. * <code>#hal.match.any&lt;[...]&gt;</code>: matches if any of the nested expressions match. * <code>#hal.match.all&lt;[...]&gt;</code>: matches only if all of the nested expressions   match. * <code>#hal.device.match.id&lt;\"pattern*-?-*\"&gt;</code>: matches against the device   identifier. The pattern is evaluated with standard file path wildcards   (<code>*</code> for zero or more characters and <code>?</code> for one character).</p> <p>If more than one condition is satisfied the first listed will be chosen. More specific conditions should be earlier in the set. If no condition is matched but there are return values the switch will abort at runtime. It's strongly recommend that all switches that return values end with a trailing <code>#hal.match.always</code> condition to handle the fallthrough case.</p> <p>Upon creation each condition region will have an empty entry block with the specified operands available as arguments. Each region must be setup to return the same types.</p> <pre><code>%c0 = arith.constant 0 : i32\n%c1 = arith.constant 1 : i32\n%c2 = arith.constant 2 : i32\n%device = ... : !hal.device\n%0 = hal.device.switch&lt;%device : !hal.device&gt; -&gt; i32\n  #hal.device.match.id&lt;\"vulkan-v1.?-*\"&gt; {\n    hal.return %c1 : i32\n  },\n  #hal.match.any&lt;[#hal.device.match.id&lt;\"vmvx\"&gt;, #hal.device.match.id&lt;\"vulkan-*\"&gt;]&gt; {\n    hal.return %c2 : i32\n  },\n  #hal.match.always {\n    hal.return %c0 : i32\n  }\n</code></pre> <p>Traits: NoRegionArguments, RecursiveMemoryEffects</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_22","title":"Attributes:","text":"Attribute MLIR Type Description <code>conditions</code> ::mlir::ArrayAttr array attribute"},{"location":"reference/mlir-dialects/HAL/#operands_42","title":"Operands:","text":"Operand Description <code>device</code> device"},{"location":"reference/mlir-dialects/HAL/#results_22","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"reference/mlir-dialects/HAL/#halreturn-halreturnop","title":"<code>hal.return</code> (HAL::ReturnOp)","text":"<p>Return from a hal.device.switch region</p> <p>Syntax:</p> <pre><code>operation ::= `hal.return` ($operands^ `:` type($operands))? attr-dict\n</code></pre> <p>Returns the given values from the region and back to the host code.</p> <p>Traits: Terminator</p>"},{"location":"reference/mlir-dialects/HAL/#operands_43","title":"Operands:","text":"Operand Description <code>operands</code> any type"},{"location":"reference/mlir-dialects/HAL/#executable-ops","title":"Executable ops","text":"<p>Ops for <code>!hal.executable</code> / <code>iree_hal_executable_t</code>.</p>"},{"location":"reference/mlir-dialects/HAL/#halexecutablebinary-halexecutablebinaryop","title":"<code>hal.executable.binary</code> (HAL::ExecutableBinaryOp)","text":"<p>Compiled executable binary data</p> <p>Syntax:</p> <pre><code>operation ::= `hal.executable.binary` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              $sym_name\n              attr-dict-with-keyword\n</code></pre> <p>A compiled executable binary with an optional nested module containing the IR prior to serialization (for debugging).</p> <p>Traits: HasParent <p>Interfaces: Symbol</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_23","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>format</code> ::mlir::StringAttr string attribute <code>data</code> ::mlir::DenseIntElementsAttr 8-bit signless integer elements attribute <code>mime_type</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/HAL/#halexecutablecalculate_workgroups-halexecutablecalculateworkgroupsop","title":"<code>hal.executable.calculate_workgroups</code> (HAL::ExecutableCalculateWorkgroupsOp)","text":"<p>Calculates workgroup count from workload for an exported function</p> <p>Syntax:</p> <pre><code>operation ::= `hal.executable.calculate_workgroups` `device` `(` $device `:` type($device) `)`\n              `target` `(` $entry_point `)`\n              (`workload` `(` `[` $workload^ `]` `)`)?\n              `:` type($workgroup_x) `,` type($workgroup_y) `,` type($workgroup_z)\n              attr-dict-with-keyword\n</code></pre> <p>Calculates the workgroup count (grid XYZ) based on the given workload using the workgroup count calculation region of the target <code>hal.executable.export</code> op.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_24","title":"Attributes:","text":"Attribute MLIR Type Description <code>entry_point</code> ::mlir::SymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/HAL/#operands_44","title":"Operands:","text":"Operand Description <code>device</code> device <code>workload</code> index"},{"location":"reference/mlir-dialects/HAL/#results_23","title":"Results:","text":"Result Description <code>workgroup_x</code> index <code>workgroup_y</code> index <code>workgroup_z</code> index"},{"location":"reference/mlir-dialects/HAL/#halexecutableconstantblock-halexecutableconstantblockop","title":"<code>hal.executable.constant.block</code> (HAL::ExecutableConstantBlockOp)","text":"<p>Executable constant block initializer</p> <p>Initializes one or more constants in the executable constant block by returning one value per identified constant. Each constant block is evaluated on the host prior to instantiating the executable for a given device and allows for the executable to be specialized based on device capabilities and limits.</p> <p>The keys specified are unique per variant and will be deduplicated across multiple constant blocks when present. They are only used during lowering and will not survive to runtime so they need only have descriptive enough names to avoid collisions and represent the semantics of the value.</p> <p>Constant values can be loaded in the device code with the <code>hal.executable.constant.load</code> op:</p> <pre><code>hal.executable.variant public @target {\n  hal.executable.constant.block(%device: !hal.device) -&gt; (i32, i32) as (\"foo\", \"bar\") {\n    %0 = hal.device.query&lt;%device&gt; key(\"some.device.prop\")...\n    %1 = hal.device.query&lt;%device&gt; key(\"another.device.prop\")...\n    hal.return %0, %1 : i32, i32\n  }\n  builtin.module {\n    func @dispatch0() {\n      %0 = hal.executable.constant.load \"foo\" : i32\n      %1 = hal.executable.constant.load \"bar\" : i32\n      return\n    }\n  }\n}\n</code></pre> <p>Each target backend will implement the constant initialization and access in a way compatible with its execution model. Examples: - CPU: read-only buffer initialized on load and passed to each dispatch - CUDA: read-only buffer initialized on load and passed to each dispatch - SPIR-V: specialization constants - Metal: function constants - WebGPU: pipeline-overridable constants</p> <p>Traits: HasParent, IsolatedFromAbove <p>Interfaces: CallableOpInterface, FunctionOpInterface, Symbol</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_25","title":"Attributes:","text":"Attribute MLIR Type Description <code>function_type</code> ::mlir::TypeAttr type attribute of function type <code>keys</code> ::mlir::ArrayAttr array attribute <code>arg_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes <code>res_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes"},{"location":"reference/mlir-dialects/HAL/#halexecutableconstantload-halexecutableconstantloadop","title":"<code>hal.executable.constant.load</code> (HAL::ExecutableConstantLoadOp)","text":"<p>Loads a constant value from the executable constant block</p> <p>Syntax:</p> <pre><code>operation ::= `hal.executable.constant.load` $key attr-dict `:` type($result)\n</code></pre> <p>Loads a scalar constant value from the static executable constant block. The value provided by a constant block with the given key will be loaded and bitcast (possibly with truncation or zero-extension) to the result type.</p> <p>Note that backends are allowed to implement their own mechanisms for referencing constant block values and this is provided only as a default for those not needing special behavior.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_26","title":"Attributes:","text":"Attribute MLIR Type Description <code>key</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/HAL/#results_24","title":"Results:","text":"Result Description <code>result</code> index or signless integer or floating-point or complex-type"},{"location":"reference/mlir-dialects/HAL/#halexecutablecreate-halexecutablecreateop","title":"<code>hal.executable.create</code> (HAL::ExecutableCreateOp)","text":"<p>Creates an executable</p> <p>Syntax:</p> <pre><code>operation ::= `hal.executable.create` `device` `(` $device `:` type($device) `)`\n              `target` `(` $executable_target `)`\n              `layouts` `(` `[` $layouts `]` `)`\n              (`constants` `(` `[` $constants^ `]` `)`)?\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Creates a target-dependent executable cached on the provided device. Entry points contained within the executable can be dispatched using the resulting executable handle.</p> <p>Depending on the driver creation may take a non-trivial amount of time (such as when JITing/etc). As the cache is internally synchronized callers can issue preparation requests from multiple threads - even for the same executables - and calls will block until preparation completes.</p> <p>Optional constants provide for specialization of the executable based on runtime-derived parameters.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_27","title":"Attributes:","text":"Attribute MLIR Type Description <code>executable_target</code> ::mlir::SymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/HAL/#operands_45","title":"Operands:","text":"Operand Description <code>device</code> device <code>layouts</code> pipeline_layout <code>constants</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HAL/#results_25","title":"Results:","text":"Result Description <code>result</code> executable"},{"location":"reference/mlir-dialects/HAL/#halexecutable_end-halexecutableendop","title":"<code>hal.executable_end</code> (HAL::ExecutableEndOp)","text":"<p>Terminator pseudo-op for the executable op</p> <p>Syntax:</p> <pre><code>operation ::= `hal.executable_end` attr-dict\n</code></pre> <p>Traits: HasParent, Terminator"},{"location":"reference/mlir-dialects/HAL/#halexecutableexport-halexecutableexportop","title":"<code>hal.executable.export</code> (HAL::ExecutableExportOp)","text":"<p>Executable entry point declaration</p> <p>An entry point exported by the executable with statically-available information describing the IO interface it uses and other dispatch metadata.</p> <p>The <code>calculate_workgroup_count</code> region represents the computation that returns the number of workgroups to use in the 3D grid dispatch. The arguments to the region represents the workload as captured by each dispatch. It returns the number of workgroups along x, y, and z.</p> <p>Traits: HasParent, IsolatedFromAbove <p>Interfaces: Symbol</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_28","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>ordinal</code> ::mlir::IntegerAttr size_t <code>layout</code> ::mlir::iree_compiler::IREE::HAL::PipelineLayoutAttr executable entry point layout specification <code>workgroup_size</code> ::mlir::ArrayAttr index array attribute <code>subgroup_size</code> ::mlir::IntegerAttr size_t <code>workgroup_local_memory</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/HAL/#halexecutablelookup-halexecutablelookupop","title":"<code>hal.executable.lookup</code> (HAL::ExecutableLookupOp)","text":"<p>Executable cache lookup pseudo-op</p> <p>Syntax:</p> <pre><code>operation ::= `hal.executable.lookup` `device` `(` $device `:` type($device) `)`\n              `executable` `(` $executable `)`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Used during conversion to provide a placeholder for a globally cached and possibly lazy-initialized executable.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_29","title":"Attributes:","text":"Attribute MLIR Type Description <code>executable</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute"},{"location":"reference/mlir-dialects/HAL/#operands_46","title":"Operands:","text":"Operand Description <code>device</code> device"},{"location":"reference/mlir-dialects/HAL/#results_26","title":"Results:","text":"Result Description <code>result</code> executable"},{"location":"reference/mlir-dialects/HAL/#halexecutable-halexecutableop","title":"<code>hal.executable</code> (HAL::ExecutableOp)","text":"<p>Target-specific executable module</p> <p>Syntax:</p> <pre><code>operation ::= `hal.executable` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              $sym_name\n              attr-dict-with-keyword\n              regions\n</code></pre> <p>An executable module representing a target-specific compiled kernel/shader/etc.</p> <p>Traits: IsolatedFromAbove, SingleBlockImplicitTerminator, SymbolTable <p>Interfaces: Symbol</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_30","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/HAL/#halexecutablesource_end-halexecutablesourceendop","title":"<code>hal.executable.source_end</code> (HAL::ExecutableSourceEndOp)","text":"<p>Terminator pseudo-op for the executable source op</p> <p>Syntax:</p> <pre><code>operation ::= `hal.executable.source_end` attr-dict\n</code></pre> <p>Traits: HasParent, Terminator"},{"location":"reference/mlir-dialects/HAL/#halexecutablesource-halexecutablesourceop","title":"<code>hal.executable.source</code> (HAL::ExecutableSourceOp)","text":"<p>Generic source contents of an executable op</p> <p>Syntax:</p> <pre><code>operation ::= `hal.executable.source` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              $sym_name\n              attr-dict-with-keyword\n              ``\n              regions\n</code></pre> <p>This is an unspecialized source representation of an executable module without an assigned target. This is useful for hand-authoring executables prior to device specification.</p> <p>Traits: IsolatedFromAbove, SingleBlockImplicitTerminator, SymbolTable <p>Interfaces: Symbol</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_31","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>objects</code> ::mlir::iree_compiler::IREE::HAL::ExecutableObjectsAttr target-specific object file references"},{"location":"reference/mlir-dialects/HAL/#halexecutablevariant_end-halexecutablevariantendop","title":"<code>hal.executable.variant_end</code> (HAL::ExecutableVariantEndOp)","text":"<p>Terminator pseudo-op for the executable variant op</p> <p>Syntax:</p> <pre><code>operation ::= `hal.executable.variant_end` attr-dict\n</code></pre> <p>Traits: HasParent, Terminator"},{"location":"reference/mlir-dialects/HAL/#halexecutablevariant-halexecutablevariantop","title":"<code>hal.executable.variant</code> (HAL::ExecutableVariantOp)","text":"<p>Target-specific variant of an executable op</p> <p>Syntax:</p> <pre><code>operation ::= `hal.executable.variant` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              $sym_name\n              `,` `target` `=` $target\n              (`,` `objects` `=` $objects^ )?\n              attr-dict-with-keyword\n              regions\n</code></pre> <p>The target IR for the executable. This can be preserved for debugging but is usually removed during transformation.</p> <p>Traits: HasParent, IsolatedFromAbove, SingleBlockImplicitTerminator, SymbolTable <p>Interfaces: Symbol</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_32","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>target</code> ::mlir::iree_compiler::IREE::HAL::ExecutableTargetAttr generic executable target specification <code>objects</code> ::mlir::ArrayAttr HAL executable object references"},{"location":"reference/mlir-dialects/HAL/#experimental-ops","title":"Experimental ops","text":"<p>Temporary hack ops expected to be removed in the future.</p>"},{"location":"reference/mlir-dialects/HAL/#halexshared_device-halexshareddeviceop","title":"<code>hal.ex.shared_device</code> (HAL::ExSharedDeviceOp)","text":"<p>Syntax:</p> <pre><code>operation ::= `hal.ex.shared_device` attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#results_27","title":"Results:","text":"Result Description <code>result</code> device"},{"location":"reference/mlir-dialects/HAL/#fence-ops","title":"Fence ops","text":"<p>Ops for <code>!hal.fence</code> / <code>iree_hal_fence_t</code>.</p>"},{"location":"reference/mlir-dialects/HAL/#halfenceawait-halfenceawaitop","title":"<code>hal.fence.await</code> (HAL::FenceAwaitOp)","text":"<p>Asynchronous fence wait operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.fence.await` `until` `(` `[` $fences `]` `)`\n              `timeout_millis` `(` $timeout_millis `)`\n              `:` type($status)\n              attr-dict-with-keyword\n</code></pre> <p>Yields the caller until all fences is reached. Returns the <code>status</code> of the fence after the wait, with a non-zero value indicating failure.</p> <p>Traits: Util_YieldPoint</p> <p>Interfaces: OpAsmOpInterface</p>"},{"location":"reference/mlir-dialects/HAL/#operands_47","title":"Operands:","text":"Operand Description <code>timeout_millis</code> 32-bit signless integer <code>fences</code> fence"},{"location":"reference/mlir-dialects/HAL/#results_28","title":"Results:","text":"Result Description <code>status</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HAL/#halfencecreate-halfencecreateop","title":"<code>hal.fence.create</code> (HAL::FenceCreateOp)","text":"<p>Creates an unsignaled fence</p> <p>Syntax:</p> <pre><code>operation ::= `hal.fence.create` `device` `(` $device `:` type($device) `)`\n              `flags` `(` $flags `)`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns a fence that defines a point in time. By default fences will remain unsignaled unless they are explicitly signaled with <code>hal.fence.signal</code> or asynchronously signaled by the device by passing them as an operand to queue submission ops.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_33","title":"Attributes:","text":"Attribute MLIR Type Description <code>flags</code> mlir::iree_compiler::IREE::HAL::FenceFlagBitfieldAttr valid FenceFlag"},{"location":"reference/mlir-dialects/HAL/#operands_48","title":"Operands:","text":"Operand Description <code>device</code> device"},{"location":"reference/mlir-dialects/HAL/#results_29","title":"Results:","text":"Result Description <code>result</code> fence"},{"location":"reference/mlir-dialects/HAL/#halfencefail-halfencefailop","title":"<code>hal.fence.fail</code> (HAL::FenceFailOp)","text":"<p>Fence failure operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.fence.fail` `&lt;` $fence `:` type($fence) `&gt;`\n              `status` `(` $status `)`\n              attr-dict-with-keyword\n</code></pre> <p>Signals the fence with a failure. The <code>status</code> will be returned from each timepoint semaphores <code>hal.semaphore.query</code> and <code>hal.semaphore.signal</code> for the lifetime of each semaphore.</p>"},{"location":"reference/mlir-dialects/HAL/#operands_49","title":"Operands:","text":"Operand Description <code>fence</code> fence <code>status</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HAL/#halfencejoin-halfencejoinop","title":"<code>hal.fence.join</code> (HAL::FenceJoinOp)","text":"<p>Creates a fence from the given timepoints</p> <p>Syntax:</p> <pre><code>operation ::= `hal.fence.join` `at` `(` `[` $fences `]` `)`\n              `-&gt;` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns a fence that joins the input fences as a wait-all operation.</p> <p>Interfaces: OpAsmOpInterface</p>"},{"location":"reference/mlir-dialects/HAL/#operands_50","title":"Operands:","text":"Operand Description <code>fences</code> fence"},{"location":"reference/mlir-dialects/HAL/#results_30","title":"Results:","text":"Result Description <code>result</code> fence"},{"location":"reference/mlir-dialects/HAL/#halfencequery-halfencequeryop","title":"<code>hal.fence.query</code> (HAL::FenceQueryOp)","text":"<p>Fence query operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.fence.query` `&lt;` $fence `:` type($fence) `&gt;`\n              `:` type($status)\n              attr-dict-with-keyword\n</code></pre> <p>Queries whether the fence has been reached and its status. Returns OK if the fence has been signaled successfully, DEFERRED if it is unsignaled, and otherwise an error indicating the failure.</p>"},{"location":"reference/mlir-dialects/HAL/#operands_51","title":"Operands:","text":"Operand Description <code>fence</code> fence"},{"location":"reference/mlir-dialects/HAL/#results_31","title":"Results:","text":"Result Description <code>status</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HAL/#halfencesignal-halfencesignalop","title":"<code>hal.fence.signal</code> (HAL::FenceSignalOp)","text":"<p>Fence signal operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal.fence.signal` `&lt;` $fence `:` type($fence) `&gt;`\n              attr-dict-with-keyword\n</code></pre> <p>Signals the fence to indicate that the timepoints contained have been reached. Waiting work may begin immediately.</p>"},{"location":"reference/mlir-dialects/HAL/#operands_52","title":"Operands:","text":"Operand Description <code>fence</code> fence"},{"location":"reference/mlir-dialects/HAL/#instrument-ops","title":"Instrument ops","text":"<p>Ops for <code>!hal.instrument.*</code>.</p>"},{"location":"reference/mlir-dialects/HAL/#halinstrumentmemoryload-halinstrumentmemoryloadop","title":"<code>hal.instrument.memory.load</code> (HAL::InstrumentMemoryLoadOp)","text":"<p>Emits a memory load instrumentation event</p> <p>Syntax:</p> <pre><code>operation ::= `hal.instrument.memory.load` `` `[` $buffer `:` type($buffer) `for` $workgroupKey `]`\n              $base `[` $indices `]` `,` $loadValue\n              attr-dict `:` type($base) `,` type($result)\n</code></pre> <p>Emits a workgroup-specific memory load event indicating that a number of bytes from the given resolved pointer have been loaded by the workgroup.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#operands_53","title":"Operands:","text":"Operand Description <code>buffer</code> memref of any type values <code>workgroupKey</code> index <code>loadValue</code> any type <code>base</code> memref of any type values <code>indices</code> index"},{"location":"reference/mlir-dialects/HAL/#results_32","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/HAL/#halinstrumentmemorystore-halinstrumentmemorystoreop","title":"<code>hal.instrument.memory.store</code> (HAL::InstrumentMemoryStoreOp)","text":"<p>Emits a memory store instrumentation event</p> <p>Syntax:</p> <pre><code>operation ::= `hal.instrument.memory.store` `` `[` $buffer `:` type($buffer) `for` $workgroupKey `]`\n              $base `[` $indices `]` `,` $storeValue\n              attr-dict `:` type($base) `,` type($result)\n</code></pre> <p>Emits a workgroup-specific memory store event indicating that a number of bytes have been stored to the given resolved pointer by the workgroup.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#operands_54","title":"Operands:","text":"Operand Description <code>buffer</code> memref of any type values <code>workgroupKey</code> index <code>storeValue</code> any type <code>base</code> memref of any type values <code>indices</code> index"},{"location":"reference/mlir-dialects/HAL/#results_33","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/HAL/#halinstrumentprint-halinstrumentprintop","title":"<code>hal.instrument.print</code> (HAL::InstrumentPrintOp)","text":"<p>Emits a human-readable printf-style string event</p> <p>Syntax:</p> <pre><code>operation ::= `hal.instrument.print` `` `[` $buffer `:` type($buffer) `for` $workgroupKey `]`\n              $format (`*` `(` $values^ `:` type($values) `)`)?\n              attr-dict\n</code></pre> <p>Formats a string using a limited subset of printf format specifiers and the provided values and then emits an <code>iree_instrument_dispatch_print_t</code> event. Final formatted string lengths may be limited to as much as 1024 characters and should be kept as small as possible to avoid easily exceeding the instrumentation storage buffers with redundant strings.</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_34","title":"Attributes:","text":"Attribute MLIR Type Description <code>format</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/HAL/#operands_55","title":"Operands:","text":"Operand Description <code>buffer</code> memref of any type values <code>workgroupKey</code> index <code>values</code> any type"},{"location":"reference/mlir-dialects/HAL/#halinstrumentvalue-halinstrumentvalueop","title":"<code>hal.instrument.value</code> (HAL::InstrumentValueOp)","text":"<p>Emits a scalar value instrumentation event</p> <p>Syntax:</p> <pre><code>operation ::= `hal.instrument.value` `` `[` $buffer `:` type($buffer) `for` $workgroupKey `]`\n              $ordinal `=` $operand attr-dict `:` type($operand)\n</code></pre> <p>Emits a workgroup-specific typed value with the given workgroup-relative ordinal.</p> <p>This op will be preserved even if the output is not used as it is only for debugging purposes.</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_35","title":"Attributes:","text":"Attribute MLIR Type Description <code>ordinal</code> ::mlir::IntegerAttr 8-bit integer attribute"},{"location":"reference/mlir-dialects/HAL/#operands_56","title":"Operands:","text":"Operand Description <code>buffer</code> memref of any type values <code>workgroupKey</code> index <code>operand</code> any type"},{"location":"reference/mlir-dialects/HAL/#results_34","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/HAL/#halinstrumentworkgroup-halinstrumentworkgroupop","title":"<code>hal.instrument.workgroup</code> (HAL::InstrumentWorkgroupOp)","text":"<p>Emits a dispatch workgroup instrumentation event</p> <p>Syntax:</p> <pre><code>operation ::= `hal.instrument.workgroup` `` `[` $buffer `:` type($buffer) `]`\n              `dispatch` `(` $dispatchId `)`\n              attr-dict `:` type($workgroupKey)\n</code></pre> <p>Emits an <code>iree_instrument_dispatch_workgroup_t</code> event into the instrumentation stream. The workgroup event identifies the unique dispatch, its workgroup count, and the ID of the emitting workgroup within the dispatch. Optionally targets that support querying the processor ID executing the workgroup can attach that information for tracking purposes.</p> <p>On targets such as CPUs where entire workgroups execute as atomic units only one workgroup event should be emitted. On targets such as GPUs where there may be multiple invocations executing as part of a single workgroup only the first invocation within the workgroup should emit the workgroup event (by checking if the LocalInvocationIndex or threadIdx == 0, etc).</p> <p>The resulting workgroup key is used by subsequent workgroup-specific instrumentation events.</p>"},{"location":"reference/mlir-dialects/HAL/#operands_57","title":"Operands:","text":"Operand Description <code>buffer</code> memref of any type values <code>dispatchId</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HAL/#results_35","title":"Results:","text":"Result Description <code>workgroupKey</code> index"},{"location":"reference/mlir-dialects/HAL/#interface-ops","title":"Interface ops","text":"<p>Ops for <code>!hal.interface.*</code>.</p>"},{"location":"reference/mlir-dialects/HAL/#halinterfacebindingsubspan-halinterfacebindingsubspanop","title":"<code>hal.interface.binding.subspan</code> (HAL::InterfaceBindingSubspanOp)","text":"<p>Returns an alias to a subspan of interface binding data</p> <p>Syntax:</p> <pre><code>operation ::= `hal.interface.binding.subspan` `set` `(` $set `)`\n              `binding` `(` $binding `)`\n              `type` `(` custom&lt;DescriptorType&gt;($descriptor_type) `)`\n              (`alignment` `(` $alignment^ `)`)?\n              (`offset` `(` $byte_offset^ `)`)?\n              (`flags` `(` $descriptor_flags^ `)`)?\n              attr-dict `:` type($result) (`{` $dynamic_dims^ `}`)?\n</code></pre> <p>Returns a subspan of an interface binding storage buffer in a generic type. The exact shape, type, and alignment of the returned type are defined by the result type (tensor, memref, etc).</p> <p>An optional alignment indicates the byte alignment of the base binding resource. Note that the byte offset is added to the base and the alignment will be the minimum of the two.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_36","title":"Attributes:","text":"Attribute MLIR Type Description <code>set</code> ::mlir::IntegerAttr index attribute <code>binding</code> ::mlir::IntegerAttr index attribute <code>descriptor_type</code> ::mlir::iree_compiler::IREE::HAL::DescriptorTypeAttr valid DescriptorType <code>alignment</code> ::mlir::IntegerAttr index attribute <code>descriptor_flags</code> ::mlir::iree_compiler::IREE::HAL::DescriptorFlagsAttr valid Descriptor flags"},{"location":"reference/mlir-dialects/HAL/#operands_58","title":"Operands:","text":"Operand Description <code>byte_offset</code> index <code>dynamic_dims</code> index"},{"location":"reference/mlir-dialects/HAL/#results_36","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/HAL/#halinterfaceconstantload-halinterfaceconstantloadop","title":"<code>hal.interface.constant.load</code> (HAL::InterfaceConstantLoadOp)","text":"<p>Loads a constant value from the interface constant block</p> <p>Syntax:</p> <pre><code>operation ::= `hal.interface.constant.load` `` `[` $index `]`\n              (`alignment` `(` $alignment^ `)`)?\n              (`values` `(` $values^ `)`)?\n              attr-dict `:` type($result)\n</code></pre> <p>Loads a scalar constant value from an executable IO push constant block. The value will be loaded from the given constant offset and will be bitcast (possibly with truncation or zero-extension) to the result type.</p> <p>An optional alignment indicates the byte alignment of potential values for the constant when it could be determined from analysis. If omitted the value may be anything and its interpretation is up to the usage. This is intended to provide pointer alignment-like semantics to constants that are used to index into binding resources.</p> <p>An optional set of values indicates all possible values that can be passed to the constant from all dispatch sites in the program. If omitted the value may be from an unanalyzable source (outside of the program, indirect, etc) and must be assumed to have any value.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_37","title":"Attributes:","text":"Attribute MLIR Type Description <code>index</code> ::mlir::IntegerAttr size_t <code>alignment</code> ::mlir::IntegerAttr index attribute <code>values</code> ::mlir::ArrayAttr array attribute"},{"location":"reference/mlir-dialects/HAL/#results_37","title":"Results:","text":"Result Description <code>result</code> index or signless integer or floating-point or complex-type"},{"location":"reference/mlir-dialects/HAL/#halinterfaceworkgroupcount-halinterfaceworkgroupcountop","title":"<code>hal.interface.workgroup.count</code> (HAL::InterfaceWorkgroupCountOp)","text":"<p>Returns the total workgroup count of the grid</p> <p>Syntax:</p> <pre><code>operation ::= `hal.interface.workgroup.count` `[` $dimension `]` attr-dict `:` type($result)\n</code></pre> <p>The total number of workgroups along each dimension in the dispatch grid. Matches what was passed to the <code>hal.command_buffer.dispatch</code> command (or what was indirectly specified).</p> <p>Corresponds to the <code>NumWorkgroups</code> SPIR-V built-in and the <code>gridDim</code> CUDA built-in variable.</p> <pre><code>%x = hal.interface.workgroup.count[0] : index\n%y = hal.interface.workgroup.count[1] : index\n%z = hal.interface.workgroup.count[2] : index\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_38","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/HAL/#results_38","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/HAL/#halinterfaceworkgroupid-halinterfaceworkgroupidop","title":"<code>hal.interface.workgroup.id</code> (HAL::InterfaceWorkgroupIDOp)","text":"<p>Returns the index of the current workgroup in the grid</p> <p>Syntax:</p> <pre><code>operation ::= `hal.interface.workgroup.id` `[` $dimension `]` attr-dict `:` type($result)\n</code></pre> <p>The global workgroup ID of the current tile in the range of <code>[0, hal.interface.workgroup.count)</code> along each XYZ dimension.</p> <p>Corresponds to the <code>WorkgroupId</code> SPIR-V built-in and the <code>blockIdx</code> CUDA built-in variable.</p> <pre><code>%x = hal.interface.workgroup.id[0] : index\n%y = hal.interface.workgroup.id[1] : index\n%z = hal.interface.workgroup.id[2] : index\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_39","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/HAL/#results_39","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/HAL/#halinterfaceworkgroupsize-halinterfaceworkgroupsizeop","title":"<code>hal.interface.workgroup.size</code> (HAL::InterfaceWorkgroupSizeOp)","text":"<p>Returns the size of each workgroup in invocations</p> <p>Syntax:</p> <pre><code>operation ::= `hal.interface.workgroup.size` `[` $dimension `]` attr-dict `:` type($result)\n</code></pre> <p>The number of local invocations within the current workgroup along each dimension. Depending on backend this may map to the SIMT thread count or inner loop nest parameters.</p> <p>Corresponds to the <code>WorkgroupSize</code> SPIR-V built-in and the <code>blockDim</code> CUDA built-in variable.</p> <pre><code>%x = hal.interface.workgroup.size[0] : index\n%y = hal.interface.workgroup.size[1] : index\n%z = hal.interface.workgroup.size[2] : index\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_40","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/HAL/#results_40","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/HAL/#pipeline-layout-ops","title":"Pipeline layout ops","text":"<p>Ops for <code>!hal.pipeline_layout</code> / <code>iree_hal_pipeline_layout_t</code>.</p>"},{"location":"reference/mlir-dialects/HAL/#halpipeline_layoutcreate-halpipelinelayoutcreateop","title":"<code>hal.pipeline_layout.create</code> (HAL::PipelineLayoutCreateOp)","text":"<p>Creates an pipeline layout</p> <p>Syntax:</p> <pre><code>operation ::= `hal.pipeline_layout.create` `device` `(` $device `:` type($device) `)`\n              `push_constants` `(` $push_constants `)`\n              `layouts` `(` `[` $set_layouts `]` `)`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Creates an pipeline layout from the given descriptor sets and push constant required size. Pipeline layouts can be shared across any executable that uses the same layout and push constant information. Sharing the layout between executables will reduce runtime binding overhead and it is often worth the cost to allow a small number of unused bindings in one executable such that it can share layouts with others that will be scheduled adjacent to it.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_41","title":"Attributes:","text":"Attribute MLIR Type Description <code>push_constants</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/HAL/#operands_59","title":"Operands:","text":"Operand Description <code>device</code> device <code>set_layouts</code> descriptor_set_layout"},{"location":"reference/mlir-dialects/HAL/#results_41","title":"Results:","text":"Result Description <code>result</code> pipeline_layout"},{"location":"reference/mlir-dialects/HAL/#halpipeline_layoutlookup-halpipelinelayoutlookupop","title":"<code>hal.pipeline_layout.lookup</code> (HAL::PipelineLayoutLookupOp)","text":"<p>Pipeline layout cache lookup pseudo-op</p> <p>Syntax:</p> <pre><code>operation ::= `hal.pipeline_layout.lookup` `device` `(` $device `:` type($device) `)`\n              `layout` `(` $layout `)`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Used during conversion to provide a placeholder for a globally cached and possibly lazy-initialized pipeline layout.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_42","title":"Attributes:","text":"Attribute MLIR Type Description <code>layout</code> ::mlir::iree_compiler::IREE::HAL::PipelineLayoutAttr executable entry point layout specification"},{"location":"reference/mlir-dialects/HAL/#operands_60","title":"Operands:","text":"Operand Description <code>device</code> device"},{"location":"reference/mlir-dialects/HAL/#results_42","title":"Results:","text":"Result Description <code>result</code> pipeline_layout"},{"location":"reference/mlir-dialects/HAL/#pseudo-ops","title":"Pseudo Ops","text":"<p>Pseudo ops for conversion support.</p>"},{"location":"reference/mlir-dialects/HAL/#haltensorbarrier-haltensorbarrierop","title":"<code>hal.tensor.barrier</code> (HAL::TensorBarrierOp)","text":"<p>Signals a fence when all tensors are available</p> <p>Syntax:</p> <pre><code>operation ::= `hal.tensor.barrier` `join` `` `(` $sources `:` type($sources) `)`\n              `=` `` `&gt;`\n              $signal_fence `:` type($signal_fence)\n              attr-dict-with-keyword\n</code></pre> <p>Defines a barrier that is used to indicate availability of an entire set of tensors by signaling a fence. The source tensors are returned for chaining.</p> <p>Interfaces: TiedOpInterface</p>"},{"location":"reference/mlir-dialects/HAL/#operands_61","title":"Operands:","text":"Operand Description <code>sources</code> tensor of any type values <code>signal_fence</code> fence"},{"location":"reference/mlir-dialects/HAL/#results_43","title":"Results:","text":"Result Description <code>results</code> tensor of any type values"},{"location":"reference/mlir-dialects/HAL/#haltensorexport-haltensorexportop","title":"<code>hal.tensor.export</code> (HAL::TensorExportOp)","text":"<p>Exports a tensor to a HAL buffer view</p> <p>Syntax:</p> <pre><code>operation ::= `hal.tensor.export` $source\n              ($name^)?\n              (`into` `(` $target_storage^ `:` type($target_storage) `)`)?\n              `:`\n              custom&lt;TypeAlias&gt;($source_encoding, type($source)) (`{` $source_dims^ `}`)?\n              `-&gt;`\n              type($target)\n              attr-dict\n</code></pre> <p>Defines an export of an SSA-form tensor to an external HAL buffer view.</p> <p>The provided <code>source_encoding</code>, if different from the <code>source</code> type, indicates that the ABI-facing type may differ from the internal representation. The types must be bitcastable (same storage size) and dynamically shaped values must have the same number of dynamic dimensions. This allows for casting between rank-0 and rank-N types, different element types, etc.</p> <p>An optional <code>target_storage</code> buffer can be provided to hold the exported result. The export will fail at runtime if the storage is null or if it has insufficient capacity to store the output. The storage must be device-visible and defined for transfer-target and dispatch usage.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), TiedOpInterface, Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_43","title":"Attributes:","text":"Attribute MLIR Type Description <code>source_encoding</code> ::mlir::TypeAttr any type attribute <code>name</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/HAL/#operands_62","title":"Operands:","text":"Operand Description <code>source</code> tensor of any type values <code>source_dims</code> index <code>target_storage</code> buffer or buffer_view"},{"location":"reference/mlir-dialects/HAL/#results_44","title":"Results:","text":"Result Description <code>target</code> buffer or buffer_view"},{"location":"reference/mlir-dialects/HAL/#haltensorimport-haltensorimportop","title":"<code>hal.tensor.import</code> (HAL::TensorImportOp)","text":"<p>Imports a tensor from a HAL buffer view</p> <p>Syntax:</p> <pre><code>operation ::= `hal.tensor.import` (`wait` `(` $wait_fence^ `)` `=` `` `&gt;`)?\n              $source\n              ($name^)?\n              `:` type($source) `-&gt;`\n              custom&lt;TypeAlias&gt;($target_encoding, type($target)) (`{` $target_dims^ `}`)?\n              attr-dict\n</code></pre> <p>Defines an import of an external HAL buffer view into a SSA-form tensor. An optional semaphore timepoint can be specified indicating when the buffer view is available for use. If no semaphore timepoint is provided it is assumed the buffer view is immediately available.</p> <p>The provided <code>target_encoding</code>, if different from the <code>target</code> type, indicates that the ABI-facing type may differ from the internal representation. The types must be bitcastable (same storage size) and dynamically shaped values must have the same number of dynamic dimensions. This allows for casting between rank-0 and rank-N types, different element types, etc.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), TiedOpInterface, Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HAL/#attributes_44","title":"Attributes:","text":"Attribute MLIR Type Description <code>target_encoding</code> ::mlir::TypeAttr any type attribute <code>name</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/HAL/#operands_63","title":"Operands:","text":"Operand Description <code>source</code> buffer or buffer_view <code>target_dims</code> index <code>wait_fence</code> fence"},{"location":"reference/mlir-dialects/HAL/#results_45","title":"Results:","text":"Result Description <code>target</code> tensor of any type values"},{"location":"reference/mlir-dialects/HAL/#attribute-definition","title":"Attribute definition","text":""},{"location":"reference/mlir-dialects/HAL/#affinityqueueattr","title":"AffinityQueueAttr","text":"<p>specifies a set of allowed queues for an operation</p> <p>WIP; see #10765. This may change in the future to either be a nested attribute on a larger affinity struct or be defined by an implementation of the affinity attr interface. For now this allows higher levels of the stack to specify queues such that the stream dialect can understand them and they can be lowered into the HAL dialect.</p> <p>Specifies that an annotated operation or scope is only allowed to execute on the set of queues (0-64) provided. Operations will not run on other queues.</p> <p>Example: <pre><code>// any queue\n#hal.affinity.queue&lt;*&gt;\n// queues 4 and 5\n#hal.affinity.queue&lt;[4, 5]&gt;\n</code></pre></p>"},{"location":"reference/mlir-dialects/HAL/#parameters","title":"Parameters:","text":"Parameter C++ type Description mask <code>int64_t</code>"},{"location":"reference/mlir-dialects/HAL/#collectiveattr","title":"CollectiveAttr","text":"<p>collective operation and specification</p> <p>Syntax:</p> <pre><code>#hal.collective&lt;\n  CollectiveKind,   # kind\n  std::optional&lt;CollectiveReductionOp&gt;,   # reduction\n  CollectiveElementType   # element_type\n&gt;\n</code></pre> <p>Specifies the collective operation to perform and any mode bits required.</p>"},{"location":"reference/mlir-dialects/HAL/#parameters_1","title":"Parameters:","text":"Parameter C++ type Description kind <code>CollectiveKind</code> reduction <code>std::optional&lt;CollectiveReductionOp&gt;</code> element_type <code>CollectiveElementType</code>"},{"location":"reference/mlir-dialects/HAL/#descriptorsetbindingattr","title":"DescriptorSetBindingAttr","text":"<p>descriptor set binding specification</p> <p>Syntax:</p> <pre><code>#hal.descriptor_set.binding&lt;\n  int64_t,   # ordinal\n  DescriptorType,   # type\n  std::optional&lt;DescriptorFlags&gt;   # flags\n&gt;\n</code></pre> <p>Specifies a single binding within a descriptor set layout.</p>"},{"location":"reference/mlir-dialects/HAL/#parameters_2","title":"Parameters:","text":"Parameter C++ type Description ordinal <code>int64_t</code> type <code>DescriptorType</code> flags <code>std::optional&lt;DescriptorFlags&gt;</code>"},{"location":"reference/mlir-dialects/HAL/#descriptorsetlayoutattr","title":"DescriptorSetLayoutAttr","text":"<p>descriptor set layout specification</p> <p>Syntax:</p> <pre><code>#hal.descriptor_set.layout&lt;\n  int64_t,   # ordinal\n  ::llvm::ArrayRef&lt;DescriptorSetBindingAttr&gt;   # bindings\n&gt;\n</code></pre> <p>Specifies the layout information of a single set of descriptors used within an pipeline layout. Multiple of these sets may be used by a single entry point to allow for bindings with similar update frequencies to be grouped.</p>"},{"location":"reference/mlir-dialects/HAL/#parameters_3","title":"Parameters:","text":"Parameter C++ type Description ordinal <code>int64_t</code> bindings <code>::llvm::ArrayRef&lt;DescriptorSetBindingAttr&gt;</code>"},{"location":"reference/mlir-dialects/HAL/#descriptortypeattr","title":"DescriptorTypeAttr","text":"<p>valid DescriptorType</p> <p>Syntax:</p> <pre><code>#hal.descriptor_type&lt;\n  ::mlir::iree_compiler::IREE::HAL::DescriptorType   # value\n&gt;\n</code></pre>"},{"location":"reference/mlir-dialects/HAL/#parameters_4","title":"Parameters:","text":"Parameter C++ type Description value <code>::mlir::iree_compiler::IREE::HAL::DescriptorType</code> an enum of type DescriptorType"},{"location":"reference/mlir-dialects/HAL/#devicematcharchitectureattr","title":"DeviceMatchArchitectureAttr","text":"<p>matches against a device architecture pattern</p> <p>Matches a device by its runtime architecture. The format of the architecture pattern is device-dependent.</p>"},{"location":"reference/mlir-dialects/HAL/#parameters_5","title":"Parameters:","text":"Parameter C++ type Description pattern <code>StringAttr</code>"},{"location":"reference/mlir-dialects/HAL/#devicematchexecutableformatattr","title":"DeviceMatchExecutableFormatAttr","text":"<p>matches when a device supports the given executable format</p> <p>Matches a device only if it claims to support the given executable format pattern. It's still possible that the executable cannot be loaded such as if it uses unavailable device features. This is used for queries such as \"can you load ELF libraries?\" to quickly get to a set of executables to attempt without needing to try dozens that definitely cannot be loaded.</p> <p>Note that different devices may share the same executable formats: for example a local synchronous CPU executor and a remote asynchronous CPU executor can both load ELF libraries. It's also possible for the same device to support multiple formats such as being able to load both platform-agnostic ELF libraries and platform-specific DLL/MachO/etc libraries.</p>"},{"location":"reference/mlir-dialects/HAL/#parameters_6","title":"Parameters:","text":"Parameter C++ type Description pattern <code>StringAttr</code>"},{"location":"reference/mlir-dialects/HAL/#devicematchfeatureattr","title":"DeviceMatchFeatureAttr","text":"<p>matches against a supported device feature pattern</p> <p>Matches a device that supports the given feature. The format of the feature pattern is device-dependent.</p>"},{"location":"reference/mlir-dialects/HAL/#parameters_7","title":"Parameters:","text":"Parameter C++ type Description pattern <code>StringAttr</code>"},{"location":"reference/mlir-dialects/HAL/#devicematchidattr","title":"DeviceMatchIDAttr","text":"<p>matches against a device ID pattern</p> <p>Matches a device by its canonical compiler/runtime ID.</p>"},{"location":"reference/mlir-dialects/HAL/#parameters_8","title":"Parameters:","text":"Parameter C++ type Description pattern <code>StringAttr</code>"},{"location":"reference/mlir-dialects/HAL/#devicetargetattr","title":"DeviceTargetAttr","text":"<p>generic device target specification</p> <p>Specifies the properties of a target runtime device. Target devices are specified with a canonical identifier matching those used by the runtime (such as <code>cpu</code>, <code>vulkan</code>, etc). Target devices may support several target executable formats specified with <code>#hal.executable.target</code>. An optional configuration dictionary allows for overriding backend defaults.</p> <p>Example: <pre><code>#hal.device.target&lt;\"llvm-cpu\", {\n  executable_targets = [\n    #hal.executable.target&lt;\"llvm-cpu\", \"embedded-elf-arm_32\"&gt;,\n    #hal.executable.target&lt;\"llvm-cpu\", \"embedded-elf-arm_64\"&gt;,\n  ]\n}&gt;\n</code></pre></p>"},{"location":"reference/mlir-dialects/HAL/#parameters_9","title":"Parameters:","text":"Parameter C++ type Description deviceID <code>StringAttr</code> configuration <code>DictionaryAttr</code>"},{"location":"reference/mlir-dialects/HAL/#executableobjectattr","title":"ExecutableObjectAttr","text":"<p>object file reference</p> <p>Defines an object file that can be linked into executables. Today this is only supported for external file references with paths the compiler can successfully resolve from its current working directory. Inlined data can optionally be provided to avoid the need for file system access and ensure the data source is attached to the IR as it makes its way through multiple compiler stages or reproducers.</p> <p>Future revisions may change this to an interface that allows both internal and external resources to define the object contents. Linking needs to be updated to support various object compositions and certain backends may require additional infrastructure support.</p> <p>In the long term the goal is to allow combinations of declared objects and generated code in order to give control of linking behavior to frontends. Instead of needing global command line flags to link in additional blobs the frontend can emit executables with the dependencies already defined per variant without needing to reach into the IREE compiler code.</p> <p>Example: <pre><code>#hal.executable.object&lt;{path = \"some/file.obj\"}&gt;\n#hal.executable.object&lt;{\n  path = \"some/embedded/file.obj\",\n  data = dense&lt;[...]&gt; : vector&lt;2048xi8&gt;\n}&gt;\n</code></pre></p>"},{"location":"reference/mlir-dialects/HAL/#parameters_10","title":"Parameters:","text":"Parameter C++ type Description path <code>StringAttr</code> data <code>DenseIntElementsAttr</code>"},{"location":"reference/mlir-dialects/HAL/#executableobjectsattr","title":"ExecutableObjectsAttr","text":"<p>target-specific object file references</p> <p>A dictionary mapping executable target specifications to a list of objects. This is used to allow layers of the stack that support multi-targeting to specify information used during lowering into each particular target.</p> <p>The key attributes are matched against each target variant based on the backend and format as well as any configuration data provided. When comparing the configuration only fields present in both the key and target variant will be checked and must match. This allows specification of generic sets (\"all x86_64 targets get these objects\") as well as specific ones (\"only x86_64 targets with vector_size = 64 get these objects\").</p> <p>Example: <pre><code>#hal.executable.objects&lt;{\n  #hal.executable.target&lt;\"llvm-cpu\", \"embedded-elf-arm_64\"&gt; = [\n    #hal.executable.object&lt;{path = \"some/file_arm_64.obj\"}&gt;\n  ],\n  #hal.executable.target&lt;\"llvm-cpu\", \"embedded-elf-x86_64\"&gt; = [\n    #hal.executable.object&lt;{path = \"some/file_x86_64.obj\"}&gt;\n  ]\n}&gt;\n</code></pre></p>"},{"location":"reference/mlir-dialects/HAL/#parameters_11","title":"Parameters:","text":"Parameter C++ type Description targets <code>ArrayAttr</code> targetObjects <code>ArrayAttr</code>"},{"location":"reference/mlir-dialects/HAL/#executabletargetattr","title":"ExecutableTargetAttr","text":"<p>generic executable target specification</p> <p>Specifies how to compile an executable for a specific target backend. A backend is used to translate and serialize the executable into the final form passed to the runtime. The format of the executable is a target-specific value indicating the required runtime support to load the deployed artifact. An optionally provided configuration dictionary overrides backend-specific defaults.</p> <p>Example: <pre><code>  // Produce a system-native ELF for x86-64 systems using the LLVM backend:\n  #hal.executable.target&lt;\"llvm-cpu\", \"system-elf-x86_64\", {\n    triple = \"x86_64-unknown-linux-elf\",\n    cpu = \"host\",\n    cpu_features = \"host\",\n    abi = \"lp32\",\n    ...\n  }&gt;\n</code></pre></p> <p>The same compilation backend may be used to translate executables for several different runtime devices. Likewise the same runtime device may use one of many different executable targets. Assume an N:M mapping between the two in all cases.</p>"},{"location":"reference/mlir-dialects/HAL/#parameters_12","title":"Parameters:","text":"Parameter C++ type Description backend <code>StringAttr</code> format <code>StringAttr</code> configuration <code>DictionaryAttr</code>"},{"location":"reference/mlir-dialects/HAL/#interfacebindingattr","title":"InterfaceBindingAttr","text":"<p>interface binding specification</p> <p>Syntax:</p> <pre><code>#hal.interface.binding&lt;\n  int64_t,   # set\n  int64_t   # binding\n&gt;\n</code></pre> <p>Specifies the descriptor set and binding ordinal of a particular layout binding.</p> <p>Example: <pre><code>#hal.interface.binding&lt;0, 1&gt;\n</code></pre></p>"},{"location":"reference/mlir-dialects/HAL/#parameters_13","title":"Parameters:","text":"Parameter C++ type Description set <code>int64_t</code> binding <code>int64_t</code>"},{"location":"reference/mlir-dialects/HAL/#matchallattr","title":"MatchAllAttr","text":"<p>matches if all subexpressions match</p> <p>Returns true only if all subexpressions return true (logical AND) or empty.</p>"},{"location":"reference/mlir-dialects/HAL/#parameters_14","title":"Parameters:","text":"Parameter C++ type Description conditions <code>ArrayAttr</code>"},{"location":"reference/mlir-dialects/HAL/#matchalwaysattr","title":"MatchAlwaysAttr","text":"<p>always matches</p> <p>Syntax: <code>#hal.match.always</code></p> <p>Returns true (constant true).</p>"},{"location":"reference/mlir-dialects/HAL/#matchanyattr","title":"MatchAnyAttr","text":"<p>matches if any subexpression matches</p> <p>Returns true if any subexpression matches (logical OR) and not empty.</p>"},{"location":"reference/mlir-dialects/HAL/#parameters_15","title":"Parameters:","text":"Parameter C++ type Description conditions <code>ArrayAttr</code>"},{"location":"reference/mlir-dialects/HAL/#pipelinelayoutattr","title":"PipelineLayoutAttr","text":"<p>executable entry point layout specification</p> <p>Syntax:</p> <pre><code>#hal.pipeline.layout&lt;\n  int64_t,   # pushConstants\n  ::llvm::ArrayRef&lt;DescriptorSetLayoutAttr&gt;   # setLayouts\n&gt;\n</code></pre> <p>Specifies the layout information used for interacting with executable functions. This allows host code to correctly map parameters to the lower-level target-specific argument passing behavior.</p>"},{"location":"reference/mlir-dialects/HAL/#parameters_16","title":"Parameters:","text":"Parameter C++ type Description pushConstants <code>int64_t</code> setLayouts <code>::llvm::ArrayRef&lt;DescriptorSetLayoutAttr&gt;</code>"},{"location":"reference/mlir-dialects/HAL/#type-constraint-definition","title":"Type constraint definition","text":""},{"location":"reference/mlir-dialects/HAL/#allocator","title":"allocator","text":"<p>Allocates buffers for a particular device memory space.</p>"},{"location":"reference/mlir-dialects/HAL/#buffer","title":"buffer","text":"<p>A memory buffer with a specific memory_type that is used to describe the capabilities and behavior of the backing memory of the buffer. Buffers may be any mix of host-accessible, host-coherent, or device-accessible for various usages. Depending on these memory types the buffers may be mapped for access on the host as memory though certain restrictions may be imposed.</p>"},{"location":"reference/mlir-dialects/HAL/#buffer_view","title":"buffer_view","text":"<p>A shaped and typed buffer reference. This just wraps an existing hal.buffer with its associated metadata to make it easier to pass across ABI boundaries. In most cases buffer views can be elided entirely by the compiler and they'll only be seen when calling external functions.</p>"},{"location":"reference/mlir-dialects/HAL/#collectivechannel","title":"collective.channel","text":"<p>Channel identifier used to allow for participation in multiple collective groups.</p>"},{"location":"reference/mlir-dialects/HAL/#command_buffer","title":"command_buffer","text":"<p>Asynchronous command buffer recording interface. Commands are recorded by the implementation for later submission to command queues.</p>"},{"location":"reference/mlir-dialects/HAL/#descriptor_set_layout","title":"descriptor_set_layout","text":"<p>Descriptor set layout.</p>"},{"location":"reference/mlir-dialects/HAL/#device","title":"device","text":"<p>Logical device instance.</p>"},{"location":"reference/mlir-dialects/HAL/#event","title":"event","text":"<p>Events are used for defining synchronization scopes within CommandBuffers. An event only exists within a single CommandBuffer and must not be used across CommandBuffers from the same device or others.</p>"},{"location":"reference/mlir-dialects/HAL/#executable","title":"executable","text":"<p>A prepared and ready-to-dispatch executable.</p>"},{"location":"reference/mlir-dialects/HAL/#fence","title":"fence","text":"<p>A set of semaphore timepoints defining a common point in time across multiple timelines.</p>"},{"location":"reference/mlir-dialects/HAL/#pipeline_layout","title":"pipeline_layout","text":"<p>An pipeline layout describing the descriptor sets and push constants used.</p>"},{"location":"reference/mlir-dialects/HALInline/","title":"HALInline","text":""},{"location":"reference/mlir-dialects/HALInline/#hal_inline-dialect","title":"'hal_inline' Dialect","text":"<p>IREE inline HAL interop runtime module dialect.</p> <p>Low-level dialect for limited in-process ABI interop with the full HAL. Only operates synchronously, single-threaded, and on host-local buffers. Use the full HAL for all other cases.</p> <p>This dialect can be used alongside the full HAL but is intended for use in standalone configurations or paired with the <code>hal_loader</code> dialect which also carries the same usage restrictions.</p> <p>See <code>hal_inline.imports.mlir</code> for the full list of exported functions.</p> <ul> <li>'hal_inline' Dialect<ul> <li>Operation definition<ul> <li>Buffer ops<ul> <li>hal_inline.buffer.allocate.initialized (HAL::Inline::BufferAllocateInitializedOp)</li> <li>hal_inline.buffer.allocate (HAL::Inline::BufferAllocateOp)</li> <li>hal_inline.buffer.length (HAL::Inline::BufferLengthOp)</li> <li>hal_inline.buffer.storage (HAL::Inline::BufferStorageOp)</li> <li>hal_inline.buffer.subspan (HAL::Inline::BufferSubspanOp)</li> <li>hal_inline.buffer.wrap (HAL::Inline::BufferWrapOp)</li> </ul> </li> <li>Buffer view ops<ul> <li>hal_inline.buffer_view.assert (HAL::Inline::BufferViewAssertOp)</li> <li>hal_inline.buffer_view.buffer (HAL::Inline::BufferViewBufferOp)</li> <li>hal_inline.buffer_view.create (HAL::Inline::BufferViewCreateOp)</li> <li>hal_inline.buffer_view.dim (HAL::Inline::BufferViewDimOp)</li> <li>hal_inline.buffer_view.element_type (HAL::Inline::BufferViewElementTypeOp)</li> <li>hal_inline.buffer_view.encoding_type (HAL::Inline::BufferViewEncodingTypeOp)</li> <li>hal_inline.buffer_view.rank (HAL::Inline::BufferViewRankOp)</li> <li>hal_inline.buffer_view.trace (HAL::Inline::BufferViewTraceOp)</li> </ul> </li> <li>Device ops<ul> <li>hal_inline.device.query (HAL::Inline::DeviceQueryOp)</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/mlir-dialects/HALInline/#operation-definition","title":"Operation definition","text":""},{"location":"reference/mlir-dialects/HALInline/#buffer-ops","title":"Buffer ops","text":"<p>Ops for <code>!hal.buffer</code> / <code>iree_hal_buffer_t</code>.</p>"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebufferallocateinitialized-halinlinebufferallocateinitializedop","title":"<code>hal_inline.buffer.allocate.initialized</code> (HAL::Inline::BufferAllocateInitializedOp)","text":"<p>Buffer allocation with cloning</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer.allocate.initialized` `source` `(` $source `:` type($source) `)` `` `[` $offset `,` $length `]`\n              `alignment` `(` $minimum_alignment `)`\n              `:` custom&lt;SizeAwareType&gt;(type($result), ref($length)) `in` type($storage)\n              attr-dict-with-keyword\n</code></pre> <p>Allocates a buffer with a copy of the provided contents.</p> <p>Interfaces: OpAsmOpInterface, SizeAwareOpInterface</p>"},{"location":"reference/mlir-dialects/HALInline/#operands","title":"Operands:","text":"Operand Description <code>minimum_alignment</code> index <code>source</code> a reference counted byte buffer <code>offset</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/HALInline/#results","title":"Results:","text":"Result Description <code>result</code> buffer <code>storage</code> a reference counted byte buffer"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebufferallocate-halinlinebufferallocateop","title":"<code>hal_inline.buffer.allocate</code> (HAL::Inline::BufferAllocateOp)","text":"<p>Empty buffer allocation operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer.allocate` `alignment` `(` $minimum_alignment `)`\n              `:` custom&lt;SizeAwareType&gt;(type($result), $allocation_size) `in` type($storage)\n              attr-dict-with-keyword\n</code></pre> <p>Allocates a buffer of the given size. The size of the buffer returned may be larger than the requested size if the allocator has specific alignment requirements or minimum allocation sizes.</p> <p>Interfaces: OpAsmOpInterface, SizeAwareOpInterface</p>"},{"location":"reference/mlir-dialects/HALInline/#operands_1","title":"Operands:","text":"Operand Description <code>minimum_alignment</code> index <code>allocation_size</code> index"},{"location":"reference/mlir-dialects/HALInline/#results_1","title":"Results:","text":"Result Description <code>result</code> buffer <code>storage</code> a reference counted byte buffer"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebufferlength-halinlinebufferlengthop","title":"<code>hal_inline.buffer.length</code> (HAL::Inline::BufferLengthOp)","text":"<p>Buffer byte length accessor</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer.length` `&lt;` $buffer `:` type($buffer) `&gt;`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the allocated size of a buffer in bytes. May be less than the underlying buffer allocation if this is a subspan or view into another buffer.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HALInline/#operands_2","title":"Operands:","text":"Operand Description <code>buffer</code> buffer"},{"location":"reference/mlir-dialects/HALInline/#results_2","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebufferstorage-halinlinebufferstorageop","title":"<code>hal_inline.buffer.storage</code> (HAL::Inline::BufferStorageOp)","text":"<p>Buffer backing storage accessor</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer.storage` `&lt;` $buffer `:` type($buffer) `&gt;`\n              `:` type($storage)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the host backing storage of the HAL buffer as a subspan limited to to the buffer's logical range (meaning that byte 0 of the returned buffer is byte 0 of the HAL buffer).</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HALInline/#operands_3","title":"Operands:","text":"Operand Description <code>buffer</code> buffer"},{"location":"reference/mlir-dialects/HALInline/#results_3","title":"Results:","text":"Result Description <code>storage</code> a reference counted byte buffer"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebuffersubspan-halinlinebuffersubspanop","title":"<code>hal_inline.buffer.subspan</code> (HAL::Inline::BufferSubspanOp)","text":"<p>Buffer subspan operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer.subspan` `&lt;` $source_buffer `:` type($source_buffer) `&gt;`\n              `` `[` $source_offset `,` $length `]`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns a reference to a subspan of the buffer.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, SizeAwareOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HALInline/#operands_4","title":"Operands:","text":"Operand Description <code>source_buffer</code> buffer <code>source_offset</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/HALInline/#results_4","title":"Results:","text":"Result Description <code>result</code> buffer"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebufferwrap-halinlinebufferwrapop","title":"<code>hal_inline.buffer.wrap</code> (HAL::Inline::BufferWrapOp)","text":"<p>Host buffer wrapping operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer.wrap` `source` `(` $source `:` type($source) `)` `` `[` $offset `,` $length `]`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Tries wrapping a !hal.buffer around host memory backed by the given byte buffer.</p> <p>Interfaces: OpAsmOpInterface, SizeAwareOpInterface</p>"},{"location":"reference/mlir-dialects/HALInline/#operands_5","title":"Operands:","text":"Operand Description <code>source</code> a reference counted byte buffer <code>offset</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/HALInline/#results_5","title":"Results:","text":"Result Description <code>result</code> buffer"},{"location":"reference/mlir-dialects/HALInline/#buffer-view-ops","title":"Buffer view ops","text":"<p>Ops for <code>!hal.buffer_view</code> / <code>iree_hal_buffer_view_t</code>.</p>"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebuffer_viewassert-halinlinebufferviewassertop","title":"<code>hal_inline.buffer_view.assert</code> (HAL::Inline::BufferViewAssertOp)","text":"<p>Buffer view contents assertion</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer_view.assert` `&lt;` $buffer_view `:` type($buffer_view) `&gt;`\n              `message` `(` $message `)`\n              `shape` `(` `[` $shape `]` `)`\n              `type` `(` $element_type `)`\n              `encoding` `(` $encoding_type `)`\n              attr-dict-with-keyword\n</code></pre> <p>Asserts that the buffer view contains a data compatible tensor with the given encoding. Program execution will abort as if <code>std.assert</code> had been used.</p>"},{"location":"reference/mlir-dialects/HALInline/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>message</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/HALInline/#operands_6","title":"Operands:","text":"Operand Description <code>buffer_view</code> buffer_view <code>element_type</code> 32-bit signless integer <code>encoding_type</code> 32-bit signless integer <code>shape</code> index"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebuffer_viewbuffer-halinlinebufferviewbufferop","title":"<code>hal_inline.buffer_view.buffer</code> (HAL::Inline::BufferViewBufferOp)","text":"<p>Buffer view buffer accessor</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer_view.buffer` `&lt;` $buffer_view `:` type($buffer_view) `&gt;`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the buffer backing this view's contents.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HALInline/#operands_7","title":"Operands:","text":"Operand Description <code>buffer_view</code> buffer_view"},{"location":"reference/mlir-dialects/HALInline/#results_6","title":"Results:","text":"Result Description <code>result</code> buffer"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebuffer_viewcreate-halinlinebufferviewcreateop","title":"<code>hal_inline.buffer_view.create</code> (HAL::Inline::BufferViewCreateOp)","text":"<p>Buffer view reference initializer</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer_view.create` `buffer` `(` $source_buffer `:` type($source_buffer) `)`\n              `` `[` $source_offset `,` $source_length `]`\n              `shape` `(` `[` $shape `]` `)`\n              `type` `(` $element_type `)`\n              `encoding` `(` $encoding_type `)`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Creates a reference to a buffer with a particular shape and element type. The buffer is not copied and both the original and view references must be synchronized. This makes it easier to associate commonly-carried metadata along with the contents.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HALInline/#operands_8","title":"Operands:","text":"Operand Description <code>source_buffer</code> buffer <code>source_offset</code> index <code>source_length</code> index <code>element_type</code> 32-bit signless integer <code>encoding_type</code> 32-bit signless integer <code>shape</code> index"},{"location":"reference/mlir-dialects/HALInline/#results_7","title":"Results:","text":"Result Description <code>result</code> buffer_view"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebuffer_viewdim-halinlinebufferviewdimop","title":"<code>hal_inline.buffer_view.dim</code> (HAL::Inline::BufferViewDimOp)","text":"<p>Buffer view dimension value query</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer_view.dim` `&lt;` $buffer_view `:` type($buffer_view) `&gt;`\n              `` `[` $index `]`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the value of the given dimension.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HALInline/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>index</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/HALInline/#operands_9","title":"Operands:","text":"Operand Description <code>buffer_view</code> buffer_view"},{"location":"reference/mlir-dialects/HALInline/#results_8","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebuffer_viewelement_type-halinlinebufferviewelementtypeop","title":"<code>hal_inline.buffer_view.element_type</code> (HAL::Inline::BufferViewElementTypeOp)","text":"<p>Buffer view element type query</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer_view.element_type` `&lt;` $buffer_view `:` type($buffer_view) `&gt;`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the element type of the buffer view.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HALInline/#operands_10","title":"Operands:","text":"Operand Description <code>buffer_view</code> buffer_view"},{"location":"reference/mlir-dialects/HALInline/#results_9","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebuffer_viewencoding_type-halinlinebufferviewencodingtypeop","title":"<code>hal_inline.buffer_view.encoding_type</code> (HAL::Inline::BufferViewEncodingTypeOp)","text":"<p>Buffer view encoding type query</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer_view.encoding_type` `&lt;` $buffer_view `:` type($buffer_view) `&gt;`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the encoding type of the buffer view.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HALInline/#operands_11","title":"Operands:","text":"Operand Description <code>buffer_view</code> buffer_view"},{"location":"reference/mlir-dialects/HALInline/#results_10","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebuffer_viewrank-halinlinebufferviewrankop","title":"<code>hal_inline.buffer_view.rank</code> (HAL::Inline::BufferViewRankOp)","text":"<p>Buffer view rank query</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer_view.rank` `&lt;` $buffer_view `:` type($buffer_view) `&gt;`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the rank of the buffer view.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HALInline/#operands_12","title":"Operands:","text":"Operand Description <code>buffer_view</code> buffer_view"},{"location":"reference/mlir-dialects/HALInline/#results_11","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinebuffer_viewtrace-halinlinebufferviewtraceop","title":"<code>hal_inline.buffer_view.trace</code> (HAL::Inline::BufferViewTraceOp)","text":"<p>Trace value(s) operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.buffer_view.trace` $operands `:` type($operands)\n              attr-dict-with-keyword\n</code></pre> <p>Traces out to a runtime trace sink (console, log file, etc) the given buffer views and titles them with the given key. The key is informational only and useful for titling/marking specific sets of buffers for easier searching.</p>"},{"location":"reference/mlir-dialects/HALInline/#attributes_2","title":"Attributes:","text":"Attribute MLIR Type Description <code>key</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/HALInline/#operands_13","title":"Operands:","text":"Operand Description <code>operands</code> buffer_view"},{"location":"reference/mlir-dialects/HALInline/#device-ops","title":"Device ops","text":"<p>Ops for <code>!hal.device</code> / <code>iree_hal_device_t</code>.</p>"},{"location":"reference/mlir-dialects/HALInline/#hal_inlinedevicequery-halinlinedevicequeryop","title":"<code>hal_inline.device.query</code> (HAL::Inline::DeviceQueryOp)","text":"<p>Returns a runtime configuration parameter from the device</p> <p>Syntax:</p> <pre><code>operation ::= `hal_inline.device.query` `key` `(` $category `:` `` `:` $key `)`\n              `:` type($ok) `,` type($value)\n              (`=` $default_value^)?\n              attr-dict-with-keyword\n</code></pre> <p>Queries a device configuration parameter with the given key. Returns a status indicating whether the pair was recognized/available and if it was the value converted to the specified type. Queries must return the same value for the lifetime of the module though may vary from run to run.</p> <p>This is roughly equivalent to the <code>sysconf</code> linux syscall (https://man7.org/linux/man-pages/man3/sysconf.3.html) in that the exact set of keys available and their interpretation is target-dependent. If there is a HAL match attribute (<code>#hal.device.match.*</code>) or op (<code>hal.device.match.*</code>) prefer to use that in order to get compile-time propagation when the target is specified and elide the runtime query and get compile-time verification when a runtime query is required.</p> <p>Users of the op must check the <code>ok</code> result before using the value as what set of keys is available may change over time. If in doubt: don't use this. Each key used adds additional versioning and testing complexity as runtime code path changes will explode combinatorially and should be treated with as much care as a binary file format change. Keys should be prefixed with <code>ex.</code> when experimental indicating that they are not expected to be present forever; all non-experimental keys should be vetted.</p> <p>Well-known keys: (none yet)</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HALInline/#attributes_3","title":"Attributes:","text":"Attribute MLIR Type Description <code>category</code> ::mlir::StringAttr string attribute <code>key</code> ::mlir::StringAttr string attribute <code>default_value</code> ::mlir::Attribute any attribute"},{"location":"reference/mlir-dialects/HALInline/#results_12","title":"Results:","text":"Result Description <code>ok</code> 1-bit signless integer <code>value</code> any type"},{"location":"reference/mlir-dialects/HALLoader/","title":"HALLoader","text":""},{"location":"reference/mlir-dialects/HALLoader/#hal_loader-dialect","title":"'hal_loader' Dialect","text":"<p>IREE HAL inline executable loader runtime module dialect.</p> <p>Low-level dialect for dynamically loading executables and dispatching work. Only operates synchronously, single-threaded, and on host-local buffers. Use the full HAL for all other cases.</p> <p>This dialect can be used alongside the full HAL but is intended for use in conjunction with the <code>hal_inline</code> dialect which also carries the same usage restrictions.</p> <p>See <code>hal_loader.imports.mlir</code> for the full list of exported functions.</p> <ul> <li>'hal_loader' Dialect<ul> <li>Operation definition<ul> <li>Executable ops<ul> <li>hal_loader.executable.dispatch (HAL::Loader::ExecutableDispatchOp)</li> <li>hal_loader.executable.dispatch.symbol (HAL::Loader::ExecutableDispatchSymbolOp)</li> <li>hal_loader.executable.load (HAL::Loader::ExecutableLoadOp)</li> <li>hal_loader.executable.lookup (HAL::Loader::ExecutableLookupOp)</li> <li>hal_loader.executable.query_support (HAL::Loader::ExecutableQuerySupportOp)</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/mlir-dialects/HALLoader/#operation-definition","title":"Operation definition","text":""},{"location":"reference/mlir-dialects/HALLoader/#executable-ops","title":"Executable ops","text":"<p>Ops for <code>!hal.executable</code> / <code>iree_hal_executable_t</code>.</p>"},{"location":"reference/mlir-dialects/HALLoader/#hal_loaderexecutabledispatch-halloaderexecutabledispatchop","title":"<code>hal_loader.executable.dispatch</code> (HAL::Loader::ExecutableDispatchOp)","text":"<p>Inline executable dispatch operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal_loader.executable.dispatch` `executable` `(` $executable `:` type($executable) `)`\n              `` `[` $entry_point `]`\n              `workgroups` `(` `[`\n              $workgroup_x `,`\n              $workgroup_y `,`\n              $workgroup_z\n              `]` `)`\n              (`constants` `(` `[` $push_constants^ `]` `)`)?\n              `bindings` `(` `[`\n              custom&lt;DispatchBindings&gt;($binding_buffers,\n              type($binding_buffers),\n              $binding_offsets,\n              $binding_lengths)\n              `]` `)`\n              attr-dict-with-keyword\n</code></pre> <p>Dispatches execution to an executable entry point with the given parameters.</p> <p>Traits: AttrSizedOperandSegments</p>"},{"location":"reference/mlir-dialects/HALLoader/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>entry_point</code> ::mlir::IntegerAttr size_t"},{"location":"reference/mlir-dialects/HALLoader/#operands","title":"Operands:","text":"Operand Description <code>executable</code> executable <code>workgroup_x</code> index <code>workgroup_y</code> index <code>workgroup_z</code> index <code>push_constants</code> 32-bit signless integer <code>binding_buffers</code> a reference counted byte buffer <code>binding_offsets</code> index <code>binding_lengths</code> index"},{"location":"reference/mlir-dialects/HALLoader/#hal_loaderexecutabledispatchsymbol-halloaderexecutabledispatchsymbolop","title":"<code>hal_loader.executable.dispatch.symbol</code> (HAL::Loader::ExecutableDispatchSymbolOp)","text":"<p>Inline executable dispatch operation</p> <p>Syntax:</p> <pre><code>operation ::= `hal_loader.executable.dispatch.symbol` `executable` `(` $executable `:` type($executable) `)`\n              `target` `(` $entry_point `)`\n              `workgroups` `(` `[`\n              $workgroup_x `,`\n              $workgroup_y `,`\n              $workgroup_z\n              `]` `)`\n              (`constants` `(` `[` $push_constants^ `]` `)`)?\n              `bindings` `(` `[`\n              custom&lt;DispatchBindings&gt;($binding_buffers,\n              type($binding_buffers),\n              $binding_offsets,\n              $binding_lengths)\n              `]` `)`\n              attr-dict-with-keyword\n</code></pre> <p>Dispatches execution to an executable entry point with the given parameters. The entry point is a symbolic reference to an exported entry point.</p> <p>Traits: AttrSizedOperandSegments</p> <p>Interfaces: SymbolUserOpInterface</p>"},{"location":"reference/mlir-dialects/HALLoader/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>entry_point</code> ::mlir::SymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/HALLoader/#operands_1","title":"Operands:","text":"Operand Description <code>executable</code> executable <code>workgroup_x</code> index <code>workgroup_y</code> index <code>workgroup_z</code> index <code>push_constants</code> 32-bit signless integer <code>binding_buffers</code> a reference counted byte buffer <code>binding_offsets</code> index <code>binding_lengths</code> index"},{"location":"reference/mlir-dialects/HALLoader/#hal_loaderexecutableload-halloaderexecutableloadop","title":"<code>hal_loader.executable.load</code> (HAL::Loader::ExecutableLoadOp)","text":"<p>Dynamically loads an executable</p> <p>Syntax:</p> <pre><code>operation ::= `hal_loader.executable.load` `format` `(` $format `)`\n              `data` `(` $data `)`\n              (`constants` `(` `[` $constants^ `]` `)`)?\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Creates, loads, and dynamically links an executable.</p> <p>Optional constants provide for specialization of the executable based on runtime-derived parameters.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HALLoader/#attributes_2","title":"Attributes:","text":"Attribute MLIR Type Description <code>format</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/HALLoader/#operands_2","title":"Operands:","text":"Operand Description <code>data</code> a reference counted byte buffer <code>constants</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/HALLoader/#results","title":"Results:","text":"Result Description <code>result</code> executable"},{"location":"reference/mlir-dialects/HALLoader/#hal_loaderexecutablelookup-halloaderexecutablelookupop","title":"<code>hal_loader.executable.lookup</code> (HAL::Loader::ExecutableLookupOp)","text":"<p>Executable cache lookup pseudo-op</p> <p>Syntax:</p> <pre><code>operation ::= `hal_loader.executable.lookup` `executable` `(` $executable `)`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Used during conversion to provide a placeholder for a globally cached and possibly lazy-initialized executable.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, SymbolUserOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HALLoader/#attributes_3","title":"Attributes:","text":"Attribute MLIR Type Description <code>executable</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute"},{"location":"reference/mlir-dialects/HALLoader/#results_1","title":"Results:","text":"Result Description <code>result</code> executable"},{"location":"reference/mlir-dialects/HALLoader/#hal_loaderexecutablequery_support-halloaderexecutablequerysupportop","title":"<code>hal_loader.executable.query_support</code> (HAL::Loader::ExecutableQuerySupportOp)","text":"<p>Queries whether an executable format is supported</p> <p>Syntax:</p> <pre><code>operation ::= `hal_loader.executable.query_support` `format` `(` $executable_format `)`\n              `:` type($supported)\n              attr-dict-with-keyword\n</code></pre> <p>Returns true if the given format is supported by the device loader. This does not guarantee that loading will succeed as the executable may require functionality that cannot be met my the hosting runtime environment.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/HALLoader/#attributes_4","title":"Attributes:","text":"Attribute MLIR Type Description <code>executable_format</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/HALLoader/#results_2","title":"Results:","text":"Result Description <code>supported</code> 1-bit signless integer"},{"location":"reference/mlir-dialects/IREEInput/","title":"IREEInput","text":""},{"location":"reference/mlir-dialects/IREEInput/#iree_input-dialect","title":"'iree_input' Dialect","text":"<p>Public ops/type/attributes legal for input to IREE's compiler.</p> <p>IREE's compiler allows as input a number of common dialects. This dialect contains structural and unique ops that do not exist elsewhere or that IREE has an interest in maintaining as a stable set.</p> <p>The contents of this dialect often mirror various constructs in IREE's internal implementation. The focus here is on simplicity and stability over time. Generally, this dialect does not use \"advanced\" features and should be broadly source compatible over a range of LLVM versions. There are of course, limits, and source-compatibility is not guaranteed, since LLVM/MLIR's API surface is itself unstable.</p> <ul> <li>'iree_input' Dialect<ul> <li>Operation definition<ul> <li>Buffer and buffer view ops<ul> <li>iree_input.buffer_view.create (Input::BufferViewCreateOp)</li> <li>iree_input.buffer_view.dim (Input::BufferViewDimOp)</li> <li>iree_input.buffer_view.rank (Input::BufferViewRankOp)</li> </ul> </li> <li>Compiler hint ops<ul> <li>iree_input.optimization_barrier (Input::OptimizationBarrierOp)</li> </ul> </li> <li>Dispatch ops<ul> <li>iree_input.dispatch (Input::DispatchOp)</li> </ul> </li> <li>Executable source ops<ul> <li>iree_input.executable.export (Input::ExecutableExportOp)</li> <li>iree_input.executable.source_end (Input::ExecutableSourceEndOp)</li> <li>iree_input.executable.source (Input::ExecutableSourceOp)</li> </ul> </li> <li>Global variable ops<ul> <li>iree_input.global.address (Input::GlobalAddressOp)</li> <li>iree_input.global.load.indirect (Input::GlobalLoadIndirectOp)</li> <li>iree_input.global.load (Input::GlobalLoadOp)</li> <li>iree_input.global (Input::GlobalOp)</li> <li>iree_input.global.store.indirect (Input::GlobalStoreIndirectOp)</li> <li>iree_input.global.store (Input::GlobalStoreOp)</li> </ul> </li> <li>Mutable list ops<ul> <li>iree_input.list.create (Input::ListCreateOp)</li> <li>iree_input.list.get (Input::ListGetOp)</li> <li>iree_input.list.resize (Input::ListResizeOp)</li> <li>iree_input.list.set (Input::ListSetOp)</li> <li>iree_input.list.size (Input::ListSizeOp)</li> </ul> </li> <li>Pseudo ops for conversion support<ul> <li>iree_input.tensor.export (Input::TensorExportOp)</li> <li>iree_input.tensor.import (Input::TensorImportOp)</li> </ul> </li> <li>Tensor ops<ul> <li>iree_input.tensor.clone (Input::TensorCloneOp)</li> <li>iree_input.tensor.load (Input::TensorLoadOp)</li> <li>iree_input.tensor.reshape (Input::TensorReshapeOp)</li> <li>iree_input.tensor.slice (Input::TensorSliceOp)</li> <li>iree_input.tensor.splat (Input::TensorSplatOp)</li> <li>iree_input.tensor.store (Input::TensorStoreOp)</li> <li>iree_input.tensor.trace (Input::TensorTraceOp)</li> <li>iree_input.tensor.update (Input::TensorUpdateOp)</li> </ul> </li> <li>Utility ops<ul> <li>iree_input.align (Input::AlignOp)</li> <li>iree_input.null (Input::NullOp)</li> </ul> </li> <li>Workgroup dispatch ops<ul> <li>iree_input.dispatch.workgroup.count (Input::DispatchWorkgroupCountOp)</li> <li>iree_input.dispatch.workgroup.id (Input::DispatchWorkgroupIDOp)</li> <li>iree_input.dispatch.workgroup.size (Input::DispatchWorkgroupSizeOp)</li> </ul> </li> </ul> </li> <li>Attribute definition<ul> <li>DescriptorSetBindingAttr</li> <li>DescriptorSetLayoutAttr</li> <li>DescriptorTypeAttr</li> <li>DeviceTargetAttr</li> <li>ExecutableObjectAttr</li> <li>ExecutableObjectsAttr</li> <li>ExecutableTargetAttr</li> <li>PipelineLayoutAttr</li> </ul> </li> <li>Type constraint definition<ul> <li>list</li> </ul> </li> <li>Type definition<ul> <li>BufferType</li> <li>BufferViewType</li> <li>ListType</li> <li>PtrType</li> <li>VariantType</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/mlir-dialects/IREEInput/#operation-definition","title":"Operation definition","text":""},{"location":"reference/mlir-dialects/IREEInput/#buffer-and-buffer-view-ops","title":"Buffer and buffer view ops","text":""},{"location":"reference/mlir-dialects/IREEInput/#iree_inputbuffer_viewcreate-inputbufferviewcreateop","title":"<code>iree_input.buffer_view.create</code> (Input::BufferViewCreateOp)","text":"<p>Buffer view reference initializer</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.buffer_view.create` `buffer` `(` $source_buffer `:` type($source_buffer) `)`\n              `` `[` $source_offset `,` $source_length `]`\n              `shape` `(` `[` $shape `]` `)`\n              `type` `(` $element_type `)`\n              `encoding` `(` $encoding_type `)`\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Creates a reference to a buffer with a particular shape and element type. The buffer is not copied and both the original and view references must be synchronized. This makes it easier to associate commonly-carried metadata along with the contents.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands","title":"Operands:","text":"Operand Description <code>source_buffer</code> Buffer is an untyped bag of bits with no shape or dtype <code>source_offset</code> index <code>source_length</code> index <code>element_type</code> 32-bit signless integer <code>encoding_type</code> 32-bit signless integer <code>shape</code> index"},{"location":"reference/mlir-dialects/IREEInput/#results","title":"Results:","text":"Result Description <code>result</code> View into a buffer, with runtime shape and element type"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputbuffer_viewdim-inputbufferviewdimop","title":"<code>iree_input.buffer_view.dim</code> (Input::BufferViewDimOp)","text":"<p>Buffer view dimension value query</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.buffer_view.dim` $buffer_view `,` $index attr-dict `:` type($result)\n</code></pre> <p>Returns the value of the given dimension.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>index</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/IREEInput/#operands_1","title":"Operands:","text":"Operand Description <code>buffer_view</code> View into a buffer, with runtime shape and element type"},{"location":"reference/mlir-dialects/IREEInput/#results_1","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputbuffer_viewrank-inputbufferviewrankop","title":"<code>iree_input.buffer_view.rank</code> (Input::BufferViewRankOp)","text":"<p>Buffer view rank query</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.buffer_view.rank` $buffer_view attr-dict `:` type($result)\n</code></pre> <p>Returns the rank of the buffer view.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_2","title":"Operands:","text":"Operand Description <code>buffer_view</code> View into a buffer, with runtime shape and element type"},{"location":"reference/mlir-dialects/IREEInput/#results_2","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/IREEInput/#compiler-hint-ops","title":"Compiler hint ops","text":""},{"location":"reference/mlir-dialects/IREEInput/#iree_inputoptimization_barrier-inputoptimizationbarrierop","title":"<code>iree_input.optimization_barrier</code> (Input::OptimizationBarrierOp)","text":"<p>Prevents compiler optimizations across a value.</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.optimization_barrier` attr-dict\n              ($operands^ `:` type($operands))?\n</code></pre> <p>Wraps any operands in an unoptimizable identity to prevent its results from being folded. It will be dropped during the final step in compilation and has no effect at runtime.</p> <p>Traits: SameOperandsAndResultType</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_3","title":"Operands:","text":"Operand Description <code>operands</code> any type"},{"location":"reference/mlir-dialects/IREEInput/#results_3","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"reference/mlir-dialects/IREEInput/#dispatch-ops","title":"Dispatch ops","text":""},{"location":"reference/mlir-dialects/IREEInput/#iree_inputdispatch-inputdispatchop","title":"<code>iree_input.dispatch</code> (Input::DispatchOp)","text":"<p>A dispatch of an executable across a grid</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.dispatch` $entry_point\n              (`[` $workload^ `]`)? ``\n              `(` $arguments `)` attr-dict `:`\n              custom&lt;ShapedFunctionType&gt;(ref($arguments),\n              type($arguments), $argument_dims,\n              type($results), $result_dims,\n              $tied_operands)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), SymbolUserOpInterface, TiedOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>entry_point</code> ::mlir::SymbolRefAttr symbol reference attribute <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute"},{"location":"reference/mlir-dialects/IREEInput/#operands_4","title":"Operands:","text":"Operand Description <code>workload</code> index <code>arguments</code> any type <code>argument_dims</code> index <code>result_dims</code> index"},{"location":"reference/mlir-dialects/IREEInput/#results_4","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"reference/mlir-dialects/IREEInput/#executable-source-ops","title":"Executable source ops","text":""},{"location":"reference/mlir-dialects/IREEInput/#iree_inputexecutableexport-inputexecutableexportop","title":"<code>iree_input.executable.export</code> (Input::ExecutableExportOp)","text":"<p>Executable entry point declaration</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.executable.export` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              $sym_name\n              `ordinal` `(` $ordinal `)`\n              `layout` `(` $layout `)`\n              attr-dict-with-keyword\n</code></pre> <p>Traits: HasParent, IsolatedFromAbove <p>Interfaces: Symbol</p>"},{"location":"reference/mlir-dialects/IREEInput/#attributes_2","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>ordinal</code> ::mlir::IntegerAttr size_t <code>layout</code> ::mlir::iree_compiler::IREE::Input::PipelineLayoutAttr executable entry point layout specification <code>workgroup_size</code> ::mlir::ArrayAttr index array attribute <code>subgroup_size</code> ::mlir::IntegerAttr size_t <code>workgroup_local_memory</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputexecutablesource_end-inputexecutablesourceendop","title":"<code>iree_input.executable.source_end</code> (Input::ExecutableSourceEndOp)","text":"<p>Terminator pseudo-op for the executable source op</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.executable.source_end` attr-dict\n</code></pre> <p>Traits: HasParent, Terminator"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputexecutablesource-inputexecutablesourceop","title":"<code>iree_input.executable.source</code> (Input::ExecutableSourceOp)","text":"<p>Generic source contents of an executable op</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.executable.source` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              $sym_name\n              attr-dict-with-keyword\n              ``\n              regions\n</code></pre> <p>Traits: IsolatedFromAbove, SingleBlockImplicitTerminator, SymbolTable <p>Interfaces: Symbol</p>"},{"location":"reference/mlir-dialects/IREEInput/#attributes_3","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>objects</code> ::mlir::iree_compiler::IREE::Input::ExecutableObjectsAttr target-specific object file references"},{"location":"reference/mlir-dialects/IREEInput/#global-variable-ops","title":"Global variable ops","text":""},{"location":"reference/mlir-dialects/IREEInput/#iree_inputglobaladdress-inputglobaladdressop","title":"<code>iree_input.global.address</code> (Input::GlobalAddressOp)","text":"<p>Returns an address reference to a global</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.global.address` $global attr-dict `:` type($result)\n</code></pre> <p>Returns the address of a global as a typed reference. Can be used with the global load and store indirect ops.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#attributes_4","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/IREEInput/#results_5","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values or index or signless integer or floating-point or complex-type"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputgloballoadindirect-inputgloballoadindirectop","title":"<code>iree_input.global.load.indirect</code> (Input::GlobalLoadIndirectOp)","text":"<p>Loads a value from a global variable</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.global.load.indirect` $global attr-dict `:` type($global) `-&gt;` type($result)\n</code></pre> <p>Returns a copy of the global value.</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_5","title":"Operands:","text":"Operand Description <code>global</code> ranked tensor of any type values or index or signless integer or floating-point or complex-type"},{"location":"reference/mlir-dialects/IREEInput/#results_6","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputglobalload-inputgloballoadop","title":"<code>iree_input.global.load</code> (Input::GlobalLoadOp)","text":"<p>Loads a value from a global variable</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.global.load` $global attr-dict `:` type($result)\n</code></pre> <p>Returns a copy of the global value.</p> <p>Interfaces: SymbolUserOpInterface</p>"},{"location":"reference/mlir-dialects/IREEInput/#attributes_5","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/IREEInput/#results_7","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputglobal-inputglobalop","title":"<code>iree_input.global</code> (Input::GlobalOp)","text":"<p>Stateful global variable declaration</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.global` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              (`mutable` $is_mutable^)?\n              $sym_name\n              attr-dict\n              (`initializer` `(` $initializer^ `)`)?\n              custom&lt;TypeOrAttr&gt;($type, $initial_value)\n</code></pre> <p>Declares a global variable that maintains its value across invocations. The value is tied to the execution context of the module and different contexts will have different global storage.</p> <p>Interfaces: Symbol</p>"},{"location":"reference/mlir-dialects/IREEInput/#attributes_6","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>type</code> ::mlir::TypeAttr any type attribute <code>is_mutable</code> ::mlir::UnitAttr unit attribute <code>initializer</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute <code>initial_value</code> ::mlir::TypedAttr TypedAttr instance"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputglobalstoreindirect-inputglobalstoreindirectop","title":"<code>iree_input.global.store.indirect</code> (Input::GlobalStoreIndirectOp)","text":"<p>Stores a value into a global variable</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.global.store.indirect` $value `,` $global attr-dict `:` type($value) `-&gt;` type($global)\n</code></pre> <p>Stores a copy of the value into a global.</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_6","title":"Operands:","text":"Operand Description <code>value</code> any type <code>global</code> ranked tensor of any type values or index or signless integer or floating-point or complex-type"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputglobalstore-inputglobalstoreop","title":"<code>iree_input.global.store</code> (Input::GlobalStoreOp)","text":"<p>Stores a value into a global variable</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.global.store` $value `,` $global attr-dict `:` type($value)\n</code></pre> <p>Stores a copy of the value into a global.</p> <p>Interfaces: SymbolUserOpInterface</p>"},{"location":"reference/mlir-dialects/IREEInput/#attributes_7","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/IREEInput/#operands_7","title":"Operands:","text":"Operand Description <code>value</code> any type"},{"location":"reference/mlir-dialects/IREEInput/#mutable-list-ops","title":"Mutable list ops","text":""},{"location":"reference/mlir-dialects/IREEInput/#iree_inputlistcreate-inputlistcreateop","title":"<code>iree_input.list.create</code> (Input::ListCreateOp)","text":"<p>Creates a new empty list</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.list.create` ($initial_capacity^)? attr-dict `:` type($result)\n</code></pre> <p>Creates a new empty list with an optional initial capacity.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, MemoryEffectOpInterface (MemoryEffectOpInterface), NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}, MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_8","title":"Operands:","text":"Operand Description <code>initial_capacity</code> index"},{"location":"reference/mlir-dialects/IREEInput/#results_8","title":"Results:","text":"Result Description <code>result</code> list"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputlistget-inputlistgetop","title":"<code>iree_input.list.get</code> (Input::ListGetOp)","text":"<p>Element accessor</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.list.get` $list `[` $index `]` attr-dict `:` type($list) `-&gt;` type($result)\n</code></pre> <p>Returns the value of the element at the given index. Note that the value may be null if the element is null or the type does not match.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_9","title":"Operands:","text":"Operand Description <code>list</code> list <code>index</code> index"},{"location":"reference/mlir-dialects/IREEInput/#results_9","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputlistresize-inputlistresizeop","title":"<code>iree_input.list.resize</code> (Input::ListResizeOp)","text":"<p>Resizes the list to a new count in elements</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.list.resize` operands attr-dict `:` type($list)\n</code></pre> <p>Resizes the list to contain <code>new_size</code> elements. This will either truncate the list if the existing size is greater than <code>new_size</code> or extend the list with the default list value of the element type.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_10","title":"Operands:","text":"Operand Description <code>list</code> list <code>new_size</code> index"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputlistset-inputlistsetop","title":"<code>iree_input.list.set</code> (Input::ListSetOp)","text":"<p>Element mutator</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.list.set` $list `[` $index `]` `,` $value attr-dict `:` type($list) `,` type($value)\n</code></pre> <p>Sets the element at the given index to the new value.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_11","title":"Operands:","text":"Operand Description <code>list</code> list <code>index</code> index <code>value</code> any type"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputlistsize-inputlistsizeop","title":"<code>iree_input.list.size</code> (Input::ListSizeOp)","text":"<p>The size of the list in elements</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.list.size` operands attr-dict `:` type($list)\n</code></pre> <p>Returns the current size of the list in elements.</p> <p>Interfaces: InferTypeOpInterface, MemoryEffectOpInterface (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_12","title":"Operands:","text":"Operand Description <code>list</code> list"},{"location":"reference/mlir-dialects/IREEInput/#results_10","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/IREEInput/#pseudo-ops-for-conversion-support","title":"Pseudo ops for conversion support","text":""},{"location":"reference/mlir-dialects/IREEInput/#iree_inputtensorexport-inputtensorexportop","title":"<code>iree_input.tensor.export</code> (Input::TensorExportOp)","text":"<p>Exports a tensor to a Buffer(View), capturing dynamic dims</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.tensor.export` $source `:` type($source) (`{` $source_dims^ `}`)? `-&gt;` type($target)\n              attr-dict-with-keyword\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_13","title":"Operands:","text":"Operand Description <code>source</code> ranked tensor of any type values <code>source_dims</code> index"},{"location":"reference/mlir-dialects/IREEInput/#results_11","title":"Results:","text":"Result Description <code>target</code> Buffer is an untyped bag of bits with no shape or dtype or View into a buffer, with runtime shape and element type"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputtensorimport-inputtensorimportop","title":"<code>iree_input.tensor.import</code> (Input::TensorImportOp)","text":"<p>Imports a Buffer(View) to a tensor, providing dynamic dims</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.tensor.import` $source `:` type($source) `-&gt;` type($target) (`{` $target_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_14","title":"Operands:","text":"Operand Description <code>source</code> Buffer is an untyped bag of bits with no shape or dtype or View into a buffer, with runtime shape and element type <code>target_dims</code> index"},{"location":"reference/mlir-dialects/IREEInput/#results_12","title":"Results:","text":"Result Description <code>target</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREEInput/#tensor-ops","title":"Tensor ops","text":""},{"location":"reference/mlir-dialects/IREEInput/#iree_inputtensorclone-inputtensorcloneop","title":"<code>iree_input.tensor.clone</code> (Input::TensorCloneOp)","text":"<p>Performs a full tensor clone operation</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.tensor.clone` $operand `:` type($result) (`{` $operand_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Clones the input tensor into an identical output tensor.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_15","title":"Operands:","text":"Operand Description <code>operand</code> ranked tensor of any type values <code>operand_dims</code> index"},{"location":"reference/mlir-dialects/IREEInput/#results_13","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputtensorload-inputtensorloadop","title":"<code>iree_input.tensor.load</code> (Input::TensorLoadOp)","text":"<p>Loads a value from a tensor element</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.tensor.load` $source (`[` $indices^ `]`)? `:`\n              type($source) (`{` $source_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Returns the element at the given location from within the tensor.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_16","title":"Operands:","text":"Operand Description <code>source</code> ranked tensor of any type values <code>source_dims</code> index <code>indices</code> index"},{"location":"reference/mlir-dialects/IREEInput/#results_14","title":"Results:","text":"Result Description <code>result</code> index or signless integer or floating-point or complex-type or vector of any type values"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputtensorreshape-inputtensorreshapeop","title":"<code>iree_input.tensor.reshape</code> (Input::TensorReshapeOp)","text":"<p>Reshapes a tensor</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.tensor.reshape` $source `:`\n              type($source) (`{` $source_dims^ `}`)? `-&gt;`\n              type($result) (`{` $result_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Reshapes a tensor to a new shape without modifying the contents.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_17","title":"Operands:","text":"Operand Description <code>source</code> ranked tensor of any type values <code>source_dims</code> index <code>result_dims</code> index"},{"location":"reference/mlir-dialects/IREEInput/#results_15","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputtensorslice-inputtensorsliceop","title":"<code>iree_input.tensor.slice</code> (Input::TensorSliceOp)","text":"<p>Slices out a subregion of a tensor</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.tensor.slice` $source `[` $start_indices `for` $lengths `]` `:`\n              type($source) (`{` $source_dims^ `}`)? `-&gt;`\n              type($result) (`{` $result_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Clones a subregion of a tensor.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_18","title":"Operands:","text":"Operand Description <code>source</code> ranked tensor of any type values <code>source_dims</code> index <code>start_indices</code> index <code>lengths</code> index <code>result_dims</code> index"},{"location":"reference/mlir-dialects/IREEInput/#results_16","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputtensorsplat-inputtensorsplatop","title":"<code>iree_input.tensor.splat</code> (Input::TensorSplatOp)","text":"<p>Splats a value into a shaped tensor</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.tensor.splat` $value `:` type($result) (`{` $result_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Returns a tensor initialized to the given primitive value.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_19","title":"Operands:","text":"Operand Description <code>value</code> index or signless integer or floating-point or complex-type <code>result_dims</code> index"},{"location":"reference/mlir-dialects/IREEInput/#results_17","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputtensorstore-inputtensorstoreop","title":"<code>iree_input.tensor.store</code> (Input::TensorStoreOp)","text":"<p>Stores a value into a tensor element</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.tensor.store` $value `,` $target (`[` $indices^ `]`)? `:`\n              type($target) (`{` $target_dims^ `}`)?\n              attr-dict-with-keyword\n</code></pre> <p>Returns a tensor with the element at the given index set to the given value.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_20","title":"Operands:","text":"Operand Description <code>value</code> index or signless integer or floating-point or complex-type or vector of any type values <code>target</code> ranked tensor of any type values <code>target_dims</code> index <code>indices</code> index"},{"location":"reference/mlir-dialects/IREEInput/#results_18","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputtensortrace-inputtensortraceop","title":"<code>iree_input.tensor.trace</code> (Input::TensorTraceOp)","text":"<p>Trace value(s) operation</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.tensor.trace` $key attr-dict ($operands^ `:` type($operands))?\n</code></pre> <p>Traces out to a runtime trace sink (console, log file, etc) the given tensors and titles them with the given key. The key is informational only and useful for titling/marking specific sets of tensors for easier searching.</p>"},{"location":"reference/mlir-dialects/IREEInput/#attributes_8","title":"Attributes:","text":"Attribute MLIR Type Description <code>key</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/IREEInput/#operands_21","title":"Operands:","text":"Operand Description <code>operands</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputtensorupdate-inputtensorupdateop","title":"<code>iree_input.tensor.update</code> (Input::TensorUpdateOp)","text":"<p>Updates a tensor with the contents of another tensor</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.tensor.update` $update `,` $target `[` $start_indices `]` `:`\n              type($update) (`{` $update_dims^ `}`)? `-&gt;`\n              custom&lt;ShapedTiedResult&gt;(type($result), $target_dims)\n              attr-dict-with-keyword\n</code></pre> <p>Updates the target tensor with the contents of the update tensor at the given offset indices.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), TiedOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_22","title":"Operands:","text":"Operand Description <code>target</code> ranked tensor of any type values <code>target_dims</code> index <code>start_indices</code> index <code>update</code> ranked tensor of any type values <code>update_dims</code> index"},{"location":"reference/mlir-dialects/IREEInput/#results_19","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREEInput/#utility-ops","title":"Utility ops","text":""},{"location":"reference/mlir-dialects/IREEInput/#iree_inputalign-inputalignop","title":"<code>iree_input.align</code> (Input::AlignOp)","text":"<p>Aligns up to a power-of-two alignment if required</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.align` $value `,` $alignment attr-dict `:` type($result)\n</code></pre> <p>Aligns |value| up to the given power-of-two |alignment| if required.</p> <p>Traits: AlwaysSpeculatableImplTrait, SameOperandsAndResultType</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#operands_23","title":"Operands:","text":"Operand Description <code>value</code> signless-integer-like <code>alignment</code> signless-integer-like"},{"location":"reference/mlir-dialects/IREEInput/#results_20","title":"Results:","text":"Result Description <code>result</code> signless-integer-like"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputnull-inputnullop","title":"<code>iree_input.null</code> (Input::NullOp)","text":"<p>A null value</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.null` attr-dict `:` type($result)\n</code></pre> <p>Initializes reference and variant types with a null value.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#results_21","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/IREEInput/#workgroup-dispatch-ops","title":"Workgroup dispatch ops","text":""},{"location":"reference/mlir-dialects/IREEInput/#iree_inputdispatchworkgroupcount-inputdispatchworkgroupcountop","title":"<code>iree_input.dispatch.workgroup.count</code> (Input::DispatchWorkgroupCountOp)","text":"<p>Returns the total workgroup count of the grid</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.dispatch.workgroup.count` `[` $dimension `]` attr-dict `:` type($result)\n</code></pre> <p>The total number of workgroups along each dimension in the dispatch grid.</p> <p>Corresponds to the <code>NumWorkgroups</code> SPIR-V built-in and the <code>gridDim</code> CUDA built-in variable, only in the iree dialect the number of dimensions is not restricted to 3 (XYZ).</p> <pre><code>%x = iree_input.dispatch.workgroup.count[0] : index\n%y = iree_input.dispatch.workgroup.count[1] : index\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#attributes_9","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/IREEInput/#results_22","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputdispatchworkgroupid-inputdispatchworkgroupidop","title":"<code>iree_input.dispatch.workgroup.id</code> (Input::DispatchWorkgroupIDOp)","text":"<p>Returns the index of the current workgroup in the grid</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.dispatch.workgroup.id` `[` $dimension `]` attr-dict `:` type($result)\n</code></pre> <p>The global workgroup ID of the current workgroup in the range of <code>[0, iree_input.dispatch.workgroup.count)</code> along each dimension.</p> <p>Corresponds to the <code>WorkgroupId</code> SPIR-V built-in and the <code>blockIdx</code> CUDA built-in variable, only in the iree dialect the number of dimensions is not restricted to 3 (XYZ).</p> <pre><code>%x = iree_input.dispatch.workgroup.id[0] : index\n%y = iree_input.dispatch.workgroup.id[1] : index\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#attributes_10","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/IREEInput/#results_23","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/IREEInput/#iree_inputdispatchworkgroupsize-inputdispatchworkgroupsizeop","title":"<code>iree_input.dispatch.workgroup.size</code> (Input::DispatchWorkgroupSizeOp)","text":"<p>Returns the size of each workgroup in invocations</p> <p>Syntax:</p> <pre><code>operation ::= `iree_input.dispatch.workgroup.size` `[` $dimension `]` attr-dict `:` type($result)\n</code></pre> <p>The number of local invocations within the current workgroup along each dimension. Depending on backend this may map to the SIMT thread count or inner loop nest parameters.</p> <p>Workgroup sizes are not determined at the iree dialect level as they are dependent on the target backend determined when lowering into the HAL. It's still possible to use the symbolic workgroup size inside of dispatch executables as a placeholder for the resolved value once in the HAL.</p> <p>Corresponds to the <code>WorkgroupSize</code> SPIR-V built-in and the <code>blockDim</code> CUDA built-in variable, only in the iree dialect the number of dimensions is not restricted to 3 (XYZ).</p> <pre><code>%x = iree_input.dispatch.workgroup.size[0] : index\n%y = iree_input.dispatch.workgroup.size[1] : index\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREEInput/#attributes_11","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/IREEInput/#results_24","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/IREEInput/#attribute-definition","title":"Attribute definition","text":""},{"location":"reference/mlir-dialects/IREEInput/#descriptorsetbindingattr","title":"DescriptorSetBindingAttr","text":"<p>descriptor set binding specification</p> <p>Syntax:</p> <pre><code>#iree_input.descriptor_set.binding&lt;\n  int64_t,   # ordinal\n  DescriptorType,   # type\n  std::optional&lt;DescriptorFlags&gt;   # flags\n&gt;\n</code></pre>"},{"location":"reference/mlir-dialects/IREEInput/#parameters","title":"Parameters:","text":"Parameter C++ type Description ordinal <code>int64_t</code> type <code>DescriptorType</code> flags <code>std::optional&lt;DescriptorFlags&gt;</code>"},{"location":"reference/mlir-dialects/IREEInput/#descriptorsetlayoutattr","title":"DescriptorSetLayoutAttr","text":"<p>descriptor set layout specification</p> <p>Syntax:</p> <pre><code>#iree_input.descriptor_set.layout&lt;\n  int64_t,   # ordinal\n  ::llvm::ArrayRef&lt;DescriptorSetBindingAttr&gt;   # bindings\n&gt;\n</code></pre>"},{"location":"reference/mlir-dialects/IREEInput/#parameters_1","title":"Parameters:","text":"Parameter C++ type Description ordinal <code>int64_t</code> bindings <code>::llvm::ArrayRef&lt;DescriptorSetBindingAttr&gt;</code>"},{"location":"reference/mlir-dialects/IREEInput/#descriptortypeattr","title":"DescriptorTypeAttr","text":"<p>valid DescriptorType</p> <p>Syntax:</p> <pre><code>#iree_input.descriptor_type&lt;\n  ::mlir::iree_compiler::IREE::Input::DescriptorType   # value\n&gt;\n</code></pre>"},{"location":"reference/mlir-dialects/IREEInput/#parameters_2","title":"Parameters:","text":"Parameter C++ type Description value <code>::mlir::iree_compiler::IREE::Input::DescriptorType</code> an enum of type DescriptorType"},{"location":"reference/mlir-dialects/IREEInput/#devicetargetattr","title":"DeviceTargetAttr","text":"<p>generic device target specification</p>"},{"location":"reference/mlir-dialects/IREEInput/#parameters_3","title":"Parameters:","text":"Parameter C++ type Description deviceID <code>StringAttr</code> configuration <code>DictionaryAttr</code>"},{"location":"reference/mlir-dialects/IREEInput/#executableobjectattr","title":"ExecutableObjectAttr","text":"<p>executable object reference</p>"},{"location":"reference/mlir-dialects/IREEInput/#parameters_4","title":"Parameters:","text":"Parameter C++ type Description path <code>StringAttr</code> data <code>DenseIntElementsAttr</code>"},{"location":"reference/mlir-dialects/IREEInput/#executableobjectsattr","title":"ExecutableObjectsAttr","text":"<p>target-specific object file references</p>"},{"location":"reference/mlir-dialects/IREEInput/#parameters_5","title":"Parameters:","text":"Parameter C++ type Description targets <code>ArrayAttr</code> targetObjects <code>ArrayAttr</code>"},{"location":"reference/mlir-dialects/IREEInput/#executabletargetattr","title":"ExecutableTargetAttr","text":"<p>generic executable target specification</p>"},{"location":"reference/mlir-dialects/IREEInput/#parameters_6","title":"Parameters:","text":"Parameter C++ type Description backend <code>StringAttr</code> format <code>StringAttr</code> configuration <code>DictionaryAttr</code>"},{"location":"reference/mlir-dialects/IREEInput/#pipelinelayoutattr","title":"PipelineLayoutAttr","text":"<p>executable entry point layout specification</p> <p>Syntax:</p> <pre><code>#iree_input.pipeline.layout&lt;\n  int64_t,   # pushConstants\n  ::llvm::ArrayRef&lt;DescriptorSetLayoutAttr&gt;   # setLayouts\n&gt;\n</code></pre>"},{"location":"reference/mlir-dialects/IREEInput/#parameters_7","title":"Parameters:","text":"Parameter C++ type Description pushConstants <code>int64_t</code> setLayouts <code>::llvm::ArrayRef&lt;DescriptorSetLayoutAttr&gt;</code>"},{"location":"reference/mlir-dialects/IREEInput/#type-constraint-definition","title":"Type constraint definition","text":""},{"location":"reference/mlir-dialects/IREEInput/#list","title":"list","text":"<p>A mutable, resizable list of some type.</p>"},{"location":"reference/mlir-dialects/IREEInput/#type-definition","title":"Type definition","text":""},{"location":"reference/mlir-dialects/IREEInput/#buffertype","title":"BufferType","text":"<p>Buffer is an untyped bag of bits with no shape or dtype</p> <p>Syntax: <code>!iree_input.buffer</code></p> <p>Buffers represent an untyped bag of bits that can be reinterpreted depending on a use case using <code>buffer_view</code> operation. Buffers can be used for packing multiple tensors into the same underlying storage. It is left to higher level code to decide how exactly tensors layed out in the buffer.</p>"},{"location":"reference/mlir-dialects/IREEInput/#bufferviewtype","title":"BufferViewType","text":"<p>View into a buffer, with runtime shape and element type</p> <p>Syntax: <code>!iree_input.buffer_view</code></p> <p>BufferViews represent views onto backing IREE runtime Buffer objects, adding runtime shape and element type parameters to the backing buffer. BufferViews are typically accepted and returned at boundaries with external code.</p> <p>In the runtime and lower level compiler, BufferView's are fully modeled; however, as boundary types, not all features are exposed publicly. Since within compiled tensor programs, it is typical to operate in terms of fully typed tensors, the primary mechanism for getting or using a BufferView at the high level is by casting to/from a tensor. It is left to higher level code to ensure that aliasing rules are enforced at such boundaries.</p>"},{"location":"reference/mlir-dialects/IREEInput/#listtype","title":"ListType","text":"<p>A one dimensional list of runtime values</p> <p>Represents a list of arbitrary type. Primitive types can be expected to be efficiently stored in an unboxed form. Reference types and variants are permitted.</p> <p>Lists can either be homogenous, with a fixed element type, or heterogenous by parameterizing them with a VariantType.</p>"},{"location":"reference/mlir-dialects/IREEInput/#parameters_8","title":"Parameters:","text":"Parameter C++ type Description elementType <code>::mlir::Type</code> A type suitable as an element type of a container"},{"location":"reference/mlir-dialects/IREEInput/#ptrtype","title":"PtrType","text":"<p>Pointer to a concrete type</p>"},{"location":"reference/mlir-dialects/IREEInput/#parameters_9","title":"Parameters:","text":"Parameter C++ type Description targetType <code>::mlir::Type</code> A type suitable as a target type of a pointer"},{"location":"reference/mlir-dialects/IREEInput/#varianttype","title":"VariantType","text":"<p>Represents any legal or reference type in the IREE runtime</p> <p>Syntax: <code>!iree_input.variant</code></p> <p>The variant type is typically used to parameterize container types that can contain any legal primitive, reference or null in the IREE type system.</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/","title":"IREELinalgExt","text":""},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_ext-dialect","title":"'iree_linalg_ext' Dialect","text":"<p>IREE Linalg Extensions.</p> <p>A dialect designed for experimenting with non-structured operations that cannot be represented efficiently/directly by the Linalg dialect.</p> <ul> <li>'iree_linalg_ext' Dialect<ul> <li>Operation definition<ul> <li>iree_linalg_ext.attention (LinalgExt::AttentionOp)</li> <li>Non-structured ops<ul> <li>iree_linalg_ext.fft (LinalgExt::FftOp)</li> <li>iree_linalg_ext.pack (LinalgExt::PackOp)</li> <li>iree_linalg_ext.reverse (LinalgExt::ReverseOp)</li> <li>iree_linalg_ext.scan (LinalgExt::ScanOp)</li> <li>iree_linalg_ext.scatter (LinalgExt::ScatterOp)</li> <li>iree_linalg_ext.set_encoding (LinalgExt::SetEncodingOp)</li> <li>iree_linalg_ext.sort (LinalgExt::SortOp)</li> <li>iree_linalg_ext.topk (LinalgExt::TopkOp)</li> <li>iree_linalg_ext.unpack (LinalgExt::UnPackOp)</li> <li>iree_linalg_ext.unset_encoding (LinalgExt::UnsetEncodingOp)</li> </ul> </li> <li>iree_linalg_ext.softmax (LinalgExt::SoftmaxOp)</li> <li>iree_linalg_ext.transform.do_not_dce_operands (LinalgExt::DoNotDCEOperandsOp)</li> <li>Winograd ops<ul> <li>iree_linalg_ext.winograd.input_transform (LinalgExt::WinogradInputTransformOp)</li> <li>iree_linalg_ext.winograd.output_transform (LinalgExt::WinogradOutputTransformOp)</li> </ul> </li> <li>iree_linalg_ext.yield (LinalgExt::YieldOp)</li> </ul> </li> <li>Attribute definition<ul> <li>EncodingAttr</li> <li>EncodingRoleAttr</li> <li>EncodingUserAttr</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/mlir-dialects/IREELinalgExt/#operation-definition","title":"Operation definition","text":""},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extattention-linalgextattentionop","title":"<code>iree_linalg_ext.attention</code> (LinalgExt::AttentionOp)","text":"<p>Attention operator</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.attention` attr-dict\n              `ins` `(` $inputs `:` type($inputs) `)`\n              `outs` `(` $outputs `:` type($outputs) `)`\n              (`-&gt;` type($result)^)?\n</code></pre> <p>This operator takes in 3 tensors: query(Q), key(K) and value(V) and computes the attention. For self-attention, all inputs have the same shape BxNxd where B is the of the batch dimension, N is the sequence length and d is head dimension. Typically N &gt;&gt;&gt; d. Mathematically, the attention is defined as matmul(softmax(matmul(Q, transpose(K))), V) and has shape BxNxd. Usually, this operator also performs scaling, masking and dropout, but we leave that out of the current implementation. For cross-attention, the query and output have the same shape (BxNxd), while the key and value differ in sequence length (they have shape BxLxd, where L != N).</p> <p>Traits: AttrSizedOperandSegments, SingleBlockImplicitTerminator&lt;::mlir::iree_compiler::IREE::LinalgExt::YieldOp&gt;</p> <p>Interfaces: DestinationStyleOpInterface, LinalgExtInterface, MemoryEffectOpInterface, ReifyRankedShapedTypeOpInterface, TilingInterface</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands","title":"Operands:","text":"Operand Description <code>inputs</code> shaped of any type values <code>outputs</code> shaped of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#results","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#non-structured-ops","title":"Non-structured ops","text":""},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extfft-linalgextfftop","title":"<code>iree_linalg_ext.fft</code> (LinalgExt::FftOp)","text":"<p>Fft operator</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.fft` attr-dict (`ins` `(` $inputs^ `:` type($inputs) `)`)?\n              `outs` `(` $outputs `:` type($outputs) `)`\n              (`:` type($results)^)?\n</code></pre> <p>Apply 1D FFT to innermost dim. This is an iterative FFT, not recurrsive. Thus, the bit reversal is assumed applied on the input. The op carries an input -- stage, which indicates the level of reduction loop in the algorithm. It represents the computation body. For more details, see \"Data reordering, bit reversal, and in-place algorithms\" section in https://en.wikipedia.org/wiki/Cooley%E2%80%93Tukey_FFT_algorithm</p> <p>The size of innermost dim is expected to be a power of 2.</p> <p>It is optional to carry coefficient tensors/buffers as inputs. In this context, they will be the second and third inputs.</p> <p>Traits: AttrSizedOperandSegments, SingleBlockImplicitTerminator&lt;::mlir::iree_compiler::IREE::LinalgExt::YieldOp&gt;</p> <p>Interfaces: DestinationStyleOpInterface, LinalgExtInterface, MemoryEffectOpInterface, ReifyRankedShapedTypeOpInterface, TilingInterface</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_1","title":"Operands:","text":"Operand Description <code>inputs</code> any type <code>outputs</code> shaped of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#results_1","title":"Results:","text":"Result Description <code>results</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extpack-linalgextpackop","title":"<code>iree_linalg_ext.pack</code> (LinalgExt::PackOp)","text":"<p>Pack operation</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.pack` attr-dict\n              $inputs\n              (`padding_value` `(` $padding_value^ `:` type($padding_value) `)`)?\n              (`outer_dims_perm` `=` $outer_dims_perm^)?\n              `inner_dims_pos` `=` $inner_dims_pos\n              `inner_tiles` `=`\n              custom&lt;DynamicIndexList&gt;($inner_tiles, $static_inner_tiles)\n              `into` $outputs `:` `(` type($inputs) type($outputs) `)`\n              (`-&gt;` type($results)^)?\n</code></pre> <p>The pack operation converts an <code>input</code> into a tiled and packed layout. The dimensions to be tiled are obtained from <code>inner_dims_pos</code> and the size of the tile is obtained from <code>inner_tiles</code>. The dimensions listed in <code>inner_dims_pos</code> do not need to be contiguous in which case the tile will get transposed.  We handle only full tiles if <code>padding_value</code> is not set; it is UB if the tile does not perfectly divide the dimension. If <code>padding_value</code> is set, it will pad along high dimensions, i.e., it pads at the bottom and on the right if the input has rank 2, and the result type shape, will be dynamic in any dimension if and only if the input shape is. As optional input, the operation takes <code>outer_dims_perm</code> that allows to permute the tiled loops.</p> <p>Example KC_to_KCck:</p> <pre><code>iree_linalg_ext.pack %arg0 inner_dims_pos = [1, 0]\n  inner_tiles = [32, 8] into %arg1 : (memref&lt;128x256xf32&gt; memref&lt;16x8x32x8xf32&gt;)\n</code></pre> <p>Example NC_to_NCnc:</p> <p><pre><code>iree_linalg_ext.pack %arg0 inner_dims_pos = [0, 1]\n  inner_tiles = [8, 32] into %arg1 : (memref&lt;128x256xf32&gt; memref&lt;16x8x8x32xf32&gt;)\n</code></pre> Example KC_to_CKkc</p> <pre><code>iree_linalg_ext.pack %arg0 outer_dims_perm = [1, 0] inner_dims_pos = [0, 1]\n  inner_tiles = [32, 8] into %arg1 : (memref&lt;128x256xf32&gt; memref&lt;32x4x32x8xf32&gt;)\n</code></pre> <p>In all cases, dimension at position 0 in the input memref (128) is tiled with a factor of 8, while dimension at position 1 (256) is tiled with a factor of 32. In the KC_to_KCck example, the point loops are interchanged, while in the KC_to_CKkc example the tiled loops.</p> <p>Example NC_to_NCnc with padding:</p> <pre><code>iree_linalg_ext.pack %arg padding_value(%pad : f32) inner_dims_pos = [0, 1]\n  inner_tiles = [8, 2] into %arg1 : (memref&lt;13x15xf32&gt; memref&lt;2x8x8x2xf32&gt;)\n</code></pre> <p>Traits: AttrSizedOperandSegments, SingleBlockImplicitTerminator&lt;::mlir::iree_compiler::IREE::LinalgExt::YieldOp&gt;</p> <p>Interfaces: DestinationStyleOpInterface, LinalgExtInterface, LinalgExtOp, MemoryEffectOpInterface, ReifyRankedShapedTypeOpInterface, TilingInterface</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>outer_dims_perm</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute <code>inner_dims_pos</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute <code>static_inner_tiles</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_2","title":"Operands:","text":"Operand Description <code>inputs</code> shaped of any type values <code>outputs</code> shaped of any type values <code>inner_tiles</code> index <code>padding_value</code> any type"},{"location":"reference/mlir-dialects/IREELinalgExt/#results_2","title":"Results:","text":"Result Description <code>results</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extreverse-linalgextreverseop","title":"<code>iree_linalg_ext.reverse</code> (LinalgExt::ReverseOp)","text":"<p>Reverse operator</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.reverse` attr-dict `dimensions` `(` $dimensions `)`\n              (`ins` `(` $inputs^ `:` type($inputs) `)`)?\n              (`outs` `(` $outputs^ `:` type($outputs) `)`)?\n              (`:` type($results)^)?\n</code></pre> <p>A temporary solution for lowering reverse ops into IREE, allowing IREE to tile and distribute them. }</p> <p>Traits: AttrSizedOperandSegments, SingleBlockImplicitTerminator&lt;::mlir::iree_compiler::IREE::LinalgExt::YieldOp&gt;</p> <p>Interfaces: DestinationStyleOpInterface, LinalgExtInterface, LinalgExtOp, MemoryEffectOpInterface, ReifyRankedShapedTypeOpInterface, TilingInterface</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimensions</code> ::mlir::DenseIntElementsAttr 64-bit signless integer elements attribute"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_3","title":"Operands:","text":"Operand Description <code>inputs</code> shaped of any type values <code>outputs</code> shaped of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#results_3","title":"Results:","text":"Result Description <code>results</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extscan-linalgextscanop","title":"<code>iree_linalg_ext.scan</code> (LinalgExt::ScanOp)","text":"<p>Scan operator</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.scan` attr-dict\n              `dimension` `(` $dimension `)`\n              `inclusive` `(` $inclusive `)`\n              `ins` `(` $inputs `:` type($inputs) `)`\n              `outs` `(` $outputs `:` type($outputs) `)`\n              $region (`-&gt;` type($results)^)?\n</code></pre> <p>Computes the inclusive/exclusive scan along a given dimension.</p> <p>Traits: AttrSizedOperandSegments, SingleBlockImplicitTerminator&lt;::mlir::iree_compiler::IREE::LinalgExt::YieldOp&gt;</p> <p>Interfaces: DestinationStyleOpInterface, LinalgExtInterface, MemoryEffectOpInterface, ReifyRankedShapedTypeOpInterface, TilingInterface</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#attributes_2","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension</code> ::mlir::IntegerAttr 64-bit signless integer attribute <code>inclusive</code> ::mlir::BoolAttr bool attribute"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_4","title":"Operands:","text":"Operand Description <code>inputs</code> shaped of any type values <code>outputs</code> shaped of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#results_4","title":"Results:","text":"Result Description <code>results</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extscatter-linalgextscatterop","title":"<code>iree_linalg_ext.scatter</code> (LinalgExt::ScatterOp)","text":"<p>Scatter operator</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.scatter` attr-dict `dimension_map` `=` $dimension_map\n              `unique_indices` `(` $unique_indices `)`\n              (`ins` `(` $inputs^ `:` type($inputs) `)`)?\n              `outs` `(` $outputs `:` type($outputs) `)`\n              $region (`-&gt;` type($results)^)?\n</code></pre> <p>Based on XLA operation semantics, takes two <code>inputs</code> (<code>update</code> and <code>indices</code>) and <code>outputs</code> value (<code>original</code>). The operation updates the value at the slices specified by <code>indices</code> by combining the current value with the value in <code>updates</code> using the computation specified in <code>region</code>. The <code>region</code> specifies a binary operation of signature (T, T) -&gt; T, where <code>T</code> is the element-type of <code>updates</code> (and <code>original</code>). The first argument correspond the value to be updated (i.e. from <code>updates</code>), and the second the current value (i.e. value from <code>original</code>).</p> <p>The <code>indices</code> is a 2D tensor/memref type. The first dim is the number of updates, and the second dim is index depth. The index depth should always be static.</p> <p>The first dim of <code>updates</code> and <code>indices</code> is identical, since they represent the number of updates.</p> <p>The rank of the <code>original</code>/<code>result</code> is at least <code>index_depth + rank(%updates) - 1</code>. The first <code>index_depth</code> indices are derived from <code>indices</code> and the shape of update value has the last rank(%original) - index_depth values match %(originals) last dimensions, with the previous dims extending from the index offsets.</p> <p>The dimension_map attributes describes which index value maps to which dimension in the destionation. It cannot contain duplicate values, must have as many entries as index depth, and values must be within the rank of the destination.</p> <p>The unique_indices attribute carries the information whether all the indices are unique. If there are repeated indices, the first iteration loop will be marked as reduction.</p> <p>The shapes definition follows tensorflow operations execept that it force batch dims to be 1D. See more information in   https://www.tensorflow.org/api_docs/python/tf/tensor_scatter_nd_update</p> <p>Traits: AttrSizedOperandSegments, SingleBlockImplicitTerminator&lt;::mlir::iree_compiler::IREE::LinalgExt::YieldOp&gt;</p> <p>Interfaces: DestinationStyleOpInterface, LinalgExtInterface, MemoryEffectOpInterface, ReifyRankedShapedTypeOpInterface, TilingInterface</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#attributes_3","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension_map</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute <code>unique_indices</code> ::mlir::BoolAttr bool attribute"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_5","title":"Operands:","text":"Operand Description <code>inputs</code> ranked tensor or memref of any type values <code>outputs</code> ranked tensor or memref of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#results_5","title":"Results:","text":"Result Description <code>results</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extset_encoding-linalgextsetencodingop","title":"<code>iree_linalg_ext.set_encoding</code> (LinalgExt::SetEncodingOp)","text":"<p>Perform pack and pad operation on source</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.set_encoding` attr-dict $source `:` type($source) `-&gt;` type($result)\n</code></pre> <p>Operation to assign an encoding to a tensor. The operation does not change the rank or extent of a tensor. Instead it adds an encoding attribute to the tensor type to represent a change in layout.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), ReifyRankedShapedTypeOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_6","title":"Operands:","text":"Operand Description <code>source</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#results_6","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extsort-linalgextsortop","title":"<code>iree_linalg_ext.sort</code> (LinalgExt::SortOp)","text":"<p>Sort operator</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.sort` attr-dict\n              `dimension` `(` $dimension `)`\n              (`ins` `(` $inputs^ `:` type($inputs) `)`)?\n              `outs` `(` $outputs `:` type($outputs) `)`\n              $region (`-&gt;` type($results)^)?\n</code></pre> <p>Based on XLA operation semantics, sorts the given <code>operands</code> at the given <code>dimension</code> with the given <code>comparator</code>.</p> <p>See https://www.tensorflow.org/xla/operation_semantics#sort.</p> <p>Traits: AttrSizedOperandSegments, SingleBlockImplicitTerminator&lt;::mlir::iree_compiler::IREE::LinalgExt::YieldOp&gt;</p> <p>Interfaces: DestinationStyleOpInterface, LinalgExtInterface, MemoryEffectOpInterface, ReifyRankedShapedTypeOpInterface, TilingInterface</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#attributes_4","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension</code> ::mlir::IntegerAttr 64-bit signless integer attribute"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_7","title":"Operands:","text":"Operand Description <code>inputs</code> any type <code>outputs</code> shaped of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#results_7","title":"Results:","text":"Result Description <code>results</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_exttopk-linalgexttopkop","title":"<code>iree_linalg_ext.topk</code> (LinalgExt::TopkOp)","text":"<p>Top-K operator</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.topk` attr-dict\n              `dimension` `(` $dimension `)`\n              `ins` `(` $inputs `:` type($inputs) `)`\n              `outs` `(` $outputs `:` type($outputs) `)`\n              $region (`-&gt;` type($results)^)?\n</code></pre> <p>A Top-K operation for N-D tensors. Reduces the target dimension from the input size N down to K elements based on the supplied binary region.</p> <p>Accepts an N-D tensor input consisting of values and an optioanl N-D tensor for indices of those values (i32 type). If input indices aren't provided, the index mapping is inferred based on the k dim.  Both input values/indices tensors and output values/indicies tensors must have the same shape. Top-K is computed along the target dimension (from dimension()). Returns two output tensors of values and the indicies of Top-K results. The output dimensions must match the input save for the dimension that is reduced to K results.</p> <p>Region accepts lhs=[next N input] and rhs=[exiting K output] and yeilds an i1. If true, the two values are swapped:   - For Top-K compoarision: &gt;   - For Min-K comparision: &lt; Note: when the two values are equal, the first occurence is always selected.</p> <p>Traits: AttrSizedOperandSegments, SingleBlockImplicitTerminator&lt;::mlir::iree_compiler::IREE::LinalgExt::YieldOp&gt;</p> <p>Interfaces: DestinationStyleOpInterface, LinalgExtInterface, LinalgExtOp, MemoryEffectOpInterface, ReifyRankedShapedTypeOpInterface, TilingInterface</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#attributes_5","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension</code> ::mlir::IntegerAttr 64-bit signless integer attribute"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_8","title":"Operands:","text":"Operand Description <code>inputs</code> shaped of any type values <code>outputs</code> shaped of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#results_8","title":"Results:","text":"Result Description <code>results</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extunpack-linalgextunpackop","title":"<code>iree_linalg_ext.unpack</code> (LinalgExt::UnPackOp)","text":"<p>Unpack operation</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.unpack` attr-dict\n              $inputs\n              (`outer_dims_perm` `=` $outer_dims_perm^)?\n              `inner_dims_pos` `=` $inner_dims_pos\n              `inner_tiles` `=`\n              custom&lt;DynamicIndexList&gt;($inner_tiles, $static_inner_tiles)\n              `into` $outputs `:` `(` type($inputs) type($outputs) `)`\n              (`-&gt;` type($results)^)?\n</code></pre> <p>The unpack operation converts a tiled and packed input to an unpacked output. See <code>pack</code> for more details on <code>inner_tiles</code> and <code>dims_pos</code>; it is UB if the tile does not perfectly divide the dimension. Optionally, the operation also supports permuting the tiled loops.</p> <p>Example KCck_to_KC:</p> <pre><code>iree_linalg_ext.unpack %arg0 dims_pos = [1, 0]\n  inner_tiles = [32, 8] into %arg1 : (memref&lt;16x8x32x8xf32&gt; memref&lt;128x256xf32&gt;)\n</code></pre> <p>Example NCnc_to_NC:</p> <pre><code>iree_linalg_ext.unpack %arg0 dims_pos = [0, 1]\n  inner_tiles = [8, 32] into %arg1 : (memref&lt;16x8x8x32xf32&gt; memref&lt;128x256xf32&gt;)\n</code></pre> <p>Example CKkc_to_KC:</p> <pre><code>iree_linalg_ext.unpack %arg1 outer_dims_perm = [1, 0] inner_dims_pos = [0, 1]\n  inner_tiles = [32, 8] into %arg0 : (memref&lt;32x4x32x8xf32&gt; memref&lt;128x256xf32&gt;)\n</code></pre> <p>Traits: AttrSizedOperandSegments, SingleBlockImplicitTerminator&lt;::mlir::iree_compiler::IREE::LinalgExt::YieldOp&gt;</p> <p>Interfaces: DestinationStyleOpInterface, LinalgExtInterface, LinalgExtOp, MemoryEffectOpInterface, ReifyRankedShapedTypeOpInterface, TilingInterface</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#attributes_6","title":"Attributes:","text":"Attribute MLIR Type Description <code>outer_dims_perm</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute <code>inner_dims_pos</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute <code>static_inner_tiles</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_9","title":"Operands:","text":"Operand Description <code>inputs</code> shaped of any type values <code>outputs</code> shaped of any type values <code>inner_tiles</code> index"},{"location":"reference/mlir-dialects/IREELinalgExt/#results_9","title":"Results:","text":"Result Description <code>results</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extunset_encoding-linalgextunsetencodingop","title":"<code>iree_linalg_ext.unset_encoding</code> (LinalgExt::UnsetEncodingOp)","text":"<p>Perfom unpack and extract operation on source</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.unset_encoding` attr-dict $source `:` type($source) `-&gt;` type($result)\n</code></pre> <p>Operation to convert an tensor with encoding that represents its data layout into a tensor with default layout (i.e. no encoding). For now in IREE the default layout is row-major.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), ReifyRankedShapedTypeOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_10","title":"Operands:","text":"Operand Description <code>source</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#results_10","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extsoftmax-linalgextsoftmaxop","title":"<code>iree_linalg_ext.softmax</code> (LinalgExt::SoftmaxOp)","text":"<p>Softmax operator</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.softmax` attr-dict\n              `dimension` `(` $dimension `)`\n              `ins` `(` $inputs `:` type($inputs) `)`\n              `outs` `(` $outputs `:` type($outputs) `)`\n              (`-&gt;` type($result)^)?\n</code></pre> <p>This op computes a numerically stable version of softmax for a given tensor. For a given input tensor x and specified dimension d, we first compute the max along that dimension (m). We then compute f(x) = exp(x - m). Then, we sum f(x) along dimension d to get l(x). Finally, we compute the softmax as f(x) / l(x).</p> <p>Traits: AttrSizedOperandSegments, SingleBlockImplicitTerminator&lt;::mlir::iree_compiler::IREE::LinalgExt::YieldOp&gt;</p> <p>Interfaces: DestinationStyleOpInterface, LinalgExtInterface, MemoryEffectOpInterface, ReifyRankedShapedTypeOpInterface, TilingInterface</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#attributes_7","title":"Attributes:","text":"Attribute MLIR Type Description <code>dimension</code> ::mlir::IntegerAttr 64-bit signless integer attribute"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_11","title":"Operands:","text":"Operand Description <code>inputs</code> shaped of any type values <code>outputs</code> shaped of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#results_11","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_exttransformdo_not_dce_operands-linalgextdonotdceoperandsop","title":"<code>iree_linalg_ext.transform.do_not_dce_operands</code> (LinalgExt::DoNotDCEOperandsOp)","text":"<p>Unfoldable op that just keeps its operands live</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.transform.do_not_dce_operands` attr-dict $operands `:` type($operands)\n</code></pre> <p>Unfoldable op that just keeps its operands live. This is to use with the transform dialect in case where transforms introduce IR that would be otherwise DCE'd by canonicalizations.</p> <p>This op should be added to the transform dialect in the fullness of time but it can't be registered dynamically on the IREE side as that triggers errors since the op does not implement any transform interface.</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_12","title":"Operands:","text":"Operand Description <code>operands</code> any type"},{"location":"reference/mlir-dialects/IREELinalgExt/#winograd-ops","title":"Winograd ops","text":""},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extwinogradinput_transform-linalgextwinogradinputtransformop","title":"<code>iree_linalg_ext.winograd.input_transform</code> (LinalgExt::WinogradInputTransformOp)","text":"<p>Winograd Input Transform operator</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.winograd.input_transform` attr-dict\n              `output_tile_size` `(` $output_tile_size `)`\n              `kernel_size` `(` $kernel_size `)`\n              `image_dimensions` `(` $image_dimensions `)`\n              `ins` `(` $inputs `:` type($inputs) `)`\n              `outs` `(` $outputs `:` type($outputs) `)`\n              (`-&gt;` type($result)^)?\n</code></pre> <p>This operator is the first step in converting a convolution to its Winograd equivalent. Given a tile of an input image (I), this operator computes matmul(tranpose(B), matmul(I, B)). The input tile is assumed to be square with each side of size m + r - 1, where the convolutional kernel is m x m and the output tile size is r x r. B is a constant 2-d square matrix of the same shape as the input tile I. The input to the operator is an image of shape (N, H, W, C) or (N, C, H, W) and the output is an operator of shape (m + r - 1, m + r - 1, N, H', W', C) where H' = ceil((H - m + 1)/r) and W' = ceil((W - m + 1)/r). The result of this operator is first collapsed and then fed to a batch matmul op.</p> <p>Traits: AttrSizedOperandSegments, SingleBlockImplicitTerminator&lt;::mlir::iree_compiler::IREE::LinalgExt::YieldOp&gt;</p> <p>Interfaces: DestinationStyleOpInterface, LinalgExtInterface, MemoryEffectOpInterface, ReifyRankedShapedTypeOpInterface, TilingInterface</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#attributes_8","title":"Attributes:","text":"Attribute MLIR Type Description <code>output_tile_size</code> ::mlir::IntegerAttr 64-bit signless integer attribute <code>kernel_size</code> ::mlir::IntegerAttr 64-bit signless integer attribute <code>image_dimensions</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_13","title":"Operands:","text":"Operand Description <code>inputs</code> shaped of any type values <code>outputs</code> shaped of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#results_12","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extwinogradoutput_transform-linalgextwinogradoutputtransformop","title":"<code>iree_linalg_ext.winograd.output_transform</code> (LinalgExt::WinogradOutputTransformOp)","text":"<p>Winograd Output Transform operator</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.winograd.output_transform` attr-dict\n              `output_tile_size` `(` $output_tile_size `)`\n              `kernel_size` `(` $kernel_size `)`\n              `image_dimensions` `(` $image_dimensions `)`\n              `ins` `(` $inputs `:` type($inputs) `)`\n              `outs` `(` $outputs `:` type($outputs) `)`\n              (`-&gt;` type($result)^)?\n</code></pre> <p>This operator is the last transform in converting a convolution to its Winograd equivalent. After convolution in the Winograd domain (which turns into an elementwise product for a single channel and batch matrix multiplication for many channels), this operator converts the output back into the original domain. Given a tile of the output (O) in the Winograd domain, this operator computes matmul(transpose(A), matmul(O, A)). The output tile is square with each side of size m + r - 1, where the convolutional kernel is m x m and the output tile size is r x r. A is a constant 2-d matrix of shape (m + r - 1) x r. The input to the operator is a tensor of shape (m + r - 1, m + r - 1, N, H', W', C) and the output is a tensor of shape (N, H, W, C) or (N, C, H, W) where H = r H' and W = r W'. This operator is followed by a tensor.extract_slice which extracts only the non-padded part of the output.</p> <p>Traits: AttrSizedOperandSegments, SingleBlockImplicitTerminator&lt;::mlir::iree_compiler::IREE::LinalgExt::YieldOp&gt;</p> <p>Interfaces: DestinationStyleOpInterface, LinalgExtInterface, MemoryEffectOpInterface, ReifyRankedShapedTypeOpInterface, TilingInterface</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#attributes_9","title":"Attributes:","text":"Attribute MLIR Type Description <code>output_tile_size</code> ::mlir::IntegerAttr 64-bit signless integer attribute <code>kernel_size</code> ::mlir::IntegerAttr 64-bit signless integer attribute <code>image_dimensions</code> ::mlir::DenseI64ArrayAttr i64 dense array attribute"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_14","title":"Operands:","text":"Operand Description <code>inputs</code> shaped of any type values <code>outputs</code> shaped of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#results_13","title":"Results:","text":"Result Description <code>result</code> ranked tensor of any type values"},{"location":"reference/mlir-dialects/IREELinalgExt/#iree_linalg_extyield-linalgextyieldop","title":"<code>iree_linalg_ext.yield</code> (LinalgExt::YieldOp)","text":"<p>LinalgExt yield op</p> <p>Syntax:</p> <pre><code>operation ::= `iree_linalg_ext.yield` attr-dict ($operands^ `:` type($operands))?\n</code></pre> <p><code>iree_linalg_ext.yield</code> is a special terminator operation for blocks inside regions in <code>iree_linalg_ext</code> ops.</p> <p>Traits: AlwaysSpeculatableImplTrait, ReturnLike, Terminator</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#operands_15","title":"Operands:","text":"Operand Description <code>operands</code> any type"},{"location":"reference/mlir-dialects/IREELinalgExt/#attribute-definition","title":"Attribute definition","text":""},{"location":"reference/mlir-dialects/IREELinalgExt/#encodingattr","title":"EncodingAttr","text":"<p>information to decide how to data-tile a tensor</p> <p>Syntax:</p> <pre><code>#iree_linalg_ext.encoding&lt;\n  EncodingUserAttr,   # user\n  EncodingRoleAttr   # role\n&gt;\n</code></pre> <p>This attribute describes the change in the layout for a given tensor to execute subsequent operations on the tiled layout. The encoding serves as a way to represent the change in the way the data is laid out in memory without changing the logical rank/extent of the tensor itself. When required, the encoding can be used to explicitly manifest the layout change through operations like pack/unpack.</p>"},{"location":"reference/mlir-dialects/IREELinalgExt/#parameters","title":"Parameters:","text":"Parameter C++ type Description user <code>EncodingUserAttr</code> kind of operation using this tensor role <code>EncodingRoleAttr</code> role of this tensor as an operand"},{"location":"reference/mlir-dialects/IREELinalgExt/#encodingroleattr","title":"EncodingRoleAttr","text":"<p>Describes the role of the tensor as an operand or a result of an operation.</p> <p>Syntax:</p> <pre><code>#iree_linalg_ext.role&lt;\n  ::mlir::iree_compiler::IREE::LinalgExt::EncodingRole   # value\n&gt;\n</code></pre>"},{"location":"reference/mlir-dialects/IREELinalgExt/#parameters_1","title":"Parameters:","text":"Parameter C++ type Description value <code>::mlir::iree_compiler::IREE::LinalgExt::EncodingRole</code> an enum of type EncodingRole"},{"location":"reference/mlir-dialects/IREELinalgExt/#encodinguserattr","title":"EncodingUserAttr","text":"<p>Describes the operation that a tensor is an operand or a result of.</p> <p>Syntax:</p> <pre><code>#iree_linalg_ext.user&lt;\n  ::mlir::iree_compiler::IREE::LinalgExt::EncodingUser   # value\n&gt;\n</code></pre>"},{"location":"reference/mlir-dialects/IREELinalgExt/#parameters_2","title":"Parameters:","text":"Parameter C++ type Description value <code>::mlir::iree_compiler::IREE::LinalgExt::EncodingUser</code> an enum of type EncodingUser"},{"location":"reference/mlir-dialects/Stream/","title":"Stream","text":""},{"location":"reference/mlir-dialects/Stream/#stream-dialect","title":"'stream' Dialect","text":"<p>A dialect designed to model execution partitioning and scheduling.</p> <p>The stream dialect is designed to take tensor programs and convert them to explicitly scheduled asynchronous programs. This includes placing ops on specific targets, partitioning the work between the targets, scheduling the work for concurrency, and encoding tensors into target-specific resources.</p> <pre><code>+--------+    +----------+    +-------+\n| flow.* | -&gt; | stream.* | -&gt; | hal.* |\n+--------+    +----------+    +-------+\n</code></pre> <p>This sits in-between the <code>flow</code> and <code>hal</code> dialects.</p> <ul> <li> <p><code>flow</code> models tensor programs by separating work into dispatchable   functions in order to isolate the main host program data flow and the   dense tensor compute operations.</p> </li> <li> <p><code>stream</code> models explicitly scheduled asynchronous programs by partitioning   the dispatchable work, specifying target affinities, encoding tensors into   target-specific forms, and scheduling the work to run concurrently.</p> </li> <li> <p><code>hal</code> models a low-level hardware abstraction layer used to manage   buffers and issue asynchronous work across a variety of device types. The   dialect is largely 1:1 with the IREE HAL C API.</p> </li> </ul> <p>Transforms in the dialect lower tensor values into opaque resources with the goal of ensuring no tensors survive in the IR. At entry <code>stream.tensor.*</code> ops are used to capture the source tensor encoding information (data type, shapes, etc) and then lowered into <code>stream.async.*</code> ops that model the asynchronous workloads on the opaque resources. The asynchronous operations are then partitioned, allocated, and scheduled for execution using the <code>stream.cmd.*</code> ops.</p> <p>It's intended that after transformation through the stream dialect the program is ready for execution on an abstract machine. At this level of representation buffers have still not been allocated and devices are not yet resolved, however the information captured in the <code>stream</code> IR allows such operations to be done trivially. To this end all ops carry the symbolic size of the resources on which they operate as well as the lifetime of the resources they are acting upon. This manifests in the usage of the <code>!stream.resource</code> type:</p> <pre><code>// Unresolved lifetime (resolved during the iree-stream-refine-usage pass):\n!stream.resource&lt;*&gt;\n// An externally managed value (passed in via the program API).\n!stream.resource&lt;external&gt;\n// A staging buffer for uploads/downloads.\n!stream.resource&lt;staging&gt;\n// A short-lived value that is used across streams.\n!stream.resource&lt;transient&gt;\n// A long-lived value that persists across streams in globals.\n!stream.resource&lt;variable&gt;\n// An immutable value that persists for the duration of the program.\n!stream.resource&lt;constant&gt;\n</code></pre> <p>Operations using resources carry the size of all operand result resources:</p> <pre><code>// %update (40 bytes) is being inserted into %target (296 bytes).\n// Can be dynamic values such as those originating from dynamic dimensions.\n%13 = stream.async.update %update, %target[%c256 to %c296] :\n    !stream.resource&lt;transient&gt;{%c40} -&gt;\n    %target as !stream.resource&lt;transient&gt;{%c296}\n</code></pre> <p>Once all <code>stream.async.*</code> work is moved into executable regions (such as <code>stream.async.execute</code>) <code>!stream.timepoint</code> values are used to sequence the execution. These timepoints represent some point in time where all execution up to that timepoint has completed and any results that were produced by the execution are available for use. Attempting to use the resources before their corresponding timepoint has been reached will lead to undefined behavior. The benefit of this is that after timepoints are established in the IR it's possible to induce aliasing of resources without breaking execution correctness.</p> <ul> <li>'stream' Dialect<ul> <li>Operation definition<ul> <li>Async control flow ops<ul> <li>stream.async.call (Stream::AsyncCallOp)</li> <li>stream.async.concurrent (Stream::AsyncConcurrentOp)</li> <li>stream.async.execute (Stream::AsyncExecuteOp)</li> <li>stream.async.func (Stream::AsyncFuncOp)</li> </ul> </li> <li>Channel ops<ul> <li>stream.channel.count (Stream::ChannelCountOp)</li> <li>stream.channel.create (Stream::ChannelCreateOp)</li> <li>stream.channel.rank (Stream::ChannelRankOp)</li> <li>stream.channel.split (Stream::ChannelSplitOp)</li> </ul> </li> <li>Executable ops<ul> <li>stream.binding.subspan (Stream::BindingSubspanOp)</li> <li>stream.executable.end (Stream::ExecutableEndOp)</li> <li>stream.executable.export (Stream::ExecutableExportOp)</li> <li>stream.executable (Stream::ExecutableOp)</li> </ul> </li> <li>Explicit command ops<ul> <li>stream.cmd.call (Stream::CmdCallOp)</li> <li>stream.cmd.collective (Stream::CmdCollectiveOp)</li> <li>stream.cmd.concurrent (Stream::CmdConcurrentOp)</li> <li>stream.cmd.copy (Stream::CmdCopyOp)</li> <li>stream.cmd.discard (Stream::CmdDiscardOp)</li> <li>stream.cmd.dispatch (Stream::CmdDispatchOp)</li> <li>stream.cmd.execute (Stream::CmdExecuteOp)</li> <li>stream.cmd.fill (Stream::CmdFillOp)</li> <li>stream.cmd.flush (Stream::CmdFlushOp)</li> <li>stream.cmd.func (Stream::CmdFuncOp)</li> <li>stream.cmd.invalidate (Stream::CmdInvalidateOp)</li> <li>stream.cmd.serial (Stream::CmdSerialOp)</li> </ul> </li> <li>Miscellaneous ops<ul> <li>stream.return (Stream::ReturnOp)</li> <li>stream.yield (Stream::YieldOp)</li> </ul> </li> <li>Pseudo Ops<ul> <li>stream.tensor.export (Stream::TensorExportOp)</li> <li>stream.tensor.import (Stream::TensorImportOp)</li> </ul> </li> <li>Resource ops<ul> <li>stream.resource.alloc (Stream::ResourceAllocOp)</li> <li>stream.resource.alloca (Stream::ResourceAllocaOp)</li> <li>stream.resource.constants (Stream::ResourceConstantsOp)</li> <li>stream.resource.dealloca (Stream::ResourceDeallocaOp)</li> <li>stream.resource.load (Stream::ResourceLoadOp)</li> <li>stream.resource.map (Stream::ResourceMapOp)</li> <li>stream.resource.pack (Stream::ResourcePackOp)</li> <li>stream.resource.size (Stream::ResourceSizeOp)</li> <li>stream.resource.store (Stream::ResourceStoreOp)</li> <li>stream.resource.subview (Stream::ResourceSubviewOp)</li> <li>stream.resource.try_map (Stream::ResourceTryMapOp)</li> </ul> </li> <li>Resource transfer ops<ul> <li>stream.async.alloca (Stream::AsyncAllocaOp)</li> <li>stream.async.clone (Stream::AsyncCloneOp)</li> <li>stream.async.collective (Stream::AsyncCollectiveOp)</li> <li>stream.async.constant (Stream::AsyncConstantOp)</li> <li>stream.async.copy (Stream::AsyncCopyOp)</li> <li>stream.async.dispatch (Stream::AsyncDispatchOp)</li> <li>stream.async.fill (Stream::AsyncFillOp)</li> <li>stream.async.load (Stream::AsyncLoadOp)</li> <li>stream.async.slice (Stream::AsyncSliceOp)</li> <li>stream.async.splat (Stream::AsyncSplatOp)</li> <li>stream.async.store (Stream::AsyncStoreOp)</li> <li>stream.async.transfer (Stream::AsyncTransferOp)</li> <li>stream.async.update (Stream::AsyncUpdateOp)</li> </ul> </li> <li>Synchronization ops<ul> <li>stream.timepoint.await (Stream::TimepointAwaitOp)</li> <li>stream.timepoint.barrier (Stream::TimepointBarrierOp)</li> <li>stream.timepoint.chain_external (Stream::TimepointChainExternalOp)</li> <li>stream.timepoint.export (Stream::TimepointExportOp)</li> <li>stream.timepoint.immediate (Stream::TimepointImmediateOp)</li> <li>stream.timepoint.import (Stream::TimepointImportOp)</li> <li>stream.timepoint.join (Stream::TimepointJoinOp)</li> </ul> </li> <li>Tensor ops<ul> <li>stream.tensor.clone (Stream::TensorCloneOp)</li> <li>stream.tensor.constant (Stream::TensorConstantOp)</li> <li>stream.tensor.empty (Stream::TensorEmptyOp)</li> <li>stream.tensor.fill (Stream::TensorFillOp)</li> <li>stream.tensor.load (Stream::TensorLoadOp)</li> <li>stream.tensor.sizeof (Stream::TensorSizeOfOp)</li> <li>stream.tensor.slice (Stream::TensorSliceOp)</li> <li>stream.tensor.splat (Stream::TensorSplatOp)</li> <li>stream.tensor.store (Stream::TensorStoreOp)</li> <li>stream.tensor.trace (Stream::TensorTraceOp)</li> <li>stream.tensor.update (Stream::TensorUpdateOp)</li> </ul> </li> </ul> </li> <li>Attribute definition<ul> <li>CollectiveAttr</li> <li>PartitioningConfigAttr</li> <li>ResourceConfigAttr</li> <li>TimepointAttr</li> </ul> </li> <li>Type constraint definition<ul> <li>constant resource</li> <li>external resource</li> <li>staging resource</li> <li>transient resource</li> <li>resource</li> <li>variable resource</li> </ul> </li> <li>Type definition<ul> <li>BindingType</li> <li>ChannelType</li> <li>ResourceType</li> <li>TimepointType</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/mlir-dialects/Stream/#operation-definition","title":"Operation definition","text":""},{"location":"reference/mlir-dialects/Stream/#async-control-flow-ops","title":"Async control flow ops","text":""},{"location":"reference/mlir-dialects/Stream/#streamasynccall-streamasynccallop","title":"<code>stream.async.call</code> (Stream::AsyncCallOp)","text":"<p>Calls a streamable external host function</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.call` (`on` `(` $affinity^ `)`)?\n              $callee ``\n              custom&lt;DispatchOperands&gt;($resource_operands,\n              $resource_operand_offsets,\n              $resource_operand_ends,\n              $resource_operand_lengths) attr-dict `:`\n              custom&lt;ShapedFunctionType&gt;(ref($resource_operands),\n              type($resource_operands), $resource_operand_sizes,\n              type($results), $result_sizes,\n              $tied_operands)\n</code></pre> <p>Calls a function taking/returning resource values with stream semantics. Asynchronous calls must have no side-effects.</p> <p>Note that returned resources must have their sizes declared prior to the call as this is what allows the call to be made on the stream. If external host logic is required to compute the size (avoid at all costs!) a separate func.call can be used outside of the stream to do so. If sizes are unknownable until the operation is performed it should be made as a normal asynchronous host call with 'coarse-fences' instead.</p> <p>Traits: AttrSizedOperandSegments, Stream_AsyncPhaseOp</p> <p>Interfaces: AsyncAccessOpInterface, CallOpInterface, Stream_AffinityOp, Stream_StreamableOp, SymbolUserOpInterface, TiedOpInterface, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>callee</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands","title":"Operands:","text":"Operand Description <code>resource_operands</code> resource or external resource or transient resource or variable resource or constant resource or index or integer or floating-point or complex-type or any type <code>resource_operand_sizes</code> index <code>resource_operand_offsets</code> index <code>resource_operand_ends</code> index <code>resource_operand_lengths</code> index <code>result_sizes</code> index"},{"location":"reference/mlir-dialects/Stream/#results","title":"Results:","text":"Result Description <code>results</code> resource or external resource or transient resource or variable resource or constant resource or index or integer or floating-point or complex-type"},{"location":"reference/mlir-dialects/Stream/#streamasyncconcurrent-streamasyncconcurrentop","title":"<code>stream.async.concurrent</code> (Stream::AsyncConcurrentOp)","text":"<p>Executes all ops concurrently</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.concurrent` (`on` `(` $affinity^ `)`)?\n              `with` ``\n              custom&lt;ResourceRegion&gt;($resource_operands,\n              type($resource_operands), $resource_operand_sizes,\n              type($results), $result_sizes,\n              $tied_operands, $body)\n              attr-dict-with-keyword\n</code></pre> <p>Represents a wave of work scheduled concurrently (each op executing at the same time). All resource inputs must be captured explicitly. All results are only ready once all nested ops complete execution.</p> <p>Waves can be nested to create a DAG. For example, take the following graph: <pre><code>                  |\n        v---------+---------v\n+-------|-------+   +-------|-------+\n|    v--+--v    |   |    v--+--v    |\n| +----+ +----+ |   | +----+ +----+ |\n| | %a | | %b | |   | | %c | | %d | |\n| +----+ +----+ |   | +----+ +----+ |\n|    +--v--+    |   |    +--v--+    |\n+-------|-------+   +-------|-------+\n        +---------v---------+\n                  |\n</code></pre></p> <p>Represented with nested waves: <pre><code>  %0 = stream.async.concurrent with(%arg) -&gt; ... {\n    %1 = stream.async.concurrent with(%arg as %arg0) -&gt; ... {\n      %a = ...\n      %b = ...\n      stream.yield %a, %b\n    }\n    %2 = stream.async.concurrent with(%arg as %arg1) -&gt; ... {\n      %c = ...\n      %d = ...\n      stream.yield %c, %d\n    }\n    stream.yield %1, %2\n  }\n</code></pre></p> <p>Traits: AttrSizedOperandSegments, HasParent, RecursiveMemoryEffects, SingleBlockImplicitTerminator, Stream_AsyncPhaseOp <p>Interfaces: AsyncAccessOpInterface, ClosureOpInterface, RegionBranchOpInterface, Stream_AffinityOp, Stream_StreamableOp, TiedOpInterface, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_1","title":"Operands:","text":"Operand Description <code>resource_operands</code> resource or external resource or transient resource or variable resource or constant resource or staging resource <code>resource_operand_sizes</code> index <code>result_sizes</code> index"},{"location":"reference/mlir-dialects/Stream/#results_1","title":"Results:","text":"Result Description <code>results</code> resource or external resource or transient resource or variable resource or constant resource or staging resource"},{"location":"reference/mlir-dialects/Stream/#streamasyncexecute-streamasyncexecuteop","title":"<code>stream.async.execute</code> (Stream::AsyncExecuteOp)","text":"<p>Executes a dependency-aware sequence of streamable ops</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.execute` (`on` `(` $affinity^ `)`)?\n              (`await` `(` $await_timepoint^ `)` `=` `` `&gt;`)?\n              `with` ``\n              custom&lt;ResourceRegion&gt;($resource_operands,\n              type($resource_operands), $resource_operand_sizes,\n              type($results), $result_sizes,\n              $tied_operands, $body)\n              `=` `` `&gt;` type($result_timepoint)\n              attr-dict-with-keyword\n</code></pre> <p>Evaluates the operations within the region by dependency order while obeying ties when present. Nested ops execute serially in block order and nested <code>stream.async.concurrent</code> ops can be used to run multiple ops concurrently within the stream. All resource inputs must be captured explicitly. All results are only ready once all nested ops complete execution and the returned timepoint is reached. Zero or more timepoints may be provided to block execution until they are all reached; zero timepoints indicates that execution may begin immediately.</p> <p>Traits: AttrSizedOperandSegments, RecursiveMemoryEffects, SingleBlockImplicitTerminator, Stream_AsyncPhaseOp <p>Interfaces: AsyncAccessOpInterface, ClosureOpInterface, RegionBranchOpInterface, Stream_AffinityOp, Stream_TimelineOp, TiedOpInterface, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_2","title":"Attributes:","text":"Attribute MLIR Type Description <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_2","title":"Operands:","text":"Operand Description <code>resource_operands</code> resource or external resource or transient resource or variable resource or constant resource or staging resource <code>resource_operand_sizes</code> index <code>result_sizes</code> index <code>await_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#results_2","title":"Results:","text":"Result Description <code>results</code> resource or external resource or transient resource or variable resource or constant resource or staging resource <code>result_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#streamasyncfunc-streamasyncfuncop","title":"<code>stream.async.func</code> (Stream::AsyncFuncOp)","text":"<p>Streamable function declaration</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.func` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              $sym_name\n              ``\n              custom&lt;ShapedFunctionSignature&gt;($function_type,\n              $tied_operands,\n              $arg_attrs,\n              $res_attrs)\n              attr-dict-with-keyword\n              ($body^)?\n</code></pre> <p>Declares a function that can be called as an asynchronous streaming operation via <code>stream.async.call</code>. Today only external functions are allowed.</p> <p>Traits: IsolatedFromAbove, Stream_AsyncPhaseOp</p> <p>Interfaces: CallableOpInterface, FunctionOpInterface, Symbol</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_3","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_name</code> ::mlir::StringAttr string attribute <code>function_type</code> ::mlir::TypeAttr type attribute of function type <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>arg_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes <code>res_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes"},{"location":"reference/mlir-dialects/Stream/#channel-ops","title":"Channel ops","text":""},{"location":"reference/mlir-dialects/Stream/#streamchannelcount-streamchannelcountop","title":"<code>stream.channel.count</code> (Stream::ChannelCountOp)","text":"<p>Returns the total number of participants in the group</p> <p>Syntax:</p> <pre><code>operation ::= `stream.channel.count` $channel `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the total participant count in the collective communicator group.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#operands_3","title":"Operands:","text":"Operand Description <code>channel</code> a collective communication channel"},{"location":"reference/mlir-dialects/Stream/#results_3","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/Stream/#streamchannelcreate-streamchannelcreateop","title":"<code>stream.channel.create</code> (Stream::ChannelCreateOp)","text":"<p>Creates a new channel for collective communication</p> <p>Syntax:</p> <pre><code>operation ::= `stream.channel.create` (`on` `(` $affinity^ `)`)?\n              (`id` `(` $id^ `)`)?\n              (`group` `(` $group^ `)`)?\n              (`rank` `(` $rank^ `)`)?\n              (`count` `(` $count^ `)`)?\n              `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns a new channel with the given rank associated with the specified affinity. Collective operations using this channel must only be submitted on compatible affinities.</p> <p>The group and ID are optional and may be null. The rank and count can be omitted to indicate a default inherited from the environment or device configuration at runtime.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, Stream_AffinityOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_4","title":"Attributes:","text":"Attribute MLIR Type Description <code>group</code> ::mlir::StringAttr string attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_4","title":"Operands:","text":"Operand Description <code>id</code> a reference counted byte buffer <code>rank</code> index <code>count</code> index"},{"location":"reference/mlir-dialects/Stream/#results_4","title":"Results:","text":"Result Description <code>result</code> a collective communication channel"},{"location":"reference/mlir-dialects/Stream/#streamchannelrank-streamchannelrankop","title":"<code>stream.channel.rank</code> (Stream::ChannelRankOp)","text":"<p>Returns the rank of the local participant in the group</p> <p>Syntax:</p> <pre><code>operation ::= `stream.channel.rank` $channel `:` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the rank the channel represents as a participant in a collective group in <code>[0, count)</code>.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#operands_5","title":"Operands:","text":"Operand Description <code>channel</code> a collective communication channel"},{"location":"reference/mlir-dialects/Stream/#results_5","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/Stream/#streamchannelsplit-streamchannelsplitop","title":"<code>stream.channel.split</code> (Stream::ChannelSplitOp)","text":"<p>Splits a collective communication channel</p> <p>Syntax:</p> <pre><code>operation ::= `stream.channel.split` $channel `,` $color `,` $key\n              `:` type($channel) `-&gt;` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Partitions the group associated with the given channel into disjoint subgroups for each unique value of color. Each new subgroup contains all participants of the same color and within each subgroup the key argument is used to define the rank order. When multiple participants in a group use the same key the tie will be broken using their rank in the parent group. A color of -1 indicates that the rank does not participate in any subgroup and will return a null channel.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#operands_6","title":"Operands:","text":"Operand Description <code>channel</code> a collective communication channel <code>color</code> index <code>key</code> index"},{"location":"reference/mlir-dialects/Stream/#results_6","title":"Results:","text":"Result Description <code>result</code> a collective communication channel"},{"location":"reference/mlir-dialects/Stream/#executable-ops","title":"Executable ops","text":""},{"location":"reference/mlir-dialects/Stream/#streambindingsubspan-streambindingsubspanop","title":"<code>stream.binding.subspan</code> (Stream::BindingSubspanOp)","text":"<p>Returns an alias to a subspan of interface binding data</p> <p>Syntax:</p> <pre><code>operation ::= `stream.binding.subspan` $binding `` `[` $byte_offset `]`\n              attr-dict `:` type($binding) `-&gt;` type($result) (`{` $dynamic_dims^ `}`)?\n</code></pre> <p>Returns a subview to a tensor or memref-like type from a binding. The same binding may have multiple subviews at different byte offsets.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#operands_7","title":"Operands:","text":"Operand Description <code>binding</code> a managed resource binding into an executable scope <code>byte_offset</code> index <code>dynamic_dims</code> index"},{"location":"reference/mlir-dialects/Stream/#results_7","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/Stream/#streamexecutableend-streamexecutableendop","title":"<code>stream.executable.end</code> (Stream::ExecutableEndOp)","text":"<p>Terminator pseudo-op for the executable op</p> <p>Syntax:</p> <pre><code>operation ::= `stream.executable.end` attr-dict\n</code></pre> <p>Traits: HasParent, Terminator"},{"location":"reference/mlir-dialects/Stream/#streamexecutableexport-streamexecutableexportop","title":"<code>stream.executable.export</code> (Stream::ExecutableExportOp)","text":"<p>Defines an executable entry point for dispatch operations</p> <p>Syntax:</p> <pre><code>operation ::= `stream.executable.export` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              custom&lt;SymbolAlias&gt;($sym_name, $function_ref)\n              custom&lt;WorkgroupCountRegion&gt;($workgroup_count)\n              attr-dict-with-keyword\n</code></pre> <p>Specifies an exported function with an externally-visible alias. Multiple exports can reference the same internal function.</p> <p>Each entry point can have a unique workgroup count calculation region. This region takes the workload parameters passed to each flow.dispatch and produces an XYZ workgroup count for the 3D grid dispatch.</p> <p>Traits: HasParent, IsolatedFromAbove <p>Interfaces: Symbol</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_5","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>function_ref</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute"},{"location":"reference/mlir-dialects/Stream/#streamexecutable-streamexecutableop","title":"<code>stream.executable</code> (Stream::ExecutableOp)","text":"<p>Generic executable module</p> <p>Syntax:</p> <pre><code>operation ::= `stream.executable` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              $sym_name\n              attr-dict-with-keyword\n              regions\n</code></pre> <p>An executable module containing one or more public functions. The contents of the functions are safe to dispatch and can be lowered further to target-specific backend IR representations.</p> <p>Traits: IsolatedFromAbove, SingleBlockImplicitTerminator, SymbolTable <p>Interfaces: Symbol</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_6","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/Stream/#explicit-command-ops","title":"Explicit command ops","text":""},{"location":"reference/mlir-dialects/Stream/#streamcmdcall-streamcmdcallop","title":"<code>stream.cmd.call</code> (Stream::CmdCallOp)","text":"<p>Calls a streamable external host function</p> <p>Syntax:</p> <pre><code>operation ::= `stream.cmd.call` $callee ``\n              custom&lt;CmdCallOperands&gt;($resource_operands,\n              $resource_operand_offsets,\n              $resource_operand_lengths,\n              $resource_operand_accesses) attr-dict `:`\n              custom&lt;ShapedFunctionType&gt;(ref($resource_operands),\n              type($resource_operands),\n              $resource_operand_sizes,\n              type($results),\n              $result_sizes,\n              $tied_operands)\n</code></pre> <p>Calls a function operating on resource values with stream semantics. Asynchronous calls must have no side-effects.</p> <p>Traits: AttrSizedOperandSegments, Stream_CmdPhaseOp</p> <p>Interfaces: CallOpInterface, Stream_StreamableOp, Stream_SubviewEffectOp, SymbolUserOpInterface, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_7","title":"Attributes:","text":"Attribute MLIR Type Description <code>callee</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute <code>resource_operand_accesses</code> ::mlir::ArrayAttr access array attribute"},{"location":"reference/mlir-dialects/Stream/#operands_8","title":"Operands:","text":"Operand Description <code>resource_operands</code> index or integer or floating-point or complex-type or resource or external resource or transient resource or variable resource or constant resource or any type <code>resource_operand_sizes</code> index <code>resource_operand_offsets</code> index <code>resource_operand_lengths</code> index <code>result_sizes</code> index"},{"location":"reference/mlir-dialects/Stream/#results_8","title":"Results:","text":"Result Description <code>results</code> index or integer or floating-point or complex-type"},{"location":"reference/mlir-dialects/Stream/#streamcmdcollective-streamcmdcollectiveop","title":"<code>stream.cmd.collective</code> (Stream::CmdCollectiveOp)","text":"<p>Dispatches a collective operation</p> <p>Syntax:</p> <pre><code>operation ::= `stream.cmd.collective` `` $op `` `[` $element_count `]`\n              `channel` `(` $channel `)`\n              (`param` `(` $param^ `:` type($param) `)`)? `{`\n              custom&lt;DispatchResources&gt;($resources, type($resources), $resource_sizes,\n              $resource_offsets, $resource_lengths,\n              $resource_accesses)\n              `\\n` `}`\n              attr-dict-with-keyword\n</code></pre> <p>Dispatches a collective operation specified against the device. If grouped with other collectives in a <code>stream.cmd.concurrent</code> region the collective operations may fuse and execute more efficiently.</p> <p>Traits: AttrSizedOperandSegments, Stream_CmdPhaseOp</p> <p>Interfaces: Stream_StreamableOp, Stream_SubviewEffectOp, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_8","title":"Attributes:","text":"Attribute MLIR Type Description <code>op</code> ::mlir::iree_compiler::IREE::Stream::CollectiveAttr collective operation and specification <code>resource_accesses</code> ::mlir::ArrayAttr access array attribute"},{"location":"reference/mlir-dialects/Stream/#operands_9","title":"Operands:","text":"Operand Description <code>channel</code> a collective communication channel <code>element_count</code> index <code>param</code> 32-bit signless integer <code>resources</code> resource or external resource or transient resource or variable resource or constant resource <code>resource_sizes</code> index <code>resource_offsets</code> index <code>resource_lengths</code> index"},{"location":"reference/mlir-dialects/Stream/#streamcmdconcurrent-streamcmdconcurrentop","title":"<code>stream.cmd.concurrent</code> (Stream::CmdConcurrentOp)","text":"<p>Executes all ops concurrently</p> <p>Syntax:</p> <pre><code>operation ::= `stream.cmd.concurrent` $body\n              attr-dict-with-keyword\n</code></pre> <p>Represents a wave of work scheduled concurrently (each op executing at the same time).</p> <p>Waves can be nested to create a DAG. For example, take the following graph: <pre><code>                  |\n        v---------+---------v\n+-------|-------+   +-------|-------+\n|    v--+--v    |   |    v--+--v    |\n| +----+ +----+ |   | +----+ +----+ |\n| | @a | | @b | |   | | @c | | @d | |\n| +----+ +----+ |   | +----+ +----+ |\n|    +--v--+    |   |    +--v--+    |\n+-------|-------+   +-------|-------+\n        +---------v---------+\n                  |\n</code></pre></p> <p>Represented with nested waves: <pre><code>  stream.cmd.concurrent {\n    stream.cmd.concurrent {\n      stream.cmd.dispatch @a\n      stream.cmd.dispatch @b\n    }\n    stream.cmd.concurrent {\n      stream.cmd.dispatch @c\n      stream.cmd.dispatch @d\n    }\n  }\n</code></pre></p> <p>Traits: HasParent, RecursiveMemoryEffects, SingleBlockImplicitTerminator, Stream_CmdPhaseOp <p>Interfaces: RegionBranchOpInterface, Stream_StreamableOp</p>"},{"location":"reference/mlir-dialects/Stream/#streamcmdcopy-streamcmdcopyop","title":"<code>stream.cmd.copy</code> (Stream::CmdCopyOp)","text":"<p>Copies a subview of a stream resource to another</p> <p>Syntax:</p> <pre><code>operation ::= `stream.cmd.copy` $source `[` $source_offset `]` `,`\n              $target `[` $target_offset `]` `,`\n              $length `:`\n              type($source) `` `{` $source_size `}` `-&gt;`\n              type($target) `` `{` $target_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Copies a subview of a resource into a subview of another. As with memcpy this does not support overlapping updates into the same resource.</p> <p>Traits: Stream_CmdPhaseOp</p> <p>Interfaces: Stream_StreamableOp, Stream_SubviewEffectOp, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#operands_10","title":"Operands:","text":"Operand Description <code>source</code> any stream-compatible type <code>source_size</code> index <code>source_offset</code> index <code>target</code> any stream-compatible type <code>target_size</code> index <code>target_offset</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/Stream/#streamcmddiscard-streamcmddiscardop","title":"<code>stream.cmd.discard</code> (Stream::CmdDiscardOp)","text":"<p>Discards a subview of a resource</p> <p>Syntax:</p> <pre><code>operation ::= `stream.cmd.discard` $target `[` $target_offset `for` $target_length `]` `:`\n              type($target) `` `{` $target_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Discards a subview of a resource, indicating that after this command the specified contents are no longer needed. This can be used to trim memory or invalidate caches.</p> <p>Traits: Stream_CmdPhaseOp</p> <p>Interfaces: Stream_StreamableOp, Stream_SubviewEffectOp, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#operands_11","title":"Operands:","text":"Operand Description <code>target</code> any stream-compatible type <code>target_size</code> index <code>target_offset</code> index <code>target_length</code> index"},{"location":"reference/mlir-dialects/Stream/#streamcmddispatch-streamcmddispatchop","title":"<code>stream.cmd.dispatch</code> (Stream::CmdDispatchOp)","text":"<p>Dispatches a parallelized grid of work</p> <p>Syntax:</p> <pre><code>operation ::= `stream.cmd.dispatch` custom&lt;DispatchEntryPoints&gt;($entry_points)\n              (`[` $workload^ `]`)? ``\n              (`(` $uniform_operands^ `:` type($uniform_operands) `)`)? `{`\n              custom&lt;DispatchResources&gt;($resources, type($resources), $resource_sizes,\n              $resource_offsets, $resource_lengths,\n              $resource_accesses)\n              `\\n` `}`\n              attr-dict-with-keyword\n</code></pre> <p>Calls the specified entry point function once for each element in the specified workgroup count. Each workgroup has access to the same operands and results and is able to load/store at will.</p> <p>Traits: AttrSizedOperandSegments, Stream_CmdPhaseOp</p> <p>Interfaces: Stream_StreamableOp, Stream_SubviewEffectOp, SymbolUserOpInterface, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_9","title":"Attributes:","text":"Attribute MLIR Type Description <code>entry_points</code> ::mlir::ArrayAttr symbol ref array attribute <code>resource_accesses</code> ::mlir::ArrayAttr access array attribute"},{"location":"reference/mlir-dialects/Stream/#operands_12","title":"Operands:","text":"Operand Description <code>workload</code> index <code>uniform_operands</code> index or integer or floating-point or complex-type <code>resources</code> resource or external resource or transient resource or variable resource or constant resource <code>resource_sizes</code> index <code>resource_offsets</code> index <code>resource_lengths</code> index"},{"location":"reference/mlir-dialects/Stream/#streamcmdexecute-streamcmdexecuteop","title":"<code>stream.cmd.execute</code> (Stream::CmdExecuteOp)","text":"<p>Executes a dependency-aware sequence of streamable ops</p> <p>Syntax:</p> <pre><code>operation ::= `stream.cmd.execute` (`on` `(` $affinity^ `)`)?\n              (`await` `(` $await_timepoint^ `)` `=` `` `&gt;`)?\n              `with` ``\n              custom&lt;ExplicitResourceRegion&gt;($resource_operands,\n              type($resource_operands), $resource_operand_sizes,\n              $body)\n              `=` `` `&gt;` type($result_timepoint)\n              attr-dict-with-keyword\n</code></pre> <p>Evaluates the operations within the region by dependency order while obeying ties when present. Nested ops execute serially in block order and nested <code>stream.cmd.concurrent</code> ops can be used to run multiple ops concurrently within the stream. All resource inputs must be captured explicitly. All results are only ready once all nested ops complete execution and the returned timepoint is reached. Zero or more timepoints may be provided to block execution until they are all reached; zero timepoints indicates that execution may begin immediately.</p> <p>Traits: AttrSizedOperandSegments, RecursiveMemoryEffects, SingleBlockImplicitTerminator, Stream_CmdPhaseOp <p>Interfaces: ClosureOpInterface, InferTypeOpInterface, RegionBranchOpInterface, Stream_AffinityOp, Stream_TimelineOp, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_10","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_13","title":"Operands:","text":"Operand Description <code>resource_operands</code> resource or external resource or transient resource or variable resource or constant resource or staging resource <code>resource_operand_sizes</code> index <code>await_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#results_9","title":"Results:","text":"Result Description <code>result_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#streamcmdfill-streamcmdfillop","title":"<code>stream.cmd.fill</code> (Stream::CmdFillOp)","text":"<p>Fills a subview of a stream resource with a value</p> <p>Syntax:</p> <pre><code>operation ::= `stream.cmd.fill` $value `,`\n              $target `[` $target_offset `for` $target_length `]` `:`\n              type($value) `-&gt;`\n              type($target) `` `{` $target_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Splats a value into a subview of the given stream resource and returns the resource with the update applied.</p> <p>Traits: Stream_CmdPhaseOp</p> <p>Interfaces: Stream_StreamableOp, Stream_SubviewEffectOp, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#operands_14","title":"Operands:","text":"Operand Description <code>target</code> resource or external resource or transient resource or variable resource or constant resource <code>target_size</code> index <code>target_offset</code> index <code>target_length</code> index <code>value</code> 8-bit signless integer or 16-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/Stream/#streamcmdflush-streamcmdflushop","title":"<code>stream.cmd.flush</code> (Stream::CmdFlushOp)","text":"<p>Flushes a subview of a resource</p> <p>Syntax:</p> <pre><code>operation ::= `stream.cmd.flush` (`to` `(` $source_affinity^ `)`)?\n              $target `[` $target_offset `for` $target_length `]` `:`\n              type($target) `` `{` $target_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Transfers a resource to an external target. The resource memory is made available to the target and can be made visible there using <code>stream.cmd.invalidate</code>.</p> <p>Traits: Stream_CmdPhaseOp</p> <p>Interfaces: Stream_StreamableOp, Stream_SubviewEffectOp, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_11","title":"Attributes:","text":"Attribute MLIR Type Description <code>source_affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_15","title":"Operands:","text":"Operand Description <code>target</code> any stream-compatible type <code>target_size</code> index <code>target_offset</code> index <code>target_length</code> index"},{"location":"reference/mlir-dialects/Stream/#streamcmdfunc-streamcmdfuncop","title":"<code>stream.cmd.func</code> (Stream::CmdFuncOp)","text":"<p>Streamable function declaration</p> <p>Syntax:</p> <pre><code>operation ::= `stream.cmd.func` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              $sym_name ``\n              custom&lt;DispatchFunctionSignature&gt;($function_type,\n              $arg_attrs,\n              $res_attrs)\n              attr-dict-with-keyword\n              ($body^)?\n</code></pre> <p>Declares a function that can be called as an asynchronous streaming operation via <code>stream.cmd.call</code>. Today only external functions are allowed.</p> <p>Traits: IsolatedFromAbove, Stream_CmdPhaseOp</p> <p>Interfaces: CallableOpInterface, FunctionOpInterface, Symbol</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_12","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_name</code> ::mlir::StringAttr string attribute <code>function_type</code> ::mlir::TypeAttr type attribute of function type <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>arg_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes <code>res_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes"},{"location":"reference/mlir-dialects/Stream/#streamcmdinvalidate-streamcmdinvalidateop","title":"<code>stream.cmd.invalidate</code> (Stream::CmdInvalidateOp)","text":"<p>Invalidates a subview of a resource</p> <p>Syntax:</p> <pre><code>operation ::= `stream.cmd.invalidate` (`from` `(` $source_affinity^ `)`)?\n              $target `[` $target_offset `for` $target_length `]` `:`\n              type($target) `` `{` $target_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Transfers a resource from an external source into the current target. The resource memory is assumed to have been made available at the source via <code>stream.cmd.flush</code>.</p> <p>Traits: Stream_CmdPhaseOp</p> <p>Interfaces: Stream_StreamableOp, Stream_SubviewEffectOp, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_13","title":"Attributes:","text":"Attribute MLIR Type Description <code>source_affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_16","title":"Operands:","text":"Operand Description <code>target</code> any stream-compatible type <code>target_size</code> index <code>target_offset</code> index <code>target_length</code> index"},{"location":"reference/mlir-dialects/Stream/#streamcmdserial-streamcmdserialop","title":"<code>stream.cmd.serial</code> (Stream::CmdSerialOp)","text":"<p>Executes all ops serially (in-order)</p> <p>Syntax:</p> <pre><code>operation ::= `stream.cmd.serial` $body\n              attr-dict-with-keyword\n</code></pre> <p>Represents a sequence of work scheduled serially (each op executing one after the other).</p> <p>Regions can be nested to create a DAG. For example, take the following graph: <pre><code>                  |\n        v---------+-----v\n+-------|-------+   +---|----+\n|    v--+--v    |   |   v    |\n| +----+ +----+ |   | +----+ |\n| | @a | | @b | |   | | @c | |\n| +----+ +----+ |   | +----+ |\n|    |     |    |   |   |    |\n|    |     |    |   | +-v--+ |\n|    |     |    |   | | @d | |\n|    |     |    |   | +----+ |\n|    +--v--+    |   |   |    |\n+-------|-------+   +---|----+\n        +---------v-----+\n                  |\n</code></pre></p> <p>Represented with nested regions: <pre><code>  stream.cmd.concurrent {\n    stream.cmd.concurrent {\n      stream.cmd.dispatch @a\n      stream.cmd.dispatch @b\n    }\n    stream.cmd.serial {\n      stream.cmd.dispatch @c\n      stream.cmd.dispatch @d\n    }\n  }\n</code></pre></p> <p>Traits: HasParent, RecursiveMemoryEffects, SingleBlockImplicitTerminator, Stream_CmdPhaseOp <p>Interfaces: RegionBranchOpInterface, Stream_StreamableOp</p>"},{"location":"reference/mlir-dialects/Stream/#miscellaneous-ops","title":"Miscellaneous ops","text":""},{"location":"reference/mlir-dialects/Stream/#streamreturn-streamreturnop","title":"<code>stream.return</code> (Stream::ReturnOp)","text":"<p>Returns results from a region</p> <p>Syntax:</p> <pre><code>operation ::= `stream.return` attr-dict\n              $operands `:` type($operands)\n</code></pre> <p>The values returned are copied by-value.</p> <p>Traits: AlwaysSpeculatableImplTrait, HasParent, ReturnLike, Terminator <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), RegionBranchTerminatorOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#operands_17","title":"Operands:","text":"Operand Description <code>operands</code> any type"},{"location":"reference/mlir-dialects/Stream/#streamyield-streamyieldop","title":"<code>stream.yield</code> (Stream::YieldOp)","text":"<p>Yields stream values from an execution region</p> <p>Syntax:</p> <pre><code>operation ::= `stream.yield` attr-dict\n              ($resource_operands^ `:`\n              custom&lt;SizeAwareTypeList&gt;(type($resource_operands),\n              $resource_operand_sizes))?\n</code></pre> <p>The values returned represent the asynchronous value at the point in time the SSA value is defined (or tied).</p> <p>Traits: AlwaysSpeculatableImplTrait, HasParent, ReturnLike, SameVariadicOperandSize, Terminator <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), RegionBranchTerminatorOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#operands_18","title":"Operands:","text":"Operand Description <code>resource_operands</code> resource or external resource or transient resource or variable resource or constant resource or staging resource <code>resource_operand_sizes</code> index"},{"location":"reference/mlir-dialects/Stream/#pseudo-ops","title":"Pseudo Ops","text":"<p>Pseudo ops for conversion support.</p>"},{"location":"reference/mlir-dialects/Stream/#streamtensorexport-streamtensorexportop","title":"<code>stream.tensor.export</code> (Stream::TensorExportOp)","text":"<p>Conversion placeholder for stream-&gt;other type conversion</p> <p>Syntax:</p> <pre><code>operation ::= `stream.tensor.export` (`on` `(` $affinity^ `)`)?\n              $source `:`\n              $source_encoding (`` `{` $source_encoding_dims^ `}`)?\n              `in`\n              type($source) `` `{` $source_size `}`\n              `-&gt;`\n              type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Defines a conversion to a higher-level dialect type such as <code>tensor</code> that is resolved during lowering into the stream dialect. This can be used to interoperate between levels of the stack that require specifying stream types and those that prior to lowering do not handle them.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp, TiedOpInterface, Util_ShapeAwareOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_14","title":"Attributes:","text":"Attribute MLIR Type Description <code>source_encoding</code> ::mlir::TypeAttr any type attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_19","title":"Operands:","text":"Operand Description <code>source</code> external resource <code>source_encoding_dims</code> index <code>source_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_10","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/Stream/#streamtensorimport-streamtensorimportop","title":"<code>stream.tensor.import</code> (Stream::TensorImportOp)","text":"<p>Conversion placeholder for other-&gt;stream type conversion</p> <p>Syntax:</p> <pre><code>operation ::= `stream.tensor.import` (`on` `(` $affinity^ `)`)?\n              $source `:`\n              type($source)\n              `-&gt;`\n              $result_encoding (`` `{` $result_encoding_dims^ `}`)?\n              `in`\n              type($result) `{` $result_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Defines a conversion from a higher-level dialect type such as <code>tensor</code> that is resolved during lowering into the stream dialect. This can be used to interoperate between levels of the stack that require specifying stream types and those that prior to lowering do not handle them.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp, TiedOpInterface, Util_ShapeAwareOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_15","title":"Attributes:","text":"Attribute MLIR Type Description <code>result_encoding</code> ::mlir::TypeAttr any type attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_20","title":"Operands:","text":"Operand Description <code>source</code> any type <code>result_encoding_dims</code> index <code>result_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_11","title":"Results:","text":"Result Description <code>result</code> external resource"},{"location":"reference/mlir-dialects/Stream/#resource-ops","title":"Resource ops","text":"<p>Generic resource ops.</p>"},{"location":"reference/mlir-dialects/Stream/#streamresourcealloc-streamresourceallocop","title":"<code>stream.resource.alloc</code> (Stream::ResourceAllocOp)","text":"<p>Allocates a persistent value with undefined contents</p> <p>Syntax:</p> <pre><code>operation ::= `stream.resource.alloc` (`on` `(` $affinity^ `)`)?\n              (`uninitialized` $uninitialized^)?\n              attr-dict `:` custom&lt;SizeAwareTypeList&gt;(type($results), $storage_sizes)\n</code></pre> <p>Allocates a persistent value (one that is long-lived and possibly external to the program) with undefined contents. Consumers of the allocated result must assume nothing of the contents and use <code>discard</code> access.</p> <p>Uninitialized allocations will have undefined contents and must only be used when all bytes are discarded prior to any reads. Runtimes decide what \"undefined contents\" means and here it only indicates that execution will be correct even if the memory starts with non-zero values.</p> <p>If multiple values are allocated from the same operation it implies that they have matching lifetimes. When lowering to execution environments the separate allocations may be fused into one or more slab allocations in order to reduce overheads. How many allocations can be fused is based on the size of the individual resources and the target constraints (how large any single buffer may be, etc). At the stream dialect level treat a multi-result alloc as a way to indicate similar lifetimes.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: AffinityOpInterface, ConditionallySpeculatable, MemoryEffectOpInterface (MemoryEffectOpInterface), Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_16","title":"Attributes:","text":"Attribute MLIR Type Description <code>uninitialized</code> ::mlir::UnitAttr unit attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_21","title":"Operands:","text":"Operand Description <code>storage_sizes</code> index"},{"location":"reference/mlir-dialects/Stream/#results_12","title":"Results:","text":"Result Description <code>results</code> any stream-compatible type"},{"location":"reference/mlir-dialects/Stream/#streamresourcealloca-streamresourceallocaop","title":"<code>stream.resource.alloca</code> (Stream::ResourceAllocaOp)","text":"<p>Allocates a transient value with undefined contents</p> <p>Syntax:</p> <pre><code>operation ::= `stream.resource.alloca` `uninitialized`\n              (`on` `(` $affinity^ `)`)?\n              (`await` `(` $await_timepoint^ `)` `=` `` `&gt;`):(`:`)?\n              attr-dict\n              type($result) `{` $storage_size `}`\n              `=` `` `&gt;`\n              type($result_timepoint)\n</code></pre> <p>Allocates a transient value (one that is short-lived and local to the current computation) with undefined contents. Consumers of the allocated result must assume nothing of the contents and use <code>discard</code> access.</p> <p>The resource returned is not valid for use until the timepoint is reached; execution using this resource must await on the timepoint.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: AffinityOpInterface, ConditionallySpeculatable, MemoryEffectOpInterface (MemoryEffectOpInterface), Stream_TimelineOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_17","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_22","title":"Operands:","text":"Operand Description <code>storage_size</code> index <code>await_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#results_13","title":"Results:","text":"Result Description <code>result</code> staging resource or transient resource <code>result_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#streamresourceconstants-streamresourceconstantsop","title":"<code>stream.resource.constants</code> (Stream::ResourceConstantsOp)","text":"<p>Asynchronously uploads or maps constant values</p> <p>Syntax:</p> <pre><code>operation ::= `stream.resource.constants` (`on` `(` $affinity^ `)`)?\n              attr-dict `:`\n              custom&lt;ConstantValueList&gt;(type($results),\n              $result_sizes,\n              $values)\n              `\\n` ` ` ` ` `=` `` `&gt;` type($result_timepoint)\n</code></pre> <p>Represents an upload of constant resources that may be packed, suballocated, and mapped depending on the final lowering target.</p> <p>In runtime environments where memory is shared between host and device this turns into a mapping operation that avoids additional memory allocation and copies. When memory cannot be shared an asynchronous stream will be created to allocate and copy all of the constant values.</p> <p>Though this op returns a unique resource for each constant value it's expected that almost all end up aliasing into the same storage. The exact packing and number of storage resources that are needed are not known until lowering to a particular backend, though, so they are separate here for proper usage tracking.</p> <p>Both constant and variable resources can be produced; a constant is immutable while a variable will be treated as a constant-value initializer for a mutable resource. By modeling these together it's not required that variable initializers first be allocated, copied to the target, and then copied into the variable storage if the target is capable of doing a direct upload or mapping.</p> <p>Traits: AlwaysSpeculatableImplTrait, SameVariadicResultSize</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp, Stream_TimelineOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_18","title":"Attributes:","text":"Attribute MLIR Type Description <code>values</code> ::mlir::ArrayAttr constant value array attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_23","title":"Operands:","text":"Operand Description <code>result_sizes</code> index"},{"location":"reference/mlir-dialects/Stream/#results_14","title":"Results:","text":"Result Description <code>results</code> constant resource or variable resource <code>result_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#streamresourcedealloca-streamresourcedeallocaop","title":"<code>stream.resource.dealloca</code> (Stream::ResourceDeallocaOp)","text":"<p>Frees a transient value when available</p> <p>Syntax:</p> <pre><code>operation ::= `stream.resource.dealloca` (`on` `(` $affinity^ `)`)?\n              (`await` `(` $await_timepoint^ `)` `=` `` `&gt;`)?\n              $operand `:` type($operand) `{` $operand_size `}`\n              `=` `` `&gt;` type($result_timepoint)\n              attr-dict\n</code></pre> <p>Deallocates a transient value (one that is short-lived and local to the current computation) previously allocated using <code>stream.resource.alloca</code>.</p> <p>The resource is considered live and valid until the provided timepoint is reached and the memory is only made available for future requests after the result timepoint is reached.</p> <p>Interfaces: AffinityOpInterface, InferTypeOpInterface, MemoryEffectOpInterface (MemoryEffectOpInterface), Stream_TimelineOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Free on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_19","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_24","title":"Operands:","text":"Operand Description <code>operand</code> staging resource or transient resource <code>operand_size</code> index <code>await_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#results_15","title":"Results:","text":"Result Description <code>result_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#streamresourceload-streamresourceloadop","title":"<code>stream.resource.load</code> (Stream::ResourceLoadOp)","text":"<p>Loads a value from a staging resource</p> <p>Syntax:</p> <pre><code>operation ::= `stream.resource.load` $source `[` $source_offset `]` `:`\n              type($source) `` `{` $source_size `}`\n              `-&gt;`\n              type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the element(s) at the given offset in the staging resource. The operation will complete synchronously against the resource though it may introduce a yield point if the staging resource needs to be transferred.</p> <p>Interfaces: Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#operands_25","title":"Operands:","text":"Operand Description <code>source</code> staging resource <code>source_size</code> index <code>source_offset</code> index"},{"location":"reference/mlir-dialects/Stream/#results_16","title":"Results:","text":"Result Description <code>result</code> index or integer or floating-point or complex-type or vector of any type values"},{"location":"reference/mlir-dialects/Stream/#streamresourcemap-streamresourcemapop","title":"<code>stream.resource.map</code> (Stream::ResourceMapOp)","text":"<p>Maps read-only memory into a staging resource</p> <p>Syntax:</p> <pre><code>operation ::= `stream.resource.map` (`on` `(` $affinity^ `)`)?\n              $source `[` $source_offset `]` `:`\n              type($source)\n              `-&gt;`\n              type($result) `` `{` $result_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Synchronously maps a host heap buffer into a stream-accessible staging resource. Will never fail but may induce a copy if required and as such the mapped resource is not coherent with the original source buffer: changing the source buffer after mapping has undefined behavior.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), Stream_AffinityOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_20","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_26","title":"Operands:","text":"Operand Description <code>source</code> a reference counted byte buffer <code>source_offset</code> index <code>result_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_17","title":"Results:","text":"Result Description <code>result</code> staging resource"},{"location":"reference/mlir-dialects/Stream/#streamresourcepack-streamresourcepackop","title":"<code>stream.resource.pack</code> (Stream::ResourcePackOp)","text":"<p>Packs variable-sized slices into a single slab</p> <p>Syntax:</p> <pre><code>operation ::= `stream.resource.pack` (`on` `(` $affinity^ `)`)?\n              (`offset` `(` $offset^ `)`)?\n              `slices` `(` `{`\n              custom&lt;PackSliceRanges&gt;($lifetime_intervals,\n              $dynamic_slice_sizes,\n              type($packed_offsets))\n              `}` `)`\n              `:` type($total_length)\n              attr-dict-with-keyword\n</code></pre> <p>Performs a greedy packing of one or more sized slices with specified lifetimes and returns their relative offsets in an aliased linear space.</p> <p>Slices are <code>[start, end] = %slice_byte_size</code>, where the start and end values define an inclusive lifetime range and the size is the total number of bytes required to be live for that range.</p> <pre><code>// Computes the total length required for the packed values and the offsets\n// of the 3 slices requested relative to the base of the packed memory:\n%total_length, %offset_0, %offset_1, %offset_2 =\n    stream.resource.pack\n        // Each slice gets one result offset:\n        slices({\n          // 3 slices where A and B overlap and will get unique offsets\n          // while B and C do not overlap and are allowed to alias.\n          [0, 10] = %size_0,  // A =&gt; %offset_0\n          [3,  8] = %size_1,  // B =&gt; %offset_1\n          [9, 10] = %size_2,  // C =&gt; %offset_2\n          ...\n        }) : index\n</code></pre> <p>The lifetime start and end points (inclusive) are only used for relative comparisons and may originate with any meaning (op order in block, epoch, phase of the moon, etc). The packing algorithm uses the intervals to determine slice liveness and when aliasing is safe.</p> <p>The size of each slice may either be a constant or runtime-computed dynamic value. Constant slices can achieve more dense packing than the dynamic values and CSE/canonicalization should be applied to ensure that as many of the dynamic values are equivalent if possible.</p> <p>The total length required to pack all slices is returned and can be used to acquire storage. The individual slice offsets are 0-based and as such if are directly used as buffer offsets may need additional offsetting. This can either be applied via the optional <code>offset</code> operand or slicing of the underlying allocation buffer.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, Stream_AffinityOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_21","title":"Attributes:","text":"Attribute MLIR Type Description <code>lifetime_intervals</code> ::mlir::ArrayAttr index array attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_27","title":"Operands:","text":"Operand Description <code>offset</code> index <code>dynamic_slice_sizes</code> index"},{"location":"reference/mlir-dialects/Stream/#results_18","title":"Results:","text":"Result Description <code>total_length</code> index <code>packed_offsets</code> index"},{"location":"reference/mlir-dialects/Stream/#streamresourcesize-streamresourcesizeop","title":"<code>stream.resource.size</code> (Stream::ResourceSizeOp)","text":"<p>Returns the size of the resource storage in bytes</p> <p>Syntax:</p> <pre><code>operation ::= `stream.resource.size` (`on` `(` $affinity^ `)`)?\n              $operand\n              attr-dict `:` type($operand)\n</code></pre> <p>Returns a possibly runtime-dynamic byte size of the resource backing storage. This may differ from the logical storage size of a value based on the alignment requirements of the target as well as encoding of higher level values such as sparse tensor formats.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_22","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_28","title":"Operands:","text":"Operand Description <code>operand</code> any stream-compatible type"},{"location":"reference/mlir-dialects/Stream/#results_19","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/Stream/#streamresourcestore-streamresourcestoreop","title":"<code>stream.resource.store</code> (Stream::ResourceStoreOp)","text":"<p>Stores a value into a staging resource</p> <p>Syntax:</p> <pre><code>operation ::= `stream.resource.store` $value `,`\n              $target `[` $target_offset `]` `:`\n              type($value)\n              `-&gt;`\n              type($target) `{` $target_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>The operation will complete synchronously against the resource though it may introduce a yield point if the staging resource needs to be acquired.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Stream/#operands_29","title":"Operands:","text":"Operand Description <code>target</code> staging resource <code>target_size</code> index <code>target_offset</code> index <code>value</code> index or integer or floating-point or complex-type or vector of any type values"},{"location":"reference/mlir-dialects/Stream/#streamresourcesubview-streamresourcesubviewop","title":"<code>stream.resource.subview</code> (Stream::ResourceSubviewOp)","text":"<p>Slices out a cloned subview of a value</p> <p>Syntax:</p> <pre><code>operation ::= `stream.resource.subview` $source `[` $source_offset `]` `:`\n              type($source) `` `{` $source_size `}` `-&gt;`\n              type($result) `` `{` $result_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Aliases a byte subrange of a resource.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), StreamableOpInterface, TiedOpInterface, Util_SizeAwareOp, Util_SubrangeOp, ViewLikeOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#operands_30","title":"Operands:","text":"Operand Description <code>source</code> any stream-compatible type <code>source_size</code> index <code>source_offset</code> index <code>result_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_20","title":"Results:","text":"Result Description <code>result</code> any stream-compatible type"},{"location":"reference/mlir-dialects/Stream/#streamresourcetry_map-streamresourcetrymapop","title":"<code>stream.resource.try_map</code> (Stream::ResourceTryMapOp)","text":"<p>Maps read-only memory into a resource</p> <p>Syntax:</p> <pre><code>operation ::= `stream.resource.try_map` (`on` `(` $affinity^ `)`)?\n              $source `[` $source_offset `]` `:`\n              type($source)\n              `-&gt;`\n              type($did_map) `,` type($result) `` `{` $result_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Synchronously maps a host heap buffer into a stream-accessible resource with constant lifetime. If the given source cannot be mapped into a constant a failure is returned and the resulting resource value is null. As with <code>stream.resource.map</code> the resulting resource is not coherent with the source and changes will not be reflected.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, MemoryEffectOpInterface (MemoryEffectOpInterface), NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}, MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_23","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_31","title":"Operands:","text":"Operand Description <code>source</code> a reference counted byte buffer <code>source_offset</code> index <code>result_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_21","title":"Results:","text":"Result Description <code>did_map</code> 1-bit signless integer <code>result</code> constant resource"},{"location":"reference/mlir-dialects/Stream/#resource-transfer-ops","title":"Resource transfer ops","text":""},{"location":"reference/mlir-dialects/Stream/#streamasyncalloca-streamasyncallocaop","title":"<code>stream.async.alloca</code> (Stream::AsyncAllocaOp)","text":"<p>Allocates a transient value with undefined contents</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.alloca` (`on` `(` $affinity^ `)`)?\n              attr-dict `:` type($result) `{` $storage_size `}`\n</code></pre> <p>Allocates a transient value (one that is short-lived and local to the current computation) with undefined contents. Consumers of the allocated result must assume nothing of the contents and use <code>discard</code> access.</p> <p>Traits: AlwaysSpeculatableImplTrait, Stream_AsyncPhaseOp</p> <p>Interfaces: AffinityOpInterface, ConditionallySpeculatable, MemoryEffectOpInterface (MemoryEffectOpInterface), StreamableOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_24","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_32","title":"Operands:","text":"Operand Description <code>storage_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_22","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamasyncclone-streamasynccloneop","title":"<code>stream.async.clone</code> (Stream::AsyncCloneOp)","text":"<p>Clones the contents of a value</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.clone` (`on` `(` $affinity^ `)`)?\n              $source `:`\n              type($source) `` `{` $source_size `}` `-&gt;`\n              type($result) `` `{` $result_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Clones the contents of a value at a snapshot in time. Future changes to the cloned value will not effect the result. Acts as a copy-on-write operation.</p> <p>Traits: Stream_AsyncPhaseOp</p> <p>Interfaces: AsyncAccessOpInterface, Stream_AffinityOp, StreamableOpInterface, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_25","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_33","title":"Operands:","text":"Operand Description <code>source</code> resource or external resource or transient resource or variable resource or constant resource <code>source_size</code> index <code>result_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_23","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamasynccollective-streamasynccollectiveop","title":"<code>stream.async.collective</code> (Stream::AsyncCollectiveOp)","text":"<p>Performs a collective operation</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.collective` `` $op `` `[` $element_count `]`\n              (`on` `(` $affinity^ `)`)?\n              `channel` `(` $channel `)`\n              custom&lt;CollectiveParam&gt;(ref($op), $param) ``\n              $source `[` $source_offset `to` $source_end `for` $source_length `]` `,`\n              $target `[` $target_offset `to` $target_end `for` $target_length `]` `:`\n              type($source) `` `{` $source_size `}` `-&gt;`\n              custom&lt;ShapedTiedResult&gt;(type($target), $target_size)\n              attr-dict-with-keyword\n</code></pre> <p>TODO: document different usage. For now this should be considered a prototype and that modeling of collective operations may change in the future to better ensure in-place operations (where send/recv is a subset of recv/send). We may have dedicated operations for the send and recv verbs as they have sequencing implications - or we could add optional sequencing to this base op.</p> <p>Traits: Stream_AsyncPhaseOp</p> <p>Interfaces: AsyncAccessOpInterface, InferTypeOpInterface, Stream_AffinityOp, Stream_StreamableOp, TiedOpInterface, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_26","title":"Attributes:","text":"Attribute MLIR Type Description <code>op</code> ::mlir::iree_compiler::IREE::Stream::CollectiveAttr collective operation and specification <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_34","title":"Operands:","text":"Operand Description <code>target</code> resource or external resource or transient resource or variable resource or constant resource <code>target_size</code> index <code>target_offset</code> index <code>target_end</code> index <code>target_length</code> index <code>source</code> resource or external resource or transient resource or variable resource or constant resource <code>source_size</code> index <code>source_offset</code> index <code>source_end</code> index <code>source_length</code> index <code>element_count</code> index <code>channel</code> a collective communication channel <code>param</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/Stream/#results_24","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamasyncconstant-streamasyncconstantop","title":"<code>stream.async.constant</code> (Stream::AsyncConstantOp)","text":"<p>Defines a constant resource</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.constant` (`on` `(` $affinity^ `)`)?\n              `:`\n              type($result) `` `{` $result_size `}`\n              `=`\n              $value\n              attr-dict-with-keyword\n</code></pre> <p>Returns a new resource with the given constant value.</p> <p>Traits: AlwaysSpeculatableImplTrait, Stream_AsyncPhaseOp</p> <p>Interfaces: AsyncAccessOpInterface, ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, Stream_AffinityOp, StreamableOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_27","title":"Attributes:","text":"Attribute MLIR Type Description <code>value</code> ::mlir::ElementsAttr constant vector/tensor attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_35","title":"Operands:","text":"Operand Description <code>result_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_25","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamasynccopy-streamasynccopyop","title":"<code>stream.async.copy</code> (Stream::AsyncCopyOp)","text":"<p>Copies a subview of a stream resource to another</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.copy` (`on` `(` $affinity^ `)`)?\n              $source `[` $source_offset `to` $source_end `]` `,`\n              $target `[` $target_offset `to` $target_end `]` `,`\n              $length `:`\n              type($source) `` `{` $source_size `}` `-&gt;`\n              custom&lt;ShapedTiedResult&gt;(type($target), $target_size)\n              attr-dict-with-keyword\n</code></pre> <p>Copies a subview of a resource into a subview of another. As with memcpy this does not support overlapping updates into the same resource. Unlike <code>stream.async.update</code> copy sources cannot be allocated in-place.</p> <p>Equivalent to a stream.async.slice + stream.async.update.</p> <p>Traits: Stream_AsyncPhaseOp</p> <p>Interfaces: AsyncAccessOpInterface, InferTypeOpInterface, Stream_AffinityOp, Stream_StreamableOp, TiedOpInterface, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_28","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_36","title":"Operands:","text":"Operand Description <code>target</code> resource or external resource or transient resource or variable resource or constant resource <code>target_size</code> index <code>target_offset</code> index <code>target_end</code> index <code>source</code> resource or external resource or transient resource or variable resource or constant resource <code>source_size</code> index <code>source_offset</code> index <code>source_end</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/Stream/#results_26","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamasyncdispatch-streamasyncdispatchop","title":"<code>stream.async.dispatch</code> (Stream::AsyncDispatchOp)","text":"<p>Dispatches a parallelized grid of work</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.dispatch` (`on` `(` $affinity^ `)`)?\n              $entry_point\n              (`[` $workload^ `]`)? ``\n              custom&lt;DispatchOperands&gt;($resource_operands,\n              $resource_operand_offsets,\n              $resource_operand_ends,\n              $resource_operand_lengths) attr-dict `:`\n              custom&lt;ShapedFunctionType&gt;(ref($resource_operands),\n              type($resource_operands), $resource_operand_sizes,\n              type($results), $result_sizes,\n              $tied_operands)\n</code></pre> <p>Calls the specified entry point function once for each element in the specified workgroup count. Each workgroup has access to the same operands and results and is able to load/store at will.</p> <p>Traits: AttrSizedOperandSegments, Stream_AsyncPhaseOp</p> <p>Interfaces: AsyncAccessOpInterface, Stream_AffinityOp, Stream_StreamableOp, SymbolUserOpInterface, TiedOpInterface, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_29","title":"Attributes:","text":"Attribute MLIR Type Description <code>entry_point</code> ::mlir::SymbolRefAttr symbol reference attribute <code>tied_operands</code> ::mlir::ArrayAttr 64-bit integer array attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_37","title":"Operands:","text":"Operand Description <code>workload</code> index <code>resource_operands</code> resource or external resource or transient resource or variable resource or constant resource or index or integer or floating-point or complex-type <code>resource_operand_sizes</code> index <code>resource_operand_offsets</code> index <code>resource_operand_ends</code> index <code>resource_operand_lengths</code> index <code>result_sizes</code> index"},{"location":"reference/mlir-dialects/Stream/#results_27","title":"Results:","text":"Result Description <code>results</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamasyncfill-streamasyncfillop","title":"<code>stream.async.fill</code> (Stream::AsyncFillOp)","text":"<p>Fills a subview of a stream resource with a value</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.fill` (`on` `(` $affinity^ `)`)?\n              $value `,`\n              $target `[` $target_offset `to` $target_end `for` $target_length `]` `:`\n              type($value) `-&gt;`\n              custom&lt;ShapedTiedResult&gt;(type($target), $target_size)\n              attr-dict-with-keyword\n</code></pre> <p>Splats a value into a subview of the given stream resource and returns the resource with the update applied.</p> <p>Equivalent to a stream.async.splat + stream.async.update.</p> <p>Traits: Stream_AsyncPhaseOp</p> <p>Interfaces: AsyncAccessOpInterface, InferTypeOpInterface, Stream_AffinityOp, Stream_StreamableOp, TiedOpInterface, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_30","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_38","title":"Operands:","text":"Operand Description <code>target</code> resource or external resource or transient resource or variable resource or constant resource <code>target_size</code> index <code>target_offset</code> index <code>target_end</code> index <code>target_length</code> index <code>value</code> 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer"},{"location":"reference/mlir-dialects/Stream/#results_28","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamasyncload-streamasyncloadop","title":"<code>stream.async.load</code> (Stream::AsyncLoadOp)","text":"<p>Loads a value from a resource</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.load` $source `[` $source_offset `]` `:`\n              type($source) `` `{` $source_size `}`\n              `-&gt;`\n              type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the element at the given location from within the resource.</p> <p>Traits: AlwaysSpeculatableImplTrait, Stream_AsyncPhaseOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#operands_39","title":"Operands:","text":"Operand Description <code>source</code> staging resource <code>source_size</code> index <code>source_offset</code> index"},{"location":"reference/mlir-dialects/Stream/#results_29","title":"Results:","text":"Result Description <code>result</code> index or integer or floating-point or complex-type or vector of any type values"},{"location":"reference/mlir-dialects/Stream/#streamasyncslice-streamasyncsliceop","title":"<code>stream.async.slice</code> (Stream::AsyncSliceOp)","text":"<p>Slices out a cloned subview of a value</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.slice` (`on` `(` $affinity^ `)`)?\n              $source `[` $source_offset `to` $source_end `]` `:`\n              type($source) `` `{` $source_size `}` `-&gt;`\n              type($result) `` `{` $result_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Slices a subrange of a stream resource based on a byte range. Acts as a copy-on-write operation.</p> <p>Traits: AlwaysSpeculatableImplTrait, Stream_AsyncPhaseOp</p> <p>Interfaces: AsyncAccessOpInterface, ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp, Stream_StreamableOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_31","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_40","title":"Operands:","text":"Operand Description <code>source</code> resource or external resource or transient resource or variable resource or constant resource <code>source_size</code> index <code>source_offset</code> index <code>source_end</code> index <code>result_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_30","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamasyncsplat-streamasyncsplatop","title":"<code>stream.async.splat</code> (Stream::AsyncSplatOp)","text":"<p>Splats a value into a resource</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.splat` (`on` `(` $affinity^ `)`)?\n              $value `:` type($value) `-&gt;` type($result) `` `{` $result_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Returns a new resource with the given primitive value splatted out to fill the entire contents.</p> <p>Traits: Stream_AsyncPhaseOp</p> <p>Interfaces: AsyncAccessOpInterface, Stream_AffinityOp, StreamableOpInterface, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_32","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_41","title":"Operands:","text":"Operand Description <code>value</code> 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer <code>result_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_31","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamasyncstore-streamasyncstoreop","title":"<code>stream.async.store</code> (Stream::AsyncStoreOp)","text":"<p>Stores a value into a resource</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.store` $value `,`\n              $target `[` $target_offset `]` `:`\n              type($value)\n              `-&gt;`\n              custom&lt;ShapedTiedResult&gt;(type($target), $target_size)\n              attr-dict-with-keyword\n</code></pre> <p>Returns a resource with the element at the given offset set to the given value.</p> <p>Traits: AlwaysSpeculatableImplTrait, Stream_AsyncPhaseOp</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), TiedOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#operands_42","title":"Operands:","text":"Operand Description <code>target</code> staging resource <code>target_size</code> index <code>target_offset</code> index <code>value</code> index or integer or floating-point or complex-type or vector of any type values"},{"location":"reference/mlir-dialects/Stream/#results_32","title":"Results:","text":"Result Description <code>result</code> staging resource"},{"location":"reference/mlir-dialects/Stream/#streamasynctransfer-streamasynctransferop","title":"<code>stream.async.transfer</code> (Stream::AsyncTransferOp)","text":"<p>Transfers a resource from one location/state to another</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.transfer` (`from` `(` $source_affinity^ `)`)?\n              $source `:`\n              type($source) `` `{` $source_size `}` `-&gt;`\n              (`to` `(` $result_affinity^ `)`)?\n              type($result) `` `{` $result_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Transfers a resource between different states (such as a <code>staging</code> lifetime to a <code>local</code> lifetime) or different affinities. This is roughly equivalent to a cast but may have special semantics when later lowered to one or more devices with discrete memory spaces or pools.</p> <p>Traits: Stream_AsyncPhaseOp</p> <p>Interfaces: AsyncAccessOpInterface, Stream_AffinityOp, Stream_StreamableOp, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_33","title":"Attributes:","text":"Attribute MLIR Type Description <code>source_affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity <code>result_affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_43","title":"Operands:","text":"Operand Description <code>source</code> resource or external resource or transient resource or variable resource or constant resource or staging resource <code>source_size</code> index <code>result_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_33","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource or staging resource"},{"location":"reference/mlir-dialects/Stream/#streamasyncupdate-streamasyncupdateop","title":"<code>stream.async.update</code> (Stream::AsyncUpdateOp)","text":"<p>Updates a slice of a subview of a resource in-place</p> <p>Syntax:</p> <pre><code>operation ::= `stream.async.update` (`on` `(` $affinity^ `)`)?\n              $update `,`\n              $target `[` $target_offset `to` $target_end `]` `:`\n              type($update) `` `{` $update_size `}` `-&gt;`\n              custom&lt;ShapedTiedResult&gt;(type($target), $target_size)\n              attr-dict-with-keyword\n</code></pre> <p>Copies a value into a resource based on a byte range. The returned value is the entire updated target value. Updates can be turned into placement allocations and avoid copies.</p> <p>Traits: Stream_AsyncPhaseOp</p> <p>Interfaces: AsyncAccessOpInterface, InferTypeOpInterface, Stream_AffinityOp, Stream_StreamableOp, TiedOpInterface, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_34","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_44","title":"Operands:","text":"Operand Description <code>target</code> resource or external resource or transient resource or variable resource or constant resource <code>target_size</code> index <code>target_offset</code> index <code>target_end</code> index <code>update</code> resource or external resource or transient resource or variable resource or constant resource <code>update_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_34","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#synchronization-ops","title":"Synchronization ops","text":""},{"location":"reference/mlir-dialects/Stream/#streamtimepointawait-streamtimepointawaitop","title":"<code>stream.timepoint.await</code> (Stream::TimepointAwaitOp)","text":"<p>Awaits a timepoint before returning a set of resources</p> <p>Syntax:</p> <pre><code>operation ::= `stream.timepoint.await` (`on` `(` $affinity^ `)`)?\n              $await_timepoint `=` `` `&gt;`\n              $resource_operands `:`\n              custom&lt;SizeAwareTypeList&gt;(type($resource_operands),\n              type($results), $resource_operand_sizes)\n              attr-dict-with-keyword\n</code></pre> <p>After asynchronous execution scheduling resources may exist in different states at different points in the execution timeline. This op enables resolving the version of a resource after a particular point in the timeline. As timepoints transitively chain the timepoint must only cover the resource availability but not be limited to its original production timepoint.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp, Stream_TimelineOp, TiedOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_35","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_45","title":"Operands:","text":"Operand Description <code>resource_operands</code> resource or external resource or transient resource or variable resource or constant resource or staging resource <code>resource_operand_sizes</code> index <code>await_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#results_35","title":"Results:","text":"Result Description <code>results</code> resource or external resource or transient resource or variable resource or constant resource or staging resource"},{"location":"reference/mlir-dialects/Stream/#streamtimepointbarrier-streamtimepointbarrierop","title":"<code>stream.timepoint.barrier</code> (Stream::TimepointBarrierOp)","text":"<p>Returns a timepoint indicating when a resource is available</p> <p>Syntax:</p> <pre><code>operation ::= `stream.timepoint.barrier` (`on` `(` $affinity^ `)`)?\n              $resource `:` type($resource) `` `{` $resource_size `}`\n              `=` `` `&gt;`\n              type($result_timepoint)\n              attr-dict-with-keyword\n</code></pre> <p>After asynchronous execution scheduling resources may exist in different states at different points in the execution timeline. This op enables identifying when the version of a resource after a particular point in the timeline is available. As timepoints transitively chain the timepoint must only cover the resource availability but not be limited to its original production timepoint.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp, Stream_TimelineOp, TiedOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_36","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_46","title":"Operands:","text":"Operand Description <code>resource</code> resource or external resource or transient resource or variable resource or constant resource or staging resource <code>resource_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_36","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource or staging resource <code>result_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#streamtimepointchain_external-streamtimepointchainexternalop","title":"<code>stream.timepoint.chain_external</code> (Stream::TimepointChainExternalOp)","text":"<p>Exports a timepoint to an external dialect type</p> <p>Syntax:</p> <pre><code>operation ::= `stream.timepoint.chain_external` (`on` `(` $affinity^ `)`)?\n              $await_timepoint\n              `=` `` `&gt;`\n              `(` $external_values `:` type($external_values) `)`\n              attr-dict-with-keyword\n</code></pre> <p>Defines a conversion to an external dialect type such as <code>hal.fence</code> that is resolved during lowering into the stream dialect. This can be used to interoperate between levels of the stack that require specifying stream types and those that prior to lowering do not handle them.</p> <p>Interfaces: Stream_AffinityOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_37","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_47","title":"Operands:","text":"Operand Description <code>await_timepoint</code> a timepoint indicating execution availability <code>external_values</code> any type"},{"location":"reference/mlir-dialects/Stream/#streamtimepointexport-streamtimepointexportop","title":"<code>stream.timepoint.export</code> (Stream::TimepointExportOp)","text":"<p>Exports a timepoint to an external dialect type</p> <p>Syntax:</p> <pre><code>operation ::= `stream.timepoint.export` (`on` `(` $affinity^ `)`)?\n              $await_timepoint\n              `=` `` `&gt;`\n              `(` type($results) `)`\n              attr-dict-with-keyword\n</code></pre> <p>Defines a conversion to an external dialect type such as <code>hal.fence</code> that is resolved during lowering into the stream dialect. This can be used to interoperate between levels of the stack that require specifying stream types and those that prior to lowering do not handle them.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_38","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_48","title":"Operands:","text":"Operand Description <code>await_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#results_37","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"reference/mlir-dialects/Stream/#streamtimepointimmediate-streamtimepointimmediateop","title":"<code>stream.timepoint.immediate</code> (Stream::TimepointImmediateOp)","text":"<p>Results an immediately-available timepoint</p> <p>Syntax:</p> <pre><code>operation ::= `stream.timepoint.immediate` attr-dict\n              `=` `` `&gt;` type($result_timepoint)\n</code></pre> <p>Timepoints indicate a point in the execution timeline and this op can be used to get a placeholder representing the start of the timeline. Any waits on the returned timepoint will resolve immediately. This generally folds away but can be useful if needing to initialize globals or branch args.</p> <p>Traits: AlwaysSpeculatableImplTrait, ConstantLike</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), Stream_TimelineOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#results_38","title":"Results:","text":"Result Description <code>result_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#streamtimepointimport-streamtimepointimportop","title":"<code>stream.timepoint.import</code> (Stream::TimepointImportOp)","text":"<p>Imports a timepoint from an external dialect type</p> <p>Syntax:</p> <pre><code>operation ::= `stream.timepoint.import` (`on` `(` $affinity^ `)`)?\n              $operands `:` `(` type($operands) `)`\n              `=` `` `&gt;`\n              type($result_timepoint)\n              attr-dict-with-keyword\n</code></pre> <p>Defines a conversion from an external dialect type such as <code>hal.semaphore</code> that is resolved during lowering into the stream dialect. This can be used to interoperate between levels of the stack that require specifying stream types and those that prior to lowering do not handle them.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_39","title":"Attributes:","text":"Attribute MLIR Type Description <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_49","title":"Operands:","text":"Operand Description <code>operands</code> any type"},{"location":"reference/mlir-dialects/Stream/#results_39","title":"Results:","text":"Result Description <code>result_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#streamtimepointjoin-streamtimepointjoinop","title":"<code>stream.timepoint.join</code> (Stream::TimepointJoinOp)","text":"<p>Joins one or more timepoints into the max of all of them</p> <p>Syntax:</p> <pre><code>operation ::= `stream.timepoint.join` `max` `(` $await_timepoints `)` `=` `` `&gt;` type($result_timepoint)\n              attr-dict-with-keyword\n</code></pre> <p>Returns a timepoint that indicates that all of the input timepoints have been reached.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), Stream_TimelineOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#operands_50","title":"Operands:","text":"Operand Description <code>await_timepoints</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#results_40","title":"Results:","text":"Result Description <code>result_timepoint</code> a timepoint indicating execution availability"},{"location":"reference/mlir-dialects/Stream/#tensor-ops","title":"Tensor ops","text":""},{"location":"reference/mlir-dialects/Stream/#streamtensorclone-streamtensorcloneop","title":"<code>stream.tensor.clone</code> (Stream::TensorCloneOp)","text":"<p>Clones the contents of a value</p> <p>Syntax:</p> <pre><code>operation ::= `stream.tensor.clone` (`on` `(` $affinity^ `)`)?\n              $source `:`\n              $source_encoding (`` `{` $source_encoding_dims^ `}`)?\n              `in`\n              type($source) `` `{` $source_size `}`\n              `-&gt;`\n              $result_encoding (`` `{` $result_encoding_dims^ `}`)?\n              `in`\n              type($result) `` `{` $result_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Clones the contents of a value at a snapshot in time. Future changes to the cloned value will not effect the result. Acts as a copy-on-write operation.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments, Stream_TensorPhaseOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp, Stream_StreamableOp, Util_ShapeAwareOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_40","title":"Attributes:","text":"Attribute MLIR Type Description <code>source_encoding</code> ::mlir::TypeAttr any type attribute <code>result_encoding</code> ::mlir::TypeAttr any type attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_51","title":"Operands:","text":"Operand Description <code>source</code> resource or external resource or transient resource or variable resource or constant resource <code>source_encoding_dims</code> index <code>source_size</code> index <code>result_encoding_dims</code> index <code>result_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_41","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamtensorconstant-streamtensorconstantop","title":"<code>stream.tensor.constant</code> (Stream::TensorConstantOp)","text":"<p>Defines a constant tensor value</p> <p>Syntax:</p> <pre><code>operation ::= `stream.tensor.constant` (`on` `(` $affinity^ `)`)?\n              `:`\n              $result_encoding (`` `{` $result_encoding_dims^ `}`)?\n              `in`\n              type($result)\n              `=`\n              $value\n              attr-dict-with-keyword\n</code></pre> <p>Returns a typed resource initialized to the given constant value.</p> <p>Traits: AlwaysSpeculatableImplTrait, Stream_TensorPhaseOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, Stream_AffinityOp, Stream_StreamableOp, Util_ShapeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_41","title":"Attributes:","text":"Attribute MLIR Type Description <code>value</code> ::mlir::ElementsAttr constant vector/tensor attribute <code>result_encoding</code> ::mlir::TypeAttr any type attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_52","title":"Operands:","text":"Operand Description <code>result_encoding_dims</code> index"},{"location":"reference/mlir-dialects/Stream/#results_42","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamtensorempty-streamtensoremptyop","title":"<code>stream.tensor.empty</code> (Stream::TensorEmptyOp)","text":"<p>Defines an empty tensor value</p> <p>Syntax:</p> <pre><code>operation ::= `stream.tensor.empty` (`on` `(` $affinity^ `)`)?\n              `:`\n              $result_encoding (`` `{` $result_encoding_dims^ `}`)?\n              `in`\n              type($result) `` `{` $result_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Returns a typed resource initialized with no contents. This still carries shape metadata and may encode to a non-empty resource such as in cases where the empty representation still has data (e.g. sparse tensors). Subsequent writes must populate any ranges of the tensor that are later read.</p> <p>Traits: AlwaysSpeculatableImplTrait, Stream_TensorPhaseOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, Stream_AffinityOp, StreamableOpInterface, Util_ShapeAwareOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_42","title":"Attributes:","text":"Attribute MLIR Type Description <code>result_encoding</code> ::mlir::TypeAttr any type attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_53","title":"Operands:","text":"Operand Description <code>result_encoding_dims</code> index <code>result_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_43","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamtensorfill-streamtensorfillop","title":"<code>stream.tensor.fill</code> (Stream::TensorFillOp)","text":"<p>Fills a subview of a stream resource with a value</p> <p>Syntax:</p> <pre><code>operation ::= `stream.tensor.fill` (`on` `(` $affinity^ `)`)?\n              $value `,` $target `[` $start_indices `for` $lengths `]` `:`\n              type($value)\n              `-&gt;`\n              $target_encoding (`` `{` $target_encoding_dims^ `}`)?\n              `in`\n              custom&lt;ShapedTiedResult&gt;(type($target), $target_size)\n              attr-dict-with-keyword\n</code></pre> <p>Splats a value into a subview of the given stream resource and returns the resource with the update applied.</p> <p>Equivalent to a stream.tensor.splat + stream.tensor.update.</p> <p>Traits: AttrSizedOperandSegments, Stream_TensorPhaseOp</p> <p>Interfaces: InferTypeOpInterface, Stream_AffinityOp, Stream_StreamableOp, TiedOpInterface, Util_ShapeAwareOp, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_43","title":"Attributes:","text":"Attribute MLIR Type Description <code>target_encoding</code> ::mlir::TypeAttr any type attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_54","title":"Operands:","text":"Operand Description <code>target</code> resource or external resource or transient resource or variable resource or constant resource <code>target_encoding_dims</code> index <code>target_size</code> index <code>start_indices</code> index <code>lengths</code> index <code>value</code> index or integer or floating-point or complex-type"},{"location":"reference/mlir-dialects/Stream/#results_44","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamtensorload-streamtensorloadop","title":"<code>stream.tensor.load</code> (Stream::TensorLoadOp)","text":"<p>Loads a value from a tensor element</p> <p>Syntax:</p> <pre><code>operation ::= `stream.tensor.load` $source (`[` $indices^ `]`)? `:`\n              $source_encoding (`` `{` $source_encoding_dims^ `}`)?\n              `in`\n              type($source) `` `{` $source_size `}`\n              `-&gt;`\n              type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the element at the given location from within the tensor.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments, Stream_TensorPhaseOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), Util_ShapeAwareOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_44","title":"Attributes:","text":"Attribute MLIR Type Description <code>source_encoding</code> ::mlir::TypeAttr any type attribute"},{"location":"reference/mlir-dialects/Stream/#operands_55","title":"Operands:","text":"Operand Description <code>source</code> staging resource <code>source_encoding_dims</code> index <code>source_size</code> index <code>indices</code> index"},{"location":"reference/mlir-dialects/Stream/#results_45","title":"Results:","text":"Result Description <code>result</code> index or integer or floating-point or complex-type or vector of any type values"},{"location":"reference/mlir-dialects/Stream/#streamtensorsizeof-streamtensorsizeofop","title":"<code>stream.tensor.sizeof</code> (Stream::TensorSizeOfOp)","text":"<p>Calculates the storage size of a given high-level type</p> <p>Syntax:</p> <pre><code>operation ::= `stream.tensor.sizeof` (`on` `(` $affinity^ `)`)?\n              $encoding (`{` $encoding_dims^ `}`)?\n              attr-dict `:` type($storage_size)\n</code></pre> <p>Target-dependent storage size calculation using a high-level annotated type. While within the stream dialect the storage size of a value is left as a placeholder using this op. The requisite target-specific parameters for expanding the size calculation are only available after affinities have been assigned.</p> <p>Traits: AlwaysSpeculatableImplTrait, Stream_TensorPhaseOp</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_45","title":"Attributes:","text":"Attribute MLIR Type Description <code>encoding</code> ::mlir::TypeAttr any type attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_56","title":"Operands:","text":"Operand Description <code>encoding_dims</code> index"},{"location":"reference/mlir-dialects/Stream/#results_46","title":"Results:","text":"Result Description <code>storage_size</code> index"},{"location":"reference/mlir-dialects/Stream/#streamtensorslice-streamtensorsliceop","title":"<code>stream.tensor.slice</code> (Stream::TensorSliceOp)","text":"<p>Slices out a cloned subview of a value</p> <p>Syntax:</p> <pre><code>operation ::= `stream.tensor.slice` (`on` `(` $affinity^ `)`)?\n              $source `[` $start_indices `for` $lengths `]` `:`\n              $source_encoding (`` `{` $source_encoding_dims^ `}`)?\n              `in`\n              type($source) `` `{` $source_size `}`\n              `-&gt;`\n              $result_encoding (`` `{` $result_encoding_dims^ `}`)?\n              `in`\n              type($result) `` `{` $result_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Slices a subrange of a stream resource based on a tensor encoding. Acts as a copy-on-write operation.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments, Stream_TensorPhaseOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp, Stream_StreamableOp, Util_ShapeAwareOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_46","title":"Attributes:","text":"Attribute MLIR Type Description <code>source_encoding</code> ::mlir::TypeAttr any type attribute <code>result_encoding</code> ::mlir::TypeAttr any type attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_57","title":"Operands:","text":"Operand Description <code>source</code> resource or external resource or transient resource or variable resource or constant resource <code>source_encoding_dims</code> index <code>source_size</code> index <code>start_indices</code> index <code>lengths</code> index <code>result_encoding_dims</code> index <code>result_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_47","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamtensorsplat-streamtensorsplatop","title":"<code>stream.tensor.splat</code> (Stream::TensorSplatOp)","text":"<p>Splats a value into a shaped tensor</p> <p>Syntax:</p> <pre><code>operation ::= `stream.tensor.splat` (`on` `(` $affinity^ `)`)?\n              $value\n              `:` type($value)\n              `-&gt;`\n              $result_encoding (`` `{` $result_encoding_dims^ `}`)?\n              `in`\n              type($result) `` `{` $result_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Returns a typed resource initialized to the given primitive value.</p> <p>Traits: AlwaysSpeculatableImplTrait, Stream_TensorPhaseOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), Stream_AffinityOp, StreamableOpInterface, Util_ShapeAwareOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_47","title":"Attributes:","text":"Attribute MLIR Type Description <code>result_encoding</code> ::mlir::TypeAttr any type attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_58","title":"Operands:","text":"Operand Description <code>value</code> index or integer or floating-point or complex-type <code>result_encoding_dims</code> index <code>result_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_48","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#streamtensorstore-streamtensorstoreop","title":"<code>stream.tensor.store</code> (Stream::TensorStoreOp)","text":"<p>Stores a value into a tensor element</p> <p>Syntax:</p> <pre><code>operation ::= `stream.tensor.store` $value `,`\n              $target (`[` $indices^ `]`)? `:`\n              type($value)\n              `-&gt;`\n              $target_encoding (`` `{` $target_encoding_dims^ `}`)?\n              `in`\n              custom&lt;ShapedTiedResult&gt;(type($target), $target_size)\n              attr-dict-with-keyword\n</code></pre> <p>Returns a tensor with the element at the given index set to the given value.</p> <p>Traits: AlwaysSpeculatableImplTrait, AttrSizedOperandSegments, Stream_TensorPhaseOp</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), TiedOpInterface, Util_ShapeAwareOp, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_48","title":"Attributes:","text":"Attribute MLIR Type Description <code>target_encoding</code> ::mlir::TypeAttr any type attribute"},{"location":"reference/mlir-dialects/Stream/#operands_59","title":"Operands:","text":"Operand Description <code>target</code> staging resource <code>target_encoding_dims</code> index <code>target_size</code> index <code>indices</code> index <code>value</code> index or integer or floating-point or complex-type or vector of any type values"},{"location":"reference/mlir-dialects/Stream/#results_49","title":"Results:","text":"Result Description <code>result</code> staging resource"},{"location":"reference/mlir-dialects/Stream/#streamtensortrace-streamtensortraceop","title":"<code>stream.tensor.trace</code> (Stream::TensorTraceOp)","text":"<p>Trace value(s) operation</p> <p>Syntax:</p> <pre><code>operation ::= `stream.tensor.trace` attr-dict ($operands^ `:` type($operands))?\n</code></pre> <p>Traces out to a runtime trace sink (console, log file, etc) the given tensors and titles them with the given key. The key is informational only and useful for titling/marking specific sets of tensors for easier searching.</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_49","title":"Attributes:","text":"Attribute MLIR Type Description <code>key</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/Stream/#operands_60","title":"Operands:","text":"Operand Description <code>operands</code> tensor of any type values"},{"location":"reference/mlir-dialects/Stream/#streamtensorupdate-streamtensorupdateop","title":"<code>stream.tensor.update</code> (Stream::TensorUpdateOp)","text":"<p>Updates a slice of a subview of a resource in-place</p> <p>Syntax:</p> <pre><code>operation ::= `stream.tensor.update` (`on` `(` $affinity^ `)`)?\n              $update `,` $target `[` $start_indices `]` `:`\n              $update_encoding (`` `{` $update_encoding_dims^ `}`)?\n              `in`\n              type($update) `` `{` $update_size `}`\n              `-&gt;`\n              $target_encoding (`` `{` $target_encoding_dims^ `}`)?\n              `in`\n              custom&lt;ShapedTiedResult&gt;(type($target), $target_size)\n              attr-dict-with-keyword\n</code></pre> <p>Copies a value into a resource based on tensor encodings. The returned value is the entire updated target value.</p> <p>Traits: AttrSizedOperandSegments, Stream_TensorPhaseOp</p> <p>Interfaces: InferTypeOpInterface, Stream_AffinityOp, Stream_StreamableOp, TiedOpInterface, Util_ShapeAwareOp, Util_SizeAwareOp</p>"},{"location":"reference/mlir-dialects/Stream/#attributes_50","title":"Attributes:","text":"Attribute MLIR Type Description <code>target_encoding</code> ::mlir::TypeAttr any type attribute <code>update_encoding</code> ::mlir::TypeAttr any type attribute <code>affinity</code> ::mlir::iree_compiler::IREE::Stream::AffinityAttr defines execution context affinity"},{"location":"reference/mlir-dialects/Stream/#operands_61","title":"Operands:","text":"Operand Description <code>target</code> resource or external resource or transient resource or variable resource or constant resource <code>target_encoding_dims</code> index <code>target_size</code> index <code>start_indices</code> index <code>update</code> resource or external resource or transient resource or variable resource or constant resource <code>update_encoding_dims</code> index <code>update_size</code> index"},{"location":"reference/mlir-dialects/Stream/#results_50","title":"Results:","text":"Result Description <code>result</code> resource or external resource or transient resource or variable resource or constant resource"},{"location":"reference/mlir-dialects/Stream/#attribute-definition","title":"Attribute definition","text":""},{"location":"reference/mlir-dialects/Stream/#collectiveattr","title":"CollectiveAttr","text":"<p>collective operation and specification</p> <p>Syntax:</p> <pre><code>#stream.collective&lt;\n  CollectiveKind,   # kind\n  std::optional&lt;CollectiveReductionOp&gt;,   # reduction\n  CollectiveElementType   # element_type\n&gt;\n</code></pre> <p>Specifies the collective operation to perform and any mode bits required.</p>"},{"location":"reference/mlir-dialects/Stream/#parameters","title":"Parameters:","text":"Parameter C++ type Description kind <code>CollectiveKind</code> reduction <code>std::optional&lt;CollectiveReductionOp&gt;</code> element_type <code>CollectiveElementType</code>"},{"location":"reference/mlir-dialects/Stream/#partitioningconfigattr","title":"PartitioningConfigAttr","text":"<p>defines partitioning configuration</p> <p>Configures the partitioning algorithm to use and its configuration. Partitioning is useful to adjust when scheduling behavior of targets is radically different - such as single-threaded vs. multi-threaded CPUs or bespoke ML accelerators vs. general purpose GPUs. This mechanism controls the amount of concurrency, parallelism, memory consumption, and latency.</p>"},{"location":"reference/mlir-dialects/Stream/#parameters_1","title":"Parameters:","text":"Parameter C++ type Description favor <code>IREE::Stream::FavorAttr</code>"},{"location":"reference/mlir-dialects/Stream/#resourceconfigattr","title":"ResourceConfigAttr","text":"<p>defines resource constraints configuration</p> <p>Defines resource storage constraints. These allow for packing and layout algorithms to ensure they are producing usable results on target devices.</p>"},{"location":"reference/mlir-dialects/Stream/#parameters_2","title":"Parameters:","text":"Parameter C++ type Description maxAllocationSize <code>int64_t</code> minBufferOffsetAlignment <code>int64_t</code> maxBufferRange <code>int64_t</code> minBufferRangeAlignment <code>int64_t</code> indexBits <code>int64_t</code> aliasMutableBindings <code>bool</code>"},{"location":"reference/mlir-dialects/Stream/#timepointattr","title":"TimepointAttr","text":"<p>an immediately-resolved timepoint</p>"},{"location":"reference/mlir-dialects/Stream/#parameters_3","title":"Parameters:","text":"Parameter C++ type Description type <code>::mlir::Type</code>"},{"location":"reference/mlir-dialects/Stream/#type-constraint-definition","title":"Type constraint definition","text":""},{"location":"reference/mlir-dialects/Stream/#constant-resource","title":"constant resource","text":"<p>Stream constants are immutable values that are available for the lifetime of the program once initialized.</p>"},{"location":"reference/mlir-dialects/Stream/#external-resource","title":"external resource","text":"<p>Stream external values represent asynchronously-available and sequenced values that are owned and managed by external code - such as those passed in or out of the program entry points. Though external values are managed during an invocation the same as other stream values the visibility into them does not extend outside of the invocation they are provided to.</p> <p>Stream values are not usable directly outside of a stream execution or transfer operation. If the contents of the value are needed they must first be transferred via <code>stream.transfer</code> - which may incur a copy.</p>"},{"location":"reference/mlir-dialects/Stream/#staging-resource","title":"staging resource","text":"<p>Stream upload/download staging resource. These are used outside of streams and then transferred to other stream resources such as variables or transients for use inside of streams. Dispatches and several other operations cannot directly operate on these resources.</p>"},{"location":"reference/mlir-dialects/Stream/#transient-resource","title":"transient resource","text":"<p>Stream transients represent asynchronously-available and sequenced values that have a short lifetime - often only passed between stream executions. It is expected that transient values are not stored in global state and have minimal lifetime as they may be heavily pooled or suballocated.</p> <p>Stream values are not usable directly outside of a stream execution or transfer operation. If the contents of the value are needed they must first be transferred via <code>stream.transfer</code> - which may incur a copy.</p>"},{"location":"reference/mlir-dialects/Stream/#resource","title":"resource","text":"<p>A stream resource that has not yet had its lifetime calculated.</p>"},{"location":"reference/mlir-dialects/Stream/#variable-resource","title":"variable resource","text":"<p>Stream variables represent asynchronously-available and sequenced values that have a long lifetime relative to the work being performed on them. These variables are often stored in global state and may live for the entire duration of the program.</p> <p>Stream values are not usable directly outside of a stream execution or transfer operation. If the contents of the value are needed they must first be transferred via <code>stream.transfer</code> - which may incur a copy.</p>"},{"location":"reference/mlir-dialects/Stream/#type-definition","title":"Type definition","text":""},{"location":"reference/mlir-dialects/Stream/#bindingtype","title":"BindingType","text":"<p>a managed resource binding into an executable scope</p> <p>Syntax: <code>!stream.binding</code></p> <p>A resource binding available within an executable dispatch function. The bindings map 1:1 with the resources bound during dispatch operations.</p>"},{"location":"reference/mlir-dialects/Stream/#channeltype","title":"ChannelType","text":"<p>a collective communication channel</p> <p>Syntax: <code>!stream.channel</code></p> <p>Represents a single participant in a collective clique. Multiple channels may exist within the same program to allow for partial operations or hierarchical operations.</p> <p>In programs that model SPMD behavior internally channels can be created or provided by hosting applications. For example, the program could expose a <code>@set_channels(!util.list&lt;!stream.channel&gt;)</code> method that stores the channels in globals for use throughout the program allowing for application-controlled channel configuration.</p>"},{"location":"reference/mlir-dialects/Stream/#resourcetype","title":"ResourceType","text":"<p>a managed resource</p> <p>Stream external values represent asynchronously-available and sequenced values that are owned and managed by external code - such as those passed in or out of the program entry points. Though external values are managed during an invocation the same as other stream values the visibility into them does not extend outside of the invocation they are provided to.</p> <p>Stream values are not usable directly outside of a stream execution or transfer operation. If the contents of the value are needed they must first be transferred via <code>stream.transfer</code> - which may incur a copy.</p>"},{"location":"reference/mlir-dialects/Stream/#parameters_4","title":"Parameters:","text":"Parameter C++ type Description lifetime <code>IREE::Stream::Lifetime</code>"},{"location":"reference/mlir-dialects/Stream/#timepointtype","title":"TimepointType","text":"<p>a timepoint indicating execution availability</p> <p>Syntax: <code>!stream.timepoint</code></p> <p>Represents a point in the execution timeline that when resolved indicates that all of the execution prior to this timepoint has completed and the results of the execution are available for use. This includes transitive dependencies as well; if timepoint B is dependent on timepoint A then when B is available so too must be A.</p>"},{"location":"reference/mlir-dialects/Util/","title":"Util","text":""},{"location":"reference/mlir-dialects/Util/#util-dialect","title":"'util' Dialect","text":"<p>A dialect used for types common across IREE subdialects.</p> <ul> <li>'util' Dialect<ul> <li>Operation definition<ul> <li>Address/offset arithmetic ops<ul> <li>util.align (Util::AlignOp)</li> <li>util.sizeof (Util::SizeOfOp)</li> </ul> </li> <li>Buffer ops<ul> <li>util.buffer.alloc (Util::BufferAllocOp)</li> <li>util.buffer.compare (Util::BufferCompareOp)</li> <li>util.buffer.constant (Util::BufferConstantOp)</li> <li>util.buffer.copy (Util::BufferCopyOp)</li> <li>util.buffer.dealloc (Util::BufferDeallocOp)</li> <li>util.buffer.fill (Util::BufferFillOp)</li> <li>util.buffer.load (Util::BufferLoadOp)</li> <li>util.buffer.size (Util::BufferSizeOp)</li> <li>util.buffer.slice (Util::BufferSliceOp)</li> <li>util.buffer.storage (Util::BufferStorageOp)</li> <li>util.buffer.store (Util::BufferStoreOp)</li> <li>util.buffer.subspan (Util::BufferSubspanOp)</li> </ul> </li> <li>Compiler hint ops<ul> <li>util.optimization_barrier (Util::OptimizationBarrierOp)</li> <li>util.unfoldable_constant (Util::UnfoldableConstantOp)</li> <li>util.unreachable (Util::UnreachableOp)</li> </ul> </li> <li>Data type conversion ops<ul> <li>util.numeric.optional_narrow (Util::NumericOptionalNarrowOp)</li> </ul> </li> <li>Global ops<ul> <li>util.global.address (Util::GlobalAddressOp)</li> <li>util.global.load.indirect (Util::GlobalLoadIndirectOp)</li> <li>util.global.load (Util::GlobalLoadOp)</li> <li>util.global (Util::GlobalOp)</li> <li>util.global.store.indirect (Util::GlobalStoreIndirectOp)</li> <li>util.global.store (Util::GlobalStoreOp)</li> </ul> </li> <li>List ops<ul> <li>util.list.create (Util::ListCreateOp)</li> <li>util.list.get (Util::ListGetOp)</li> <li>util.list.resize (Util::ListResizeOp)</li> <li>util.list.set (Util::ListSetOp)</li> <li>util.list.size (Util::ListSizeOp)</li> </ul> </li> <li>Range arithmetic ops<ul> <li>util.range.extents (Util::RangeExtentsOp)</li> <li>util.range.max (Util::RangeMaxOp)</li> <li>util.range.min (Util::RangeMinOp)</li> </ul> </li> <li>Status ops<ul> <li>util.status.check_ok (Util::StatusCheckOkOp)</li> </ul> </li> <li>Structural ops<ul> <li>util.initializer (Util::InitializerOp)</li> <li>util.initializer.return (Util::InitializerReturnOp)</li> </ul> </li> <li>Type manipulation ops<ul> <li>util.cast (Util::CastOp)</li> <li>util.cmp.eq (Util::CmpEQOp)</li> <li>util.null (Util::NullOp)</li> </ul> </li> <li>Value utility ops<ul> <li>util.switch (Util::SwitchOp)</li> </ul> </li> </ul> </li> <li>Type definition<ul> <li>BufferType</li> <li>ListType</li> <li>ObjectType</li> <li>PtrType</li> <li>VariantType</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/mlir-dialects/Util/#operation-definition","title":"Operation definition","text":""},{"location":"reference/mlir-dialects/Util/#addressoffset-arithmetic-ops","title":"Address/offset arithmetic ops","text":""},{"location":"reference/mlir-dialects/Util/#utilalign-utilalignop","title":"<code>util.align</code> (Util::AlignOp)","text":"<p>Aligns up to a power-of-two alignment if required</p> <p>Syntax:</p> <pre><code>operation ::= `util.align` $value `,` $alignment attr-dict `:` type($result)\n</code></pre> <p>Aligns |value| up to the given power-of-two |alignment| if required.</p> <p>Traits: AlwaysSpeculatableImplTrait, SameOperandsAndResultType</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#operands","title":"Operands:","text":"Operand Description <code>value</code> signless-integer-like <code>alignment</code> signless-integer-like"},{"location":"reference/mlir-dialects/Util/#results","title":"Results:","text":"Result Description <code>result</code> signless-integer-like"},{"location":"reference/mlir-dialects/Util/#utilsizeof-utilsizeofop","title":"<code>util.sizeof</code> (Util::SizeOfOp)","text":"<p>Returns the size in bytes of a datatype</p> <p>Syntax:</p> <pre><code>operation ::= `util.sizeof` $sizedType attr-dict-with-keyword\n</code></pre> <p>Most datatypes have a static size at all layers of the compilation stack. However, those that only have a size for certain lowering flows can be challenging. This op represents such sizes in a way that can be specialized later.</p> <p>Returns the size in bytes, rounded up to the next whole byte of the specified type. This op will fold to a constant index value for IntegerType and FloatType. All others are not folded.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>sizedType</code> ::mlir::TypeAttr any type attribute"},{"location":"reference/mlir-dialects/Util/#results_1","title":"Results:","text":"Result Description <code>size</code> index"},{"location":"reference/mlir-dialects/Util/#buffer-ops","title":"Buffer ops","text":""},{"location":"reference/mlir-dialects/Util/#utilbufferalloc-utilbufferallocop","title":"<code>util.buffer.alloc</code> (Util::BufferAllocOp)","text":"<p>Allocates a buffer with undefined contents</p> <p>Syntax:</p> <pre><code>operation ::= `util.buffer.alloc` `uninitialized`\n              attr-dict\n              `:`\n              type($result) `` `{` $storage_size `}`\n</code></pre> <p>Allocates a buffer with undefined contents. Consumers of the allocated result must assume nothing of the contents.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, MemoryEffectOpInterface (MemoryEffectOpInterface), NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}, MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>alignment</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/Util/#operands_1","title":"Operands:","text":"Operand Description <code>storage_size</code> index"},{"location":"reference/mlir-dialects/Util/#results_2","title":"Results:","text":"Result Description <code>result</code> a reference counted byte buffer"},{"location":"reference/mlir-dialects/Util/#utilbuffercompare-utilbuffercompareop","title":"<code>util.buffer.compare</code> (Util::BufferCompareOp)","text":"<p>Compares a range of two buffers</p> <p>Syntax:</p> <pre><code>operation ::= `util.buffer.compare` $lhs `[` $lhs_offset `]` `,`\n              $rhs `[` $rhs_offset `]` `,`\n              $length `:`\n              type($lhs) `` `{` $lhs_size `}` `,`\n              type($rhs) `` `{` $rhs_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Returns true if the two ranges are bitwise equivalent, somewhat like memcmp.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, MemoryEffectOpInterface (MemoryEffectOpInterface), NoMemoryEffect (MemoryEffectOpInterface), SubrangeOperandOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}, MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#operands_2","title":"Operands:","text":"Operand Description <code>lhs</code> a reference counted byte buffer <code>lhs_size</code> index <code>lhs_offset</code> index <code>rhs</code> a reference counted byte buffer <code>rhs_size</code> index <code>rhs_offset</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/Util/#results_3","title":"Results:","text":"Result Description <code>result</code> 1-bit signless integer"},{"location":"reference/mlir-dialects/Util/#utilbufferconstant-utilbufferconstantop","title":"<code>util.buffer.constant</code> (Util::BufferConstantOp)","text":"<p>Constant host-side byte buffer</p> <p>Syntax:</p> <pre><code>operation ::= `util.buffer.constant` ($name^)? attr-dict `:` type($result) `=` $value\n</code></pre> <p>Defines a compile-time byte buffer based on the given attribute value. The attribute will be serialized into the canonical IREE format for the chosen host target.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#attributes_2","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute <code>value</code> ::mlir::Attribute buffer-like constant attribute values <code>alignment</code> ::mlir::IntegerAttr index attribute <code>mime_type</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/Util/#results_4","title":"Results:","text":"Result Description <code>result</code> a reference counted byte buffer"},{"location":"reference/mlir-dialects/Util/#utilbuffercopy-utilbuffercopyop","title":"<code>util.buffer.copy</code> (Util::BufferCopyOp)","text":"<p>Copies a range of bytes between buffers</p> <p>Syntax:</p> <pre><code>operation ::= `util.buffer.copy` $source `[` $source_offset `]` `,`\n              $target `[` $target_offset `]` `,`\n              $length `:`\n              type($source) `` `{` $source_size `}` `-&gt;`\n              type($target) `` `{` $target_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Copies a range of bytes as with memcpy (no overlapping).</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), SubrangeOperandOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource, MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Util/#operands_3","title":"Operands:","text":"Operand Description <code>source</code> a reference counted byte buffer <code>source_size</code> index <code>source_offset</code> index <code>target</code> a reference counted byte buffer <code>target_size</code> index <code>target_offset</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/Util/#utilbufferdealloc-utilbufferdeallocop","title":"<code>util.buffer.dealloc</code> (Util::BufferDeallocOp)","text":"<p>Deallocates a buffer</p> <p>Syntax:</p> <pre><code>operation ::= `util.buffer.dealloc` $operand `:` type($operand) `{` $operand_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Hints that the buffer contents can be discarded. Buffers are reference counted and other owners may keep it live beyond the dealloc.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, MemoryEffectOpInterface (MemoryEffectOpInterface), NoMemoryEffect (MemoryEffectOpInterface), Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Free on ::mlir::SideEffects::DefaultResource}, MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#operands_4","title":"Operands:","text":"Operand Description <code>operand</code> a reference counted byte buffer <code>operand_size</code> index"},{"location":"reference/mlir-dialects/Util/#utilbufferfill-utilbufferfillop","title":"<code>util.buffer.fill</code> (Util::BufferFillOp)","text":"<p>Fills a range of bytes with a value</p> <p>Syntax:</p> <pre><code>operation ::= `util.buffer.fill` $pattern `,`\n              $target `[` $target_offset `for` $length `]` `:`\n              type($pattern) `-&gt;`\n              type($target) `` `{` $target_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Fills the contents of the buffer in the given byte range with a pattern. The offset and length must match the natural alignment of the pattern type.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), SubrangeOperandOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Util/#operands_5","title":"Operands:","text":"Operand Description <code>pattern</code> integer or floating-point or index <code>target</code> a reference counted byte buffer <code>target_size</code> index <code>target_offset</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/Util/#utilbufferload-utilbufferloadop","title":"<code>util.buffer.load</code> (Util::BufferLoadOp)","text":"<p>Loads a value from a buffer</p> <p>Syntax:</p> <pre><code>operation ::= `util.buffer.load` $source `[` $source_offset `for` $length `]`\n              `:` type($source) `` `{` $source_size `}` `-&gt;` type($result)\n              attr-dict-with-keyword\n</code></pre> <p>Loads a value at a byte offset. Must be aligned to the natural size of the result type.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), SubrangeOperandOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Util/#operands_6","title":"Operands:","text":"Operand Description <code>source</code> a reference counted byte buffer <code>source_size</code> index <code>source_offset</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/Util/#results_5","title":"Results:","text":"Result Description <code>result</code> index or integer or floating-point"},{"location":"reference/mlir-dialects/Util/#utilbuffersize-utilbuffersizeop","title":"<code>util.buffer.size</code> (Util::BufferSizeOp)","text":"<p>Returns the total buffer storage size in bytes</p> <p>Syntax:</p> <pre><code>operation ::= `util.buffer.size` $operand\n              `:` type($operand)\n              attr-dict-with-keyword\n</code></pre> <p>Returns the total length of the buffer in bytes from its base offset.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#operands_7","title":"Operands:","text":"Operand Description <code>operand</code> a reference counted byte buffer"},{"location":"reference/mlir-dialects/Util/#results_6","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/Util/#utilbufferslice-utilbuffersliceop","title":"<code>util.buffer.slice</code> (Util::BufferSliceOp)","text":"<p>Clones a subregion of a buffer</p> <p>Syntax:</p> <pre><code>operation ::= `util.buffer.slice` $source `[` $source_offset `]` attr-dict `:`\n              type($source) `` `{` $source_size `}` `-&gt;`\n              type($result) `` `{` $result_size `}`\n</code></pre> <p>Returns a copy of the contents from the source buffer.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, MemoryEffectOpInterface (MemoryEffectOpInterface), NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, SubrangeOperandOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource, MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}, MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#attributes_3","title":"Attributes:","text":"Attribute MLIR Type Description <code>alignment</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/Util/#operands_8","title":"Operands:","text":"Operand Description <code>source</code> a reference counted byte buffer <code>source_size</code> index <code>source_offset</code> index <code>result_size</code> index"},{"location":"reference/mlir-dialects/Util/#results_7","title":"Results:","text":"Result Description <code>result</code> a reference counted byte buffer"},{"location":"reference/mlir-dialects/Util/#utilbufferstorage-utilbufferstorageop","title":"<code>util.buffer.storage</code> (Util::BufferStorageOp)","text":"<p>Returns the underlying buffer storage range</p> <p>Syntax:</p> <pre><code>operation ::= `util.buffer.storage` $operand\n              `:` type($operand) `` `{` $operand_size `}` `-&gt;` `(` type($result) `,` type($offset) `)`\n              attr-dict-with-keyword\n</code></pre> <p>Returns the buffer storage as a memref that must be offset and restricted to the returned range. The memref may be of any type and the user is responsible for ensuring that the reinterpret_cast-like behavior makes sense for the data they are accessing.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#operands_9","title":"Operands:","text":"Operand Description <code>operand</code> a reference counted byte buffer <code>operand_size</code> index"},{"location":"reference/mlir-dialects/Util/#results_8","title":"Results:","text":"Result Description <code>result</code> memref of any type values <code>offset</code> index"},{"location":"reference/mlir-dialects/Util/#utilbufferstore-utilbufferstoreop","title":"<code>util.buffer.store</code> (Util::BufferStoreOp)","text":"<p>Stores a value into a buffer</p> <p>Syntax:</p> <pre><code>operation ::= `util.buffer.store` $source `,`\n              $target `[` $target_offset `for` $length `]`\n              `:` type($source) `-&gt;` type($target) `` `{` $target_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Stores a value at a byte offset. Must be aligned to the natural size of the source type.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), SubrangeOperandOpInterface, Util_SizeAwareOp</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Util/#operands_10","title":"Operands:","text":"Operand Description <code>source</code> index or integer or floating-point <code>target</code> a reference counted byte buffer <code>target_size</code> index <code>target_offset</code> index <code>length</code> index"},{"location":"reference/mlir-dialects/Util/#utilbuffersubspan-utilbuffersubspanop","title":"<code>util.buffer.subspan</code> (Util::BufferSubspanOp)","text":"<p>Returns a reference to a subrange of a buffer</p> <p>Syntax:</p> <pre><code>operation ::= `util.buffer.subspan` $source `[` $source_offset `]` `:`\n              type($source) `` `{` $source_size `}` `-&gt;`\n              type($result) `` `{` $result_size `}`\n              attr-dict-with-keyword\n</code></pre> <p>Returns a logical view into an underlying source buffer. This induces aliasing and multiple SSA values may allow access to the same underlying buffer storage.</p> <p>Subspans are a compiler-only concept and are propagated by an analysis pass to result in absolute offsets on accesses any place the subrange would have been used.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, SubrangeOperandOpInterface, TiedOpInterface, Util_SizeAwareOp, Util_SubrangeOp, ViewLikeOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#operands_11","title":"Operands:","text":"Operand Description <code>source</code> a reference counted byte buffer <code>source_size</code> index <code>source_offset</code> index <code>result_size</code> index"},{"location":"reference/mlir-dialects/Util/#results_9","title":"Results:","text":"Result Description <code>result</code> a reference counted byte buffer"},{"location":"reference/mlir-dialects/Util/#compiler-hint-ops","title":"Compiler hint ops","text":""},{"location":"reference/mlir-dialects/Util/#utiloptimization_barrier-utiloptimizationbarrierop","title":"<code>util.optimization_barrier</code> (Util::OptimizationBarrierOp)","text":"<p>Prevents compiler optimizations across a value.</p> <p>Syntax:</p> <pre><code>operation ::= `util.optimization_barrier` attr-dict\n              ($operands^ `:` type($operands))?\n</code></pre> <p>Wraps any operands in an unoptimizable identity to prevent its results from being folded. It will be dropped during the final step in compilation and has no effect at runtime.</p> <p>Traits: SameOperandsAndResultType</p>"},{"location":"reference/mlir-dialects/Util/#operands_12","title":"Operands:","text":"Operand Description <code>operands</code> any type"},{"location":"reference/mlir-dialects/Util/#results_10","title":"Results:","text":"Result Description <code>results</code> any type"},{"location":"reference/mlir-dialects/Util/#utilunfoldable_constant-utilunfoldableconstantop","title":"<code>util.unfoldable_constant</code> (Util::UnfoldableConstantOp)","text":"<p>A constant that cannot be folded by the compiler.</p> <p>Similar to a std.constant, but is declared as having a side effect and has no folder. This is really just syntactic sugar as it is canonicalized to a std.constant wrapped in an util.optimization_barrier.</p>"},{"location":"reference/mlir-dialects/Util/#attributes_4","title":"Attributes:","text":"Attribute MLIR Type Description <code>value</code> ::mlir::Attribute any attribute"},{"location":"reference/mlir-dialects/Util/#results_11","title":"Results:","text":"Result Description \u00abunnamed\u00bb any type"},{"location":"reference/mlir-dialects/Util/#utilunreachable-utilunreachableop","title":"<code>util.unreachable</code> (Util::UnreachableOp)","text":"<p>Unreachable assertion op</p> <p>Syntax:</p> <pre><code>operation ::= `util.unreachable` $message attr-dict\n</code></pre> <p>Signals to the compiler that the parent block should not be reachable. This may be converted into a runtime assertion, though ideally they are stripped during translation.</p> <pre><code>^bb0:\n  %true = arith.constant true\n  cond_br %true, ^bb2, ^bb1\n^bb1:\n  // Indicates that this branch should never be taken.\n  util.unreachable \"shouldn't be here\"\n^bb2:\n  ...\n</code></pre> <p>Traits: ReturnLike, Terminator</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#attributes_5","title":"Attributes:","text":"Attribute MLIR Type Description <code>message</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/Util/#data-type-conversion-ops","title":"Data type conversion ops","text":""},{"location":"reference/mlir-dialects/Util/#utilnumericoptional_narrow-utilnumericoptionalnarrowop","title":"<code>util.numeric.optional_narrow</code> (Util::NumericOptionalNarrowOp)","text":"<p>Memorializes an optional numeric narrowing that is valid</p> <p>Syntax:</p> <pre><code>operation ::= `util.numeric.optional_narrow` $operand `:` type($operand) `as` $semantic_type attr-dict\n</code></pre> <p>Serves as a placeholder for points in the computation where an optional numeric narrowing can be performed without loss of information. Such ops can guide optimization passes wishing to perform precision reduction.</p> <p>In addition to the operand and result type, this op takes an additional <code>semantic_type</code> attribute representing the semantic target type which can be:   * FloatType   * Signed IntegerType   * Unsigned IntegerType</p> <p>Note that this <code>semantic_type</code> must be a sign-carrying integer if using an integer type and cannot be IndexType (i.e. it can be used to indicate a possible narrowing of an IndexType to a specific integer).</p> <p>If the operand is a TensorType, then the result must be a TensorType. The <code>semantic_type</code> constrains the element type.</p> <p>Optionally, the minimum and maximum integer values (for integer semantic types) are tracked if known.</p> <p>Traits: AlwaysSpeculatableImplTrait, SameOperandsAndResultType</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#attributes_6","title":"Attributes:","text":"Attribute MLIR Type Description <code>semantic_type</code> ::mlir::TypeAttr any type attribute <code>min_value</code> ::mlir::IntegerAttr arbitrary integer attribute <code>max_value</code> ::mlir::IntegerAttr arbitrary integer attribute"},{"location":"reference/mlir-dialects/Util/#operands_13","title":"Operands:","text":"Operand Description <code>operand</code> signless integer or floating-point or tensor of signless integer or floating-point values"},{"location":"reference/mlir-dialects/Util/#results_12","title":"Results:","text":"Result Description <code>result</code> signless integer or floating-point or tensor of signless integer or floating-point values"},{"location":"reference/mlir-dialects/Util/#global-ops","title":"Global ops","text":""},{"location":"reference/mlir-dialects/Util/#utilglobaladdress-utilglobaladdressop","title":"<code>util.global.address</code> (Util::GlobalAddressOp)","text":"<p>Returns an address reference to a global</p> <p>Syntax:</p> <pre><code>operation ::= `util.global.address` $global attr-dict `:` qualified(type($result))\n</code></pre> <p>Returns the address of a global as a typed reference. Can be used with the global load and store indirect ops.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, SymbolUserOpInterface, Util_GlobalAddressOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#attributes_7","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute"},{"location":"reference/mlir-dialects/Util/#results_13","title":"Results:","text":"Result Description <code>result</code> a pointer-like reference"},{"location":"reference/mlir-dialects/Util/#utilgloballoadindirect-utilgloballoadindirectop","title":"<code>util.global.load.indirect</code> (Util::GlobalLoadIndirectOp)","text":"<p>Loads a value from a global variable</p> <p>Syntax:</p> <pre><code>operation ::= `util.global.load.indirect` $global attr-dict `:` qualified(type($global)) `-&gt;` type($result)\n</code></pre> <p>Returns a copy of the global variable value.</p> <p>Interfaces: Util_GlobalLoadIndirectOpInterface</p>"},{"location":"reference/mlir-dialects/Util/#operands_14","title":"Operands:","text":"Operand Description <code>global</code> a pointer-like reference"},{"location":"reference/mlir-dialects/Util/#results_14","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/Util/#utilglobalload-utilgloballoadop","title":"<code>util.global.load</code> (Util::GlobalLoadOp)","text":"<p>Loads a value from a global variable</p> <p>Syntax:</p> <pre><code>operation ::= `util.global.load` $global attr-dict `:` type($result)\n</code></pre> <p>Returns a global variable value.</p> <p>Interfaces: MemoryEffectOpInterface, OpAsmOpInterface, SymbolUserOpInterface, Util_GlobalLoadOpInterface</p>"},{"location":"reference/mlir-dialects/Util/#attributes_8","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute"},{"location":"reference/mlir-dialects/Util/#results_15","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/Util/#utilglobal-utilglobalop","title":"<code>util.global</code> (Util::GlobalOp)","text":"<p>Stateful global variable declaration</p> <p>Syntax:</p> <pre><code>operation ::= `util.global` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              (`mutable` $is_mutable^)?\n              $sym_name\n              attr-dict\n              custom&lt;TypeOrAttr&gt;($type, $initial_value)\n</code></pre> <p>Declares a global variable that maintains its value across invocations. The value is tied to the execution context of the module and different contexts will have different variable storage.</p> <p>Interfaces: Symbol, Util_GlobalOpInterface</p>"},{"location":"reference/mlir-dialects/Util/#attributes_9","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>type</code> ::mlir::TypeAttr any type attribute <code>is_mutable</code> ::mlir::UnitAttr unit attribute <code>initial_value</code> ::mlir::TypedAttr TypedAttr instance"},{"location":"reference/mlir-dialects/Util/#utilglobalstoreindirect-utilglobalstoreindirectop","title":"<code>util.global.store.indirect</code> (Util::GlobalStoreIndirectOp)","text":"<p>Stores a value into a global variable</p> <p>Syntax:</p> <pre><code>operation ::= `util.global.store.indirect` $value `,` $global attr-dict `:` type($value) `-&gt;` qualified(type($global))\n</code></pre> <p>Stores a copy of the value into a global variable.</p> <p>Interfaces: Util_GlobalStoreIndirectOpInterface</p>"},{"location":"reference/mlir-dialects/Util/#operands_15","title":"Operands:","text":"Operand Description <code>value</code> any type <code>global</code> a pointer-like reference"},{"location":"reference/mlir-dialects/Util/#utilglobalstore-utilglobalstoreop","title":"<code>util.global.store</code> (Util::GlobalStoreOp)","text":"<p>Stores a value into a global variable</p> <p>Syntax:</p> <pre><code>operation ::= `util.global.store` $value `,` $global attr-dict `:` type($value)\n</code></pre> <p>Stores a copy of the value into a global variable.</p> <p>Interfaces: SymbolUserOpInterface, Util_GlobalStoreOpInterface</p>"},{"location":"reference/mlir-dialects/Util/#attributes_10","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute"},{"location":"reference/mlir-dialects/Util/#operands_16","title":"Operands:","text":"Operand Description <code>value</code> any type"},{"location":"reference/mlir-dialects/Util/#list-ops","title":"List ops","text":"<p>Ops for <code>!util.list&lt;T&gt;</code> (mostly just a placeholder for now).</p>"},{"location":"reference/mlir-dialects/Util/#utillistcreate-utillistcreateop","title":"<code>util.list.create</code> (Util::ListCreateOp)","text":"<p>Creates a new empty list</p> <p>Syntax:</p> <pre><code>operation ::= `util.list.create` ($initial_capacity^)? attr-dict `:` qualified(type($result))\n</code></pre> <p>Creates a new empty list with an optional initial capacity.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, MemoryEffectOpInterface (MemoryEffectOpInterface), NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}, MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#operands_17","title":"Operands:","text":"Operand Description <code>initial_capacity</code> index"},{"location":"reference/mlir-dialects/Util/#results_16","title":"Results:","text":"Result Description <code>result</code> dense list container type"},{"location":"reference/mlir-dialects/Util/#utillistget-utillistgetop","title":"<code>util.list.get</code> (Util::ListGetOp)","text":"<p>Element accessor</p> <p>Syntax:</p> <pre><code>operation ::= `util.list.get` $list `[` $index `]` attr-dict `:` custom&lt;ListTypeGet&gt;(type($list), type($result))\n</code></pre> <p>Returns the value of the element at the given index. Note that the value may be null if the element is null or the type does not match.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Util/#operands_18","title":"Operands:","text":"Operand Description <code>list</code> dense list container type <code>index</code> index"},{"location":"reference/mlir-dialects/Util/#results_17","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/Util/#utillistresize-utillistresizeop","title":"<code>util.list.resize</code> (Util::ListResizeOp)","text":"<p>Resizes the list to a new count in elements</p> <p>Syntax:</p> <pre><code>operation ::= `util.list.resize` operands attr-dict `:` qualified(type($list))\n</code></pre> <p>Resizes the list to contain <code>new_size</code> elements. This will either truncate the list if the existing size is greater than <code>new_size</code> or extend the list with the default list value of the element type.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Util/#operands_19","title":"Operands:","text":"Operand Description <code>list</code> dense list container type <code>new_size</code> index"},{"location":"reference/mlir-dialects/Util/#utillistset-utillistsetop","title":"<code>util.list.set</code> (Util::ListSetOp)","text":"<p>Element mutator</p> <p>Syntax:</p> <pre><code>operation ::= `util.list.set` $list `[` $index `]` `,` $value attr-dict `:` custom&lt;ListTypeSet&gt;(type($list), type($value))\n</code></pre> <p>Sets the element at the given index to the new value.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Util/#operands_20","title":"Operands:","text":"Operand Description <code>list</code> dense list container type <code>index</code> index <code>value</code> any type"},{"location":"reference/mlir-dialects/Util/#utillistsize-utillistsizeop","title":"<code>util.list.size</code> (Util::ListSizeOp)","text":"<p>The size of the list in elements</p> <p>Syntax:</p> <pre><code>operation ::= `util.list.size` operands attr-dict `:` qualified(type($list))\n</code></pre> <p>Returns the current size of the list in elements.</p> <p>Interfaces: InferTypeOpInterface, MemoryEffectOpInterface (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/Util/#operands_21","title":"Operands:","text":"Operand Description <code>list</code> dense list container type"},{"location":"reference/mlir-dialects/Util/#results_18","title":"Results:","text":"Result Description <code>result</code> index"},{"location":"reference/mlir-dialects/Util/#range-arithmetic-ops","title":"Range arithmetic ops","text":""},{"location":"reference/mlir-dialects/Util/#utilrangeextents-utilrangeextentsop","title":"<code>util.range.extents</code> (Util::RangeExtentsOp)","text":"<p>Returns the min/max of a union of a set of ranges</p> <p>Syntax:</p> <pre><code>operation ::= `util.range.extents` custom&lt;RangeList&gt;($offsets, $lengths) attr-dict `:` type($min)\n</code></pre> <p>Computes min(offsets) and max(offsets + lengths). Though it's possible to express this with standard arithmetic this op enables more semantically meaningful folding/optimizations.</p> <p>Traits: AlwaysSpeculatableImplTrait, SameOperandsAndResultType, SameVariadicOperandSize</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#operands_22","title":"Operands:","text":"Operand Description <code>offsets</code> index or integer <code>lengths</code> index or integer"},{"location":"reference/mlir-dialects/Util/#results_19","title":"Results:","text":"Result Description <code>min</code> index or integer <code>max</code> index or integer"},{"location":"reference/mlir-dialects/Util/#utilrangemax-utilrangemaxop","title":"<code>util.range.max</code> (Util::RangeMaxOp)","text":"<p>Returns the max of all values</p> <p>Syntax:</p> <pre><code>operation ::= `util.range.max` $operands attr-dict `:` type($result)\n</code></pre> <p>Computes the max of a variadic list of operands. Though it's possible to express this with standard arithmetic this op enables more semantically meaningful folding/optimizations.</p> <p>Traits: AlwaysSpeculatableImplTrait, SameOperandsAndResultType, SameVariadicOperandSize</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#operands_23","title":"Operands:","text":"Operand Description <code>operands</code> index or integer"},{"location":"reference/mlir-dialects/Util/#results_20","title":"Results:","text":"Result Description <code>result</code> index or integer"},{"location":"reference/mlir-dialects/Util/#utilrangemin-utilrangeminop","title":"<code>util.range.min</code> (Util::RangeMinOp)","text":"<p>Returns the min of all values</p> <p>Syntax:</p> <pre><code>operation ::= `util.range.min` $operands attr-dict `:` type($result)\n</code></pre> <p>Computes the min of a variadic list of operands. Though it's possible to express this with standard arithmetic this op enables more semantically meaningful folding/optimizations.</p> <p>Traits: AlwaysSpeculatableImplTrait, SameOperandsAndResultType, SameVariadicOperandSize</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#operands_24","title":"Operands:","text":"Operand Description <code>operands</code> index or integer"},{"location":"reference/mlir-dialects/Util/#results_21","title":"Results:","text":"Result Description <code>result</code> index or integer"},{"location":"reference/mlir-dialects/Util/#status-ops","title":"Status ops","text":""},{"location":"reference/mlir-dialects/Util/#utilstatuscheck_ok-utilstatuscheckokop","title":"<code>util.status.check_ok</code> (Util::StatusCheckOkOp)","text":"<p>Raises a global failure if a status is not 'ok'</p> <p>Syntax:</p> <pre><code>operation ::= `util.status.check_ok` $status (`,` $message^)? attr-dict\n</code></pre> <p>When the status is not 'ok' this signals a runtime failure that causes the entire active invocation - and possibly all in-flight and pending invocations - to fail with the given status. The status will be propagated back via the available runtime error handling mechanisms such as semaphores or synchronous invocation results.</p> <p>As the IREE execution model is deeply pipelined it's possible that failures have a latency between when they are emitted and when the application can observe the failure. It's also possible that other work that is in-flight or pending when the failure occurs will complete.</p>"},{"location":"reference/mlir-dialects/Util/#attributes_11","title":"Attributes:","text":"Attribute MLIR Type Description <code>message</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/Util/#operands_25","title":"Operands:","text":"Operand Description <code>status</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/Util/#structural-ops","title":"Structural ops","text":""},{"location":"reference/mlir-dialects/Util/#utilinitializer-utilinitializerop","title":"<code>util.initializer</code> (Util::InitializerOp)","text":"<p>Global initialization function</p> <p>A function that is called in definition order upon module initialization. Must not load any globals that are defined or initialized after it in the module.</p> <p>Traits: IsolatedFromAbove</p> <p>Interfaces: CallableOpInterface, FunctionOpInterface, Symbol, Util_InitializerOpInterface</p>"},{"location":"reference/mlir-dialects/Util/#attributes_12","title":"Attributes:","text":"Attribute MLIR Type Description <code>function_type</code> ::mlir::TypeAttr type attribute of function type <code>arg_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes <code>res_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes"},{"location":"reference/mlir-dialects/Util/#utilinitializerreturn-utilinitializerreturnop","title":"<code>util.initializer.return</code> (Util::InitializerReturnOp)","text":"<p>Return from a util.initializer</p> <p>Syntax:</p> <pre><code>operation ::= `util.initializer.return` attr-dict\n</code></pre> <p>Returns control from an initializer function.</p> <p>Traits: AlwaysSpeculatableImplTrait, HasParent, ReturnLike, Terminator <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#type-manipulation-ops","title":"Type manipulation ops","text":""},{"location":"reference/mlir-dialects/Util/#utilcast-utilcastop","title":"<code>util.cast</code> (Util::CastOp)","text":"<p>Casts one util type to another ala static_cast/dynamic_cast</p> <p>Syntax:</p> <pre><code>operation ::= `util.cast` $operand attr-dict `:` type($operand) `to` type($result)\n</code></pre> <p>Performs a type cast between object types known to the util dialect.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: CastOpInterface, ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), TiedOpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#operands_26","title":"Operands:","text":"Operand Description <code>operand</code> any type"},{"location":"reference/mlir-dialects/Util/#results_22","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/Util/#utilcmpeq-utilcmpeqop","title":"<code>util.cmp.eq</code> (Util::CmpEQOp)","text":"<p>Compares two values for equality</p> <p>Syntax:</p> <pre><code>operation ::= `util.cmp.eq` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands for equality. This is intended for comparing IREE reference types (like !util.buffer) that cannot be used with std.cmpi.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#operands_27","title":"Operands:","text":"Operand Description <code>lhs</code> any type <code>rhs</code> any type"},{"location":"reference/mlir-dialects/Util/#results_23","title":"Results:","text":"Result Description <code>result</code> 1-bit signless integer"},{"location":"reference/mlir-dialects/Util/#utilnull-utilnullop","title":"<code>util.null</code> (Util::NullOp)","text":"<p>Returns a null type value</p> <p>Syntax:</p> <pre><code>operation ::= `util.null` attr-dict `:` type($result)\n</code></pre> <p>Defines an SSA value that is lowered into dialects supporting null/undefined/optional/etc values.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#results_24","title":"Results:","text":"Result Description <code>result</code> any type"},{"location":"reference/mlir-dialects/Util/#value-utility-ops","title":"Value utility ops","text":""},{"location":"reference/mlir-dialects/Util/#utilswitch-utilswitchop","title":"<code>util.switch</code> (Util::SwitchOp)","text":"<p>Primitive switch operation</p> <p>Syntax:</p> <pre><code>operation ::= `util.switch` type($default_value) `from`\n              custom&lt;TypedValueList&gt;(ref(type($default_value)), $values, type($values))\n              `at` $index\n              `else` $default_value\n              attr-dict\n              `:` type($result)\n</code></pre> <p>Returns the value with the given <code>index</code> in <code>values</code> or <code>default_value</code> if the index is out of bounds.</p> <pre><code>// Switch %index to cases of %c100/%c200/%c300 if index==0, ==1, ==2.\n// If %index is out of range (&lt;0 or &gt;2) then default to %c5.\n%0 = util.switch %index[%c100, %c200, %c300] else %c5 : i32\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, InferTypeOpInterface, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/Util/#operands_28","title":"Operands:","text":"Operand Description <code>index</code> index <code>default_value</code> index or integer or floating-point <code>values</code> index or integer or floating-point"},{"location":"reference/mlir-dialects/Util/#results_25","title":"Results:","text":"Result Description <code>result</code> index or integer or floating-point"},{"location":"reference/mlir-dialects/Util/#type-definition","title":"Type definition","text":""},{"location":"reference/mlir-dialects/Util/#buffertype","title":"BufferType","text":"<p>a reference counted byte buffer</p> <p>Syntax: <code>!util.buffer</code></p> <p>A reference counted byte buffer that models a pointer, offset, and length.</p>"},{"location":"reference/mlir-dialects/Util/#listtype","title":"ListType","text":"<p>dense list container type</p> <p>Syntax:</p> <pre><code>!util.list&lt;\n  Type   # element_type\n&gt;\n</code></pre> <p>Typed container supporting variant storage.</p>"},{"location":"reference/mlir-dialects/Util/#parameters","title":"Parameters:","text":"Parameter C++ type Description element_type <code>Type</code>"},{"location":"reference/mlir-dialects/Util/#objecttype","title":"ObjectType","text":"<p>a placeholder for an unspecified object type</p> <p>Syntax: <code>!util.object</code></p> <p>Describes a runtime object type. These may be reference counted or garbage collected at runtime.</p>"},{"location":"reference/mlir-dialects/Util/#ptrtype","title":"PtrType","text":"<p>a pointer-like reference</p> <p>Syntax:</p> <pre><code>!util.ptr&lt;\n  Type   # target_type\n&gt;\n</code></pre> <p>A typed indirect reference to a value. These define a runtime addressable value that is strongly referenced.</p>"},{"location":"reference/mlir-dialects/Util/#parameters_1","title":"Parameters:","text":"Parameter C++ type Description target_type <code>Type</code>"},{"location":"reference/mlir-dialects/Util/#varianttype","title":"VariantType","text":"<p>a placeholder for a variant type (<code>?</code>)</p> <p>Syntax: <code>!util.variant</code></p> <p>Describes a runtime variant type. These may be primitives (i32, f32, etc) or object types.</p>"},{"location":"reference/mlir-dialects/VM/","title":"VM","text":""},{"location":"reference/mlir-dialects/VM/#vm-dialect","title":"'vm' Dialect","text":"<p>A dialect representing operations against an abstract virtual machine.</p> <p>The virtual machine ops are designed to be either serialized to a bytecode representation that can be interpreted at runtime or lowered further to static representations such as LLVM IR, C, etc. The idea is that the types and operations performed are generally just encoding resource ownership rules and control flow that can be represented in many different ways by target runtimes. For example, it should be possible to lower the VM dialect to SPIR-V and run the VM entirely within a persistent Vulkan kernel.</p> <p>With this scalable runtime approach we make some limiting assumptions to keep the required implementations simple. As we assume all real math is happening within dispatch regions the only math we provide is scalar operations used for offset and shape calculations. This also enables simple flow control such as fixed-range loops.</p> <p>Besides integer values the only other storage type is a variant reference modeling an abstract iree_vm_ref_t. This allows automated reference counting to be relied upon by other dialects built on top of the VM dialect and avoids the need for more verbose manual reference counting logic (that may be difficult or impossible to manage given the coroutine-like nature of the VM). Lowering targets can insert the reference counting as needed.</p> <p>The types in the VM dialect correspond to the storage rather than value type, with the interpretation of the type encoded on the op.</p> <ul> <li>'vm' Dialect<ul> <li>Operation definition<ul> <li>Async/fiber ops<ul> <li>vm.yield (VM::YieldOp)</li> </ul> </li> <li>Bitwise shift and rotate ops<ul> <li>vm.shl.i32 (VM::ShlI32Op)</li> <li>vm.shl.i64 (VM::ShlI64Op)</li> <li>vm.shr.i32.s (VM::ShrI32SOp)</li> <li>vm.shr.i32.u (VM::ShrI32UOp)</li> <li>vm.shr.i64.s (VM::ShrI64SOp)</li> <li>vm.shr.i64.u (VM::ShrI64UOp)</li> </ul> </li> <li>Buffer ops<ul> <li>vm.buffer.alloc (VM::BufferAllocOp)</li> <li>vm.buffer.clone (VM::BufferCloneOp)</li> <li>vm.buffer.compare (VM::BufferCompareOp)</li> <li>vm.buffer.copy (VM::BufferCopyOp)</li> <li>vm.buffer.fill.f32 (VM::BufferFillF32Op)</li> <li>vm.buffer.fill.f64 (VM::BufferFillF64Op)</li> <li>vm.buffer.fill.i16 (VM::BufferFillI16Op)</li> <li>vm.buffer.fill.i32 (VM::BufferFillI32Op)</li> <li>vm.buffer.fill.i64 (VM::BufferFillI64Op)</li> <li>vm.buffer.fill.i8 (VM::BufferFillI8Op)</li> <li>vm.buffer.length (VM::BufferLengthOp)</li> <li>vm.buffer.load.f32 (VM::BufferLoadF32Op)</li> <li>vm.buffer.load.f64 (VM::BufferLoadF64Op)</li> <li>vm.buffer.load.i16.s (VM::BufferLoadI16SOp)</li> <li>vm.buffer.load.i16.u (VM::BufferLoadI16UOp)</li> <li>vm.buffer.load.i32 (VM::BufferLoadI32Op)</li> <li>vm.buffer.load.i64 (VM::BufferLoadI64Op)</li> <li>vm.buffer.load.i8.s (VM::BufferLoadI8SOp)</li> <li>vm.buffer.load.i8.u (VM::BufferLoadI8UOp)</li> <li>vm.buffer.store.f32 (VM::BufferStoreF32Op)</li> <li>vm.buffer.store.f64 (VM::BufferStoreF64Op)</li> <li>vm.buffer.store.i16 (VM::BufferStoreI16Op)</li> <li>vm.buffer.store.i32 (VM::BufferStoreI32Op)</li> <li>vm.buffer.store.i64 (VM::BufferStoreI64Op)</li> <li>vm.buffer.store.i8 (VM::BufferStoreI8Op)</li> </ul> </li> <li>Casting and conversion ops<ul> <li>vm.bitcast.f32.i32 (VM::BitcastF32I32Op)</li> <li>vm.bitcast.f64.i64 (VM::BitcastF64I64Op)</li> <li>vm.bitcast.i32.f32 (VM::BitcastI32F32Op)</li> <li>vm.bitcast.i64.f64 (VM::BitcastI64F64Op)</li> <li>vm.cast.any.ref (VM::CastAnyRefOp)</li> <li>vm.cast.f32.si32 (VM::CastF32SI32Op)</li> <li>vm.cast.f32.ui32 (VM::CastF32UI32Op)</li> <li>vm.cast.ref.any (VM::CastRefAnyOp)</li> <li>vm.cast.si32.f32 (VM::CastSI32F32Op)</li> <li>vm.cast.ui32.f32 (VM::CastUI32F32Op)</li> <li>vm.ext.f32.f64 (VM::ExtF32F64Op)</li> <li>vm.ext.i16.i32.s (VM::ExtI16I32SOp)</li> <li>vm.ext.i16.i32.u (VM::ExtI16I32UOp)</li> <li>vm.ext.i16.i64.s (VM::ExtI16I64SOp)</li> <li>vm.ext.i16.i64.u (VM::ExtI16I64UOp)</li> <li>vm.ext.i32.i64.s (VM::ExtI32I64SOp)</li> <li>vm.ext.i32.i64.u (VM::ExtI32I64UOp)</li> <li>vm.ext.i8.i32.s (VM::ExtI8I32SOp)</li> <li>vm.ext.i8.i32.u (VM::ExtI8I32UOp)</li> <li>vm.ext.i8.i64.s (VM::ExtI8I64SOp)</li> <li>vm.ext.i8.i64.u (VM::ExtI8I64UOp)</li> <li>vm.trunc.f64.f32 (VM::TruncF64F32Op)</li> <li>vm.trunc.i32.i16 (VM::TruncI32I16Op)</li> <li>vm.trunc.i32.i8 (VM::TruncI32I8Op)</li> <li>vm.trunc.i64.i16 (VM::TruncI64I16Op)</li> <li>vm.trunc.i64.i32 (VM::TruncI64I32Op)</li> <li>vm.trunc.i64.i8 (VM::TruncI64I8Op)</li> </ul> </li> <li>Comparison ops<ul> <li>vm.cmp.eq.i32 (VM::CmpEQI32Op)</li> <li>vm.cmp.eq.i64 (VM::CmpEQI64Op)</li> <li>vm.cmp.gte.i32.s (VM::CmpGTEI32SOp)</li> <li>vm.cmp.gte.i32.u (VM::CmpGTEI32UOp)</li> <li>vm.cmp.gte.i64.s (VM::CmpGTEI64SOp)</li> <li>vm.cmp.gte.i64.u (VM::CmpGTEI64UOp)</li> <li>vm.cmp.gt.i32.s (VM::CmpGTI32SOp)</li> <li>vm.cmp.gt.i32.u (VM::CmpGTI32UOp)</li> <li>vm.cmp.gt.i64.s (VM::CmpGTI64SOp)</li> <li>vm.cmp.gt.i64.u (VM::CmpGTI64UOp)</li> <li>vm.cmp.lte.i32.s (VM::CmpLTEI32SOp)</li> <li>vm.cmp.lte.i32.u (VM::CmpLTEI32UOp)</li> <li>vm.cmp.lte.i64.s (VM::CmpLTEI64SOp)</li> <li>vm.cmp.lte.i64.u (VM::CmpLTEI64UOp)</li> <li>vm.cmp.lt.i32.s (VM::CmpLTI32SOp)</li> <li>vm.cmp.lt.i32.u (VM::CmpLTI32UOp)</li> <li>vm.cmp.lt.i64.s (VM::CmpLTI64SOp)</li> <li>vm.cmp.lt.i64.u (VM::CmpLTI64UOp)</li> <li>vm.cmp.ne.i32 (VM::CmpNEI32Op)</li> <li>vm.cmp.ne.i64 (VM::CmpNEI64Op)</li> <li>vm.cmp.nz.i32 (VM::CmpNZI32Op)</li> <li>vm.cmp.nz.i64 (VM::CmpNZI64Op)</li> </ul> </li> <li>Conditional assignment ops<ul> <li>vm.select.f32 (VM::SelectF32Op)</li> <li>vm.select.f64 (VM::SelectF64Op)</li> <li>vm.select.i32 (VM::SelectI32Op)</li> <li>vm.select.i64 (VM::SelectI64Op)</li> <li>vm.select.ref (VM::SelectRefOp)</li> <li>vm.switch.f32 (VM::SwitchF32Op)</li> <li>vm.switch.f64 (VM::SwitchF64Op)</li> <li>vm.switch.i32 (VM::SwitchI32Op)</li> <li>vm.switch.i64 (VM::SwitchI64Op)</li> <li>vm.switch.ref (VM::SwitchRefOp)</li> </ul> </li> <li>Constant ops<ul> <li>vm.const.f32 (VM::ConstF32Op)</li> <li>vm.const.f32.zero (VM::ConstF32ZeroOp)</li> <li>vm.const.f64 (VM::ConstF64Op)</li> <li>vm.const.f64.zero (VM::ConstF64ZeroOp)</li> <li>vm.const.i32 (VM::ConstI32Op)</li> <li>vm.const.i32.zero (VM::ConstI32ZeroOp)</li> <li>vm.const.i64 (VM::ConstI64Op)</li> <li>vm.const.i64.zero (VM::ConstI64ZeroOp)</li> <li>vm.const.ref.rodata (VM::ConstRefRodataOp)</li> <li>vm.const.ref.zero (VM::ConstRefZeroOp)</li> <li>vm.rodata.inline (VM::RodataInlineOp)</li> <li>vm.rodata (VM::RodataOp)</li> </ul> </li> <li>Control flow ops<ul> <li>vm.br (VM::BranchOp)</li> <li>vm.call (VM::CallOp)</li> <li>vm.call.variadic (VM::CallVariadicOp)</li> <li>vm.check.eq (VM::CheckEQOp)</li> <li>vm.check.ne (VM::CheckNEOp)</li> <li>vm.check.nz (VM::CheckNZOp)</li> <li>vm.check.nearly_eq (VM::CheckNearlyEQOp)</li> <li>vm.cond_br (VM::CondBranchOp)</li> <li>vm.cond_fail (VM::CondFailOp)</li> <li>vm.fail (VM::FailOp)</li> <li>vm.import.resolved (VM::ImportResolvedOp)</li> <li>vm.return (VM::ReturnOp)</li> </ul> </li> <li>Debugging ops<ul> <li>vm.break (VM::BreakOp)</li> <li>vm.cond_break (VM::CondBreakOp)</li> <li>vm.print (VM::PrintOp)</li> <li>vm.trace (VM::TraceOp)</li> </ul> </li> <li>Floating-point arithmetic ops<ul> <li>vm.abs.f32 (VM::AbsF32Op)</li> <li>vm.abs.f64 (VM::AbsF64Op)</li> <li>vm.add.f32 (VM::AddF32Op)</li> <li>vm.add.f64 (VM::AddF64Op)</li> <li>vm.ceil.f32 (VM::CeilF32Op)</li> <li>vm.ceil.f64 (VM::CeilF64Op)</li> <li>vm.div.f32 (VM::DivF32Op)</li> <li>vm.div.f64 (VM::DivF64Op)</li> <li>vm.fma.f32 (VM::FMAF32Op)</li> <li>vm.fma.f64 (VM::FMAF64Op)</li> <li>vm.floor.f32 (VM::FloorF32Op)</li> <li>vm.floor.f64 (VM::FloorF64Op)</li> <li>vm.max.f32 (VM::MaxF32Op)</li> <li>vm.max.f64 (VM::MaxF64Op)</li> <li>vm.min.f32 (VM::MinF32Op)</li> <li>vm.min.f64 (VM::MinF64Op)</li> <li>vm.mul.f32 (VM::MulF32Op)</li> <li>vm.mul.f64 (VM::MulF64Op)</li> <li>vm.neg.f32 (VM::NegF32Op)</li> <li>vm.neg.f64 (VM::NegF64Op)</li> <li>vm.rem.f32 (VM::RemF32Op)</li> <li>vm.rem.f64 (VM::RemF64Op)</li> <li>vm.round.f32.even (VM::RoundF32EvenOp)</li> <li>vm.round.f32 (VM::RoundF32Op)</li> <li>vm.round.f64.even (VM::RoundF64EvenOp)</li> <li>vm.round.f64 (VM::RoundF64Op)</li> <li>vm.sub.f32 (VM::SubF32Op)</li> <li>vm.sub.f64 (VM::SubF64Op)</li> </ul> </li> <li>Floating-point comparison ops<ul> <li>vm.cmp.eq.f32.near (VM::CmpEQF32NearOp)</li> <li>vm.cmp.eq.f32.o (VM::CmpEQF32OOp)</li> <li>vm.cmp.eq.f32.u (VM::CmpEQF32UOp)</li> <li>vm.cmp.eq.f64.near (VM::CmpEQF64NearOp)</li> <li>vm.cmp.eq.f64.o (VM::CmpEQF64OOp)</li> <li>vm.cmp.eq.f64.u (VM::CmpEQF64UOp)</li> <li>vm.cmp.gte.f32.o (VM::CmpGTEF32OOp)</li> <li>vm.cmp.gte.f32.u (VM::CmpGTEF32UOp)</li> <li>vm.cmp.gte.f64.o (VM::CmpGTEF64OOp)</li> <li>vm.cmp.gte.f64.u (VM::CmpGTEF64UOp)</li> <li>vm.cmp.gt.f32.o (VM::CmpGTF32OOp)</li> <li>vm.cmp.gt.f32.u (VM::CmpGTF32UOp)</li> <li>vm.cmp.gt.f64.o (VM::CmpGTF64OOp)</li> <li>vm.cmp.gt.f64.u (VM::CmpGTF64UOp)</li> <li>vm.cmp.lte.f32.o (VM::CmpLTEF32OOp)</li> <li>vm.cmp.lte.f32.u (VM::CmpLTEF32UOp)</li> <li>vm.cmp.lte.f64.o (VM::CmpLTEF64OOp)</li> <li>vm.cmp.lte.f64.u (VM::CmpLTEF64UOp)</li> <li>vm.cmp.lt.f32.o (VM::CmpLTF32OOp)</li> <li>vm.cmp.lt.f32.u (VM::CmpLTF32UOp)</li> <li>vm.cmp.lt.f64.o (VM::CmpLTF64OOp)</li> <li>vm.cmp.lt.f64.u (VM::CmpLTF64UOp)</li> <li>vm.cmp.ne.f32.o (VM::CmpNEF32OOp)</li> <li>vm.cmp.ne.f32.u (VM::CmpNEF32UOp)</li> <li>vm.cmp.ne.f64.o (VM::CmpNEF64OOp)</li> <li>vm.cmp.ne.f64.u (VM::CmpNEF64UOp)</li> <li>vm.cmp.nz.f32.o (VM::CmpNZF32OOp)</li> <li>vm.cmp.nz.f32.u (VM::CmpNZF32UOp)</li> <li>vm.cmp.nz.f64.o (VM::CmpNZF64OOp)</li> <li>vm.cmp.nz.f64.u (VM::CmpNZF64UOp)</li> <li>vm.cmp.nan.f32 (VM::CmpNaNF32Op)</li> <li>vm.cmp.nan.f64 (VM::CmpNaNF64Op)</li> </ul> </li> <li>Floating-point math ops<ul> <li>vm.atan2.f32 (VM::Atan2F32Op)</li> <li>vm.atan2.f64 (VM::Atan2F64Op)</li> <li>vm.atan.f32 (VM::AtanF32Op)</li> <li>vm.atan.f64 (VM::AtanF64Op)</li> <li>vm.cos.f32 (VM::CosF32Op)</li> <li>vm.cos.f64 (VM::CosF64Op)</li> <li>vm.erf.f32 (VM::ErfF32Op)</li> <li>vm.erf.f64 (VM::ErfF64Op)</li> <li>vm.exp2.f32 (VM::Exp2F32Op)</li> <li>vm.exp2.f64 (VM::Exp2F64Op)</li> <li>vm.exp.f32 (VM::ExpF32Op)</li> <li>vm.exp.f64 (VM::ExpF64Op)</li> <li>vm.expm1.f32 (VM::ExpM1F32Op)</li> <li>vm.expm1.f64 (VM::ExpM1F64Op)</li> <li>vm.log10.f32 (VM::Log10F32Op)</li> <li>vm.log10.f64 (VM::Log10F64Op)</li> <li>vm.log1p.f32 (VM::Log1pF32Op)</li> <li>vm.log1p.f64 (VM::Log1pF64Op)</li> <li>vm.log2.f32 (VM::Log2F32Op)</li> <li>vm.log2.f64 (VM::Log2F64Op)</li> <li>vm.log.f32 (VM::LogF32Op)</li> <li>vm.log.f64 (VM::LogF64Op)</li> <li>vm.pow.f32 (VM::PowF32Op)</li> <li>vm.pow.f64 (VM::PowF64Op)</li> <li>vm.rsqrt.f32 (VM::RsqrtF32Op)</li> <li>vm.rsqrt.f64 (VM::RsqrtF64Op)</li> <li>vm.sin.f32 (VM::SinF32Op)</li> <li>vm.sin.f64 (VM::SinF64Op)</li> <li>vm.sqrt.f32 (VM::SqrtF32Op)</li> <li>vm.sqrt.f64 (VM::SqrtF64Op)</li> <li>vm.tanh.f32 (VM::TanhF32Op)</li> <li>vm.tanh.f64 (VM::TanhF64Op)</li> </ul> </li> <li>Global ops<ul> <li>vm.global.address (VM::GlobalAddressOp)</li> <li>vm.global.f32 (VM::GlobalF32Op)</li> <li>vm.global.f64 (VM::GlobalF64Op)</li> <li>vm.global.i32 (VM::GlobalI32Op)</li> <li>vm.global.i64 (VM::GlobalI64Op)</li> <li>vm.global.load.f32 (VM::GlobalLoadF32Op)</li> <li>vm.global.load.f64 (VM::GlobalLoadF64Op)</li> <li>vm.global.load.i32 (VM::GlobalLoadI32Op)</li> <li>vm.global.load.i64 (VM::GlobalLoadI64Op)</li> <li>vm.global.load.indirect.f32 (VM::GlobalLoadIndirectF32Op)</li> <li>vm.global.load.indirect.f64 (VM::GlobalLoadIndirectF64Op)</li> <li>vm.global.load.indirect.i32 (VM::GlobalLoadIndirectI32Op)</li> <li>vm.global.load.indirect.i64 (VM::GlobalLoadIndirectI64Op)</li> <li>vm.global.load.indirect.ref (VM::GlobalLoadIndirectRefOp)</li> <li>vm.global.load.ref (VM::GlobalLoadRefOp)</li> <li>vm.global.ref (VM::GlobalRefOp)</li> <li>vm.global.store.f32 (VM::GlobalStoreF32Op)</li> <li>vm.global.store.f64 (VM::GlobalStoreF64Op)</li> <li>vm.global.store.i32 (VM::GlobalStoreI32Op)</li> <li>vm.global.store.i64 (VM::GlobalStoreI64Op)</li> <li>vm.global.store.indirect.f32 (VM::GlobalStoreIndirectF32Op)</li> <li>vm.global.store.indirect.f64 (VM::GlobalStoreIndirectF64Op)</li> <li>vm.global.store.indirect.i32 (VM::GlobalStoreIndirectI32Op)</li> <li>vm.global.store.indirect.i64 (VM::GlobalStoreIndirectI64Op)</li> <li>vm.global.store.indirect.ref (VM::GlobalStoreIndirectRefOp)</li> <li>vm.global.store.ref (VM::GlobalStoreRefOp)</li> </ul> </li> <li>Integer arithmetic ops<ul> <li>vm.abs.i32 (VM::AbsI32Op)</li> <li>vm.abs.i64 (VM::AbsI64Op)</li> <li>vm.add.i32 (VM::AddI32Op)</li> <li>vm.add.i64 (VM::AddI64Op)</li> <li>vm.div.i32.s (VM::DivI32SOp)</li> <li>vm.div.i32.u (VM::DivI32UOp)</li> <li>vm.div.i64.s (VM::DivI64SOp)</li> <li>vm.div.i64.u (VM::DivI64UOp)</li> <li>vm.fma.i32 (VM::FMAI32Op)</li> <li>vm.fma.i64 (VM::FMAI64Op)</li> <li>vm.max.i32.s (VM::MaxI32SOp)</li> <li>vm.max.i32.u (VM::MaxI32UOp)</li> <li>vm.max.i64.s (VM::MaxI64SOp)</li> <li>vm.max.i64.u (VM::MaxI64UOp)</li> <li>vm.min.i32.s (VM::MinI32SOp)</li> <li>vm.min.i32.u (VM::MinI32UOp)</li> <li>vm.min.i64.s (VM::MinI64SOp)</li> <li>vm.min.i64.u (VM::MinI64UOp)</li> <li>vm.mul.i32 (VM::MulI32Op)</li> <li>vm.mul.i64 (VM::MulI64Op)</li> <li>vm.rem.i32.s (VM::RemI32SOp)</li> <li>vm.rem.i32.u (VM::RemI32UOp)</li> <li>vm.rem.i64.s (VM::RemI64SOp)</li> <li>vm.rem.i64.u (VM::RemI64UOp)</li> <li>vm.sub.i32 (VM::SubI32Op)</li> <li>vm.sub.i64 (VM::SubI64Op)</li> </ul> </li> <li>Integer bit manipulation ops<ul> <li>vm.and.i32 (VM::AndI32Op)</li> <li>vm.and.i64 (VM::AndI64Op)</li> <li>vm.ctlz.i32 (VM::CtlzI32Op)</li> <li>vm.ctlz.i64 (VM::CtlzI64Op)</li> <li>vm.not.i32 (VM::NotI32Op)</li> <li>vm.not.i64 (VM::NotI64Op)</li> <li>vm.or.i32 (VM::OrI32Op)</li> <li>vm.or.i64 (VM::OrI64Op)</li> <li>vm.xor.i32 (VM::XorI32Op)</li> <li>vm.xor.i64 (VM::XorI64Op)</li> </ul> </li> <li>List ops<ul> <li>vm.list.alloc (VM::ListAllocOp)</li> <li>vm.list.get.f32 (VM::ListGetF32Op)</li> <li>vm.list.get.f64 (VM::ListGetF64Op)</li> <li>vm.list.get.i32 (VM::ListGetI32Op)</li> <li>vm.list.get.i64 (VM::ListGetI64Op)</li> <li>vm.list.get.ref (VM::ListGetRefOp)</li> <li>vm.list.reserve (VM::ListReserveOp)</li> <li>vm.list.resize (VM::ListResizeOp)</li> <li>vm.list.set.f32 (VM::ListSetF32Op)</li> <li>vm.list.set.f64 (VM::ListSetF64Op)</li> <li>vm.list.set.i32 (VM::ListSetI32Op)</li> <li>vm.list.set.i64 (VM::ListSetI64Op)</li> <li>vm.list.set.ref (VM::ListSetRefOp)</li> <li>vm.list.size (VM::ListSizeOp)</li> </ul> </li> <li>Ref comparison ops<ul> <li>vm.cmp.eq.ref (VM::CmpEQRefOp)</li> <li>vm.cmp.ne.ref (VM::CmpNERefOp)</li> <li>vm.cmp.nz.ref (VM::CmpNZRefOp)</li> </ul> </li> <li>Structural ops<ul> <li>vm.export (VM::ExportOp)</li> <li>vm.func (VM::FuncOp)</li> <li>vm.import (VM::ImportOp)</li> <li>vm.initializer (VM::InitializerOp)</li> <li>vm.module (VM::ModuleOp)</li> <li>vm.module_terminator (VM::ModuleTerminatorOp)</li> </ul> </li> </ul> </li> <li>Attribute definition<ul> <li>OrdinalCountsAttr</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/mlir-dialects/VM/#operation-definition","title":"Operation definition","text":""},{"location":"reference/mlir-dialects/VM/#asyncfiber-ops","title":"Async/fiber ops","text":""},{"location":"reference/mlir-dialects/VM/#vmyield-vmyieldop","title":"<code>vm.yield</code> (VM::YieldOp)","text":"<p>Unconditional fiber yield operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.yield` $dest (`(` $destOperands^ `:` type($destOperands) `)`)? attr-dict\n</code></pre> <p>Yields the fiber for some (likely short) amount of time. This can be used to  perform cooperative scheduling and ensure fair (enough) execution. Execution  resumes at the specified target branch.</p> <p><code>^bb0:    vm.yield ^on_resume  ^on_resume:    ...</code></p> <p>Traits: HasParent, Terminator, Util_YieldPoint <p>Interfaces: BranchOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands","title":"Operands:","text":"Operand Description <code>destOperands</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#successors","title":"Successors:","text":"Successor Description <code>dest</code> any successor"},{"location":"reference/mlir-dialects/VM/#bitwise-shift-and-rotate-ops","title":"Bitwise shift and rotate ops","text":""},{"location":"reference/mlir-dialects/VM/#vmshli32-vmshli32op","title":"<code>vm.shl.i32</code> (VM::ShlI32Op)","text":"<p>Integer shift left operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.shl.i32` $operand `,` $amount attr-dict `:` type($operand)\n</code></pre> <p>Shifts the operand in a direction by the number of bits specified.</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_1","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer <code>amount</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmshli64-vmshli64op","title":"<code>vm.shl.i64</code> (VM::ShlI64Op)","text":"<p>Integer shift left operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.shl.i64` $operand `,` $amount attr-dict `:` type($operand)\n</code></pre> <p>Shifts the operand in a direction by the number of bits specified.</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_2","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit signless integer <code>amount</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_1","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmshri32s-vmshri32sop","title":"<code>vm.shr.i32.s</code> (VM::ShrI32SOp)","text":"<p>Signed integer (arithmetic) shift right operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.shr.i32.s` $operand `,` $amount attr-dict `:` type($operand)\n</code></pre> <p>Shifts the operand in a direction by the number of bits specified.</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_3","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer <code>amount</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_2","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmshri32u-vmshri32uop","title":"<code>vm.shr.i32.u</code> (VM::ShrI32UOp)","text":"<p>Unsigned integer (logical) shift right operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.shr.i32.u` $operand `,` $amount attr-dict `:` type($operand)\n</code></pre> <p>Shifts the operand in a direction by the number of bits specified.</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_4","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer <code>amount</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_3","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmshri64s-vmshri64sop","title":"<code>vm.shr.i64.s</code> (VM::ShrI64SOp)","text":"<p>Signed integer (arithmetic) shift right operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.shr.i64.s` $operand `,` $amount attr-dict `:` type($operand)\n</code></pre> <p>Shifts the operand in a direction by the number of bits specified.</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_5","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit signless integer <code>amount</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_4","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmshri64u-vmshri64uop","title":"<code>vm.shr.i64.u</code> (VM::ShrI64UOp)","text":"<p>Unsigned integer (logical) shift right operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.shr.i64.u` $operand `,` $amount attr-dict `:` type($operand)\n</code></pre> <p>Shifts the operand in a direction by the number of bits specified.</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_6","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit signless integer <code>amount</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_5","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#buffer-ops","title":"Buffer ops","text":""},{"location":"reference/mlir-dialects/VM/#vmbufferalloc-vmbufferallocop","title":"<code>vm.buffer.alloc</code> (VM::BufferAllocOp)","text":"<p>Allocates a new zero-initialized buffer</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.alloc` operands attr-dict `:` type($result)\n</code></pre> <p>Allocates a new zero-initialized buffer with the given size in bytes.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_7","title":"Operands:","text":"Operand Description <code>length</code> 64-bit signless integer <code>alignment</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_6","title":"Results:","text":"Result Description <code>result</code> ref"},{"location":"reference/mlir-dialects/VM/#vmbufferclone-vmbuffercloneop","title":"<code>vm.buffer.clone</code> (VM::BufferCloneOp)","text":"<p>Clones a buffer</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.clone` operands attr-dict `:` type($source_buffer) `-&gt;` type($result)\n</code></pre> <p>Clones a range of the source buffer to produce a mutable buffer with the same contents.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource, MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_8","title":"Operands:","text":"Operand Description <code>source_buffer</code> ref <code>source_offset</code> 64-bit signless integer <code>length</code> 64-bit signless integer <code>alignment</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_7","title":"Results:","text":"Result Description <code>result</code> ref"},{"location":"reference/mlir-dialects/VM/#vmbuffercompare-vmbuffercompareop","title":"<code>vm.buffer.compare</code> (VM::BufferCompareOp)","text":"<p>Compares a range of a buffer to another</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.compare` operands attr-dict `:` type($lhs_buffer) `,` type($rhs_buffer)\n</code></pre> <p>Returns 1 if the two ranges are bitwise equivalent, somewhat like memcmp.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource, MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_9","title":"Operands:","text":"Operand Description <code>lhs_buffer</code> ref <code>lhs_offset</code> 64-bit signless integer <code>rhs_buffer</code> ref <code>rhs_offset</code> 64-bit signless integer <code>length</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_8","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbuffercopy-vmbuffercopyop","title":"<code>vm.buffer.copy</code> (VM::BufferCopyOp)","text":"<p>Copies a range of a buffer to another</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.copy` operands attr-dict `:` type($source_buffer) `-&gt;` type($target_buffer)\n</code></pre> <p>Copies a range of one buffer to another, like memcpy.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource, MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_10","title":"Operands:","text":"Operand Description <code>source_buffer</code> ref <code>source_offset</code> 64-bit signless integer <code>target_buffer</code> ref <code>target_offset</code> 64-bit signless integer <code>length</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferfillf32-vmbufferfillf32op","title":"<code>vm.buffer.fill.f32</code> (VM::BufferFillF32Op)","text":"<p>Fills the buffer with the given repeating 32-bit value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.fill.f32` $target_buffer `,` $target_offset `,` $length `,` $value\n              attr-dict `:` type($value) `-&gt;` type($target_buffer)\n</code></pre> <p>Fills an element range of the buffer with the given value, like memset.</p> <p>Traits: VM_ExtF32</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_11","title":"Operands:","text":"Operand Description <code>target_buffer</code> ref <code>target_offset</code> 64-bit signless integer <code>length</code> 64-bit signless integer <code>value</code> 32-bit float or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferfillf64-vmbufferfillf64op","title":"<code>vm.buffer.fill.f64</code> (VM::BufferFillF64Op)","text":"<p>Fills the buffer with the given repeating 64-bit value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.fill.f64` $target_buffer `,` $target_offset `,` $length `,` $value\n              attr-dict `:` type($value) `-&gt;` type($target_buffer)\n</code></pre> <p>Fills an element range of the buffer with the given value, like memset.</p> <p>Traits: VM_ExtF64</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_12","title":"Operands:","text":"Operand Description <code>target_buffer</code> ref <code>target_offset</code> 64-bit signless integer <code>length</code> 64-bit signless integer <code>value</code> 64-bit float or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferfilli16-vmbufferfilli16op","title":"<code>vm.buffer.fill.i16</code> (VM::BufferFillI16Op)","text":"<p>Fills the buffer with the given repeating 16-bit value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.fill.i16` $target_buffer `,` $target_offset `,` $length `,` $value\n              attr-dict `:` type($value) `-&gt;` type($target_buffer)\n</code></pre> <p>Fills an element range of the buffer with the given value, like memset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_13","title":"Operands:","text":"Operand Description <code>target_buffer</code> ref <code>target_offset</code> 64-bit signless integer <code>length</code> 64-bit signless integer <code>value</code> 16-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferfilli32-vmbufferfilli32op","title":"<code>vm.buffer.fill.i32</code> (VM::BufferFillI32Op)","text":"<p>Fills the buffer with the given repeating 32-bit value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.fill.i32` $target_buffer `,` $target_offset `,` $length `,` $value\n              attr-dict `:` type($value) `-&gt;` type($target_buffer)\n</code></pre> <p>Fills an element range of the buffer with the given value, like memset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_14","title":"Operands:","text":"Operand Description <code>target_buffer</code> ref <code>target_offset</code> 64-bit signless integer <code>length</code> 64-bit signless integer <code>value</code> 32-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferfilli64-vmbufferfilli64op","title":"<code>vm.buffer.fill.i64</code> (VM::BufferFillI64Op)","text":"<p>Fills the buffer with the given repeating 64-bit value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.fill.i64` $target_buffer `,` $target_offset `,` $length `,` $value\n              attr-dict `:` type($value) `-&gt;` type($target_buffer)\n</code></pre> <p>Fills an element range of the buffer with the given value, like memset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_15","title":"Operands:","text":"Operand Description <code>target_buffer</code> ref <code>target_offset</code> 64-bit signless integer <code>length</code> 64-bit signless integer <code>value</code> 64-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferfilli8-vmbufferfilli8op","title":"<code>vm.buffer.fill.i8</code> (VM::BufferFillI8Op)","text":"<p>Fills the buffer with the given repeating 8-bit value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.fill.i8` $target_buffer `,` $target_offset `,` $length `,` $value\n              attr-dict `:` type($value) `-&gt;` type($target_buffer)\n</code></pre> <p>Fills an element range of the buffer with the given value, like memset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_16","title":"Operands:","text":"Operand Description <code>target_buffer</code> ref <code>target_offset</code> 64-bit signless integer <code>length</code> 64-bit signless integer <code>value</code> 8-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferlength-vmbufferlengthop","title":"<code>vm.buffer.length</code> (VM::BufferLengthOp)","text":"<p>Returns the byte length of a buffer</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.length` operands attr-dict `:` type($buffer) `-&gt;` type($result)\n</code></pre> <p>Returns the total byte length of the given buffer. This is the exact value as specified during buffer allocation though the underlying system buffer may have additional padding.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_17","title":"Operands:","text":"Operand Description <code>buffer</code> ref"},{"location":"reference/mlir-dialects/VM/#results_9","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferloadf32-vmbufferloadf32op","title":"<code>vm.buffer.load.f32</code> (VM::BufferLoadF32Op)","text":"<p>32-bit floating-point load</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.load.f32` $source_buffer `[` $source_offset `]`\n              attr-dict `:` type($source_buffer) `-&gt;` type($result)\n</code></pre> <p>Loads a value from the buffer at the given element offset.</p> <p>Traits: VM_ExtF32</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_18","title":"Operands:","text":"Operand Description <code>source_buffer</code> ref <code>source_offset</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_10","title":"Results:","text":"Result Description <code>result</code> 32-bit float or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferloadf64-vmbufferloadf64op","title":"<code>vm.buffer.load.f64</code> (VM::BufferLoadF64Op)","text":"<p>64-bit floating-point load</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.load.f64` $source_buffer `[` $source_offset `]`\n              attr-dict `:` type($source_buffer) `-&gt;` type($result)\n</code></pre> <p>Loads a value from the buffer at the given element offset.</p> <p>Traits: VM_ExtF64</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_19","title":"Operands:","text":"Operand Description <code>source_buffer</code> ref <code>source_offset</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_11","title":"Results:","text":"Result Description <code>result</code> 64-bit float or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferloadi16s-vmbufferloadi16sop","title":"<code>vm.buffer.load.i16.s</code> (VM::BufferLoadI16SOp)","text":"<p>Signed 16-bit integer load</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.load.i16.s` $source_buffer `[` $source_offset `]`\n              attr-dict `:` type($source_buffer) `-&gt;` type($result)\n</code></pre> <p>Loads a value from the buffer at the given element offset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_20","title":"Operands:","text":"Operand Description <code>source_buffer</code> ref <code>source_offset</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_12","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferloadi16u-vmbufferloadi16uop","title":"<code>vm.buffer.load.i16.u</code> (VM::BufferLoadI16UOp)","text":"<p>Unsigned 16-bit integer load</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.load.i16.u` $source_buffer `[` $source_offset `]`\n              attr-dict `:` type($source_buffer) `-&gt;` type($result)\n</code></pre> <p>Loads a value from the buffer at the given element offset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_21","title":"Operands:","text":"Operand Description <code>source_buffer</code> ref <code>source_offset</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_13","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferloadi32-vmbufferloadi32op","title":"<code>vm.buffer.load.i32</code> (VM::BufferLoadI32Op)","text":"<p>32-bit integer load</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.load.i32` $source_buffer `[` $source_offset `]`\n              attr-dict `:` type($source_buffer) `-&gt;` type($result)\n</code></pre> <p>Loads a value from the buffer at the given element offset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_22","title":"Operands:","text":"Operand Description <code>source_buffer</code> ref <code>source_offset</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_14","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferloadi64-vmbufferloadi64op","title":"<code>vm.buffer.load.i64</code> (VM::BufferLoadI64Op)","text":"<p>64-bit integer load</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.load.i64` $source_buffer `[` $source_offset `]`\n              attr-dict `:` type($source_buffer) `-&gt;` type($result)\n</code></pre> <p>Loads a value from the buffer at the given element offset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_23","title":"Operands:","text":"Operand Description <code>source_buffer</code> ref <code>source_offset</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_15","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferloadi8s-vmbufferloadi8sop","title":"<code>vm.buffer.load.i8.s</code> (VM::BufferLoadI8SOp)","text":"<p>Signed 8-bit integer load</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.load.i8.s` $source_buffer `[` $source_offset `]`\n              attr-dict `:` type($source_buffer) `-&gt;` type($result)\n</code></pre> <p>Loads a value from the buffer at the given element offset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_24","title":"Operands:","text":"Operand Description <code>source_buffer</code> ref <code>source_offset</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_16","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferloadi8u-vmbufferloadi8uop","title":"<code>vm.buffer.load.i8.u</code> (VM::BufferLoadI8UOp)","text":"<p>Unsigned 8-bit integer load</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.load.i8.u` $source_buffer `[` $source_offset `]`\n              attr-dict `:` type($source_buffer) `-&gt;` type($result)\n</code></pre> <p>Loads a value from the buffer at the given element offset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_25","title":"Operands:","text":"Operand Description <code>source_buffer</code> ref <code>source_offset</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_17","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferstoref32-vmbufferstoref32op","title":"<code>vm.buffer.store.f32</code> (VM::BufferStoreF32Op)","text":"<p>32-bit floating-point store</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.store.f32` $value `,` $target_buffer `[` $target_offset `]`\n              attr-dict `:` type($value) `-&gt;` type($target_buffer)\n</code></pre> <p>Stores a value to the buffer at the given element offset.</p> <p>Traits: VM_ExtF32</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_26","title":"Operands:","text":"Operand Description <code>target_buffer</code> ref <code>target_offset</code> 64-bit signless integer <code>value</code> 32-bit float or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferstoref64-vmbufferstoref64op","title":"<code>vm.buffer.store.f64</code> (VM::BufferStoreF64Op)","text":"<p>64-bit floating-point store</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.store.f64` $value `,` $target_buffer `[` $target_offset `]`\n              attr-dict `:` type($value) `-&gt;` type($target_buffer)\n</code></pre> <p>Stores a value to the buffer at the given element offset.</p> <p>Traits: VM_ExtF64</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_27","title":"Operands:","text":"Operand Description <code>target_buffer</code> ref <code>target_offset</code> 64-bit signless integer <code>value</code> 64-bit float or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferstorei16-vmbufferstorei16op","title":"<code>vm.buffer.store.i16</code> (VM::BufferStoreI16Op)","text":"<p>Unsigned 16-bit integer store</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.store.i16` $value `,` $target_buffer `[` $target_offset `]`\n              attr-dict `:` type($value) `-&gt;` type($target_buffer)\n</code></pre> <p>Stores a value to the buffer at the given element offset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_28","title":"Operands:","text":"Operand Description <code>target_buffer</code> ref <code>target_offset</code> 64-bit signless integer <code>value</code> 32-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferstorei32-vmbufferstorei32op","title":"<code>vm.buffer.store.i32</code> (VM::BufferStoreI32Op)","text":"<p>32-bit integer store</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.store.i32` $value `,` $target_buffer `[` $target_offset `]`\n              attr-dict `:` type($value) `-&gt;` type($target_buffer)\n</code></pre> <p>Stores a value to the buffer at the given element offset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_29","title":"Operands:","text":"Operand Description <code>target_buffer</code> ref <code>target_offset</code> 64-bit signless integer <code>value</code> 32-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferstorei64-vmbufferstorei64op","title":"<code>vm.buffer.store.i64</code> (VM::BufferStoreI64Op)","text":"<p>64-bit integer store</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.store.i64` $value `,` $target_buffer `[` $target_offset `]`\n              attr-dict `:` type($value) `-&gt;` type($target_buffer)\n</code></pre> <p>Stores a value to the buffer at the given element offset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_30","title":"Operands:","text":"Operand Description <code>target_buffer</code> ref <code>target_offset</code> 64-bit signless integer <code>value</code> 64-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbufferstorei8-vmbufferstorei8op","title":"<code>vm.buffer.store.i8</code> (VM::BufferStoreI8Op)","text":"<p>Unsigned 8-bit integer store</p> <p>Syntax:</p> <pre><code>operation ::= `vm.buffer.store.i8` $value `,` $target_buffer `[` $target_offset `]`\n              attr-dict `:` type($value) `-&gt;` type($target_buffer)\n</code></pre> <p>Stores a value to the buffer at the given element offset.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_31","title":"Operands:","text":"Operand Description <code>target_buffer</code> ref <code>target_offset</code> 64-bit signless integer <code>value</code> 32-bit signless integer or 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#casting-and-conversion-ops","title":"Casting and conversion ops","text":"<p>Casting and type conversion/emulation.</p>"},{"location":"reference/mlir-dialects/VM/#vmbitcastf32i32-vmbitcastf32i32op","title":"<code>vm.bitcast.f32.i32</code> (VM::BitcastF32I32Op)","text":"<p>Bitcast from a 32-bit float-point value to a 32-bit integer</p> <p>Syntax:</p> <pre><code>operation ::= `vm.bitcast.f32.i32` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_32","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_18","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbitcastf64i64-vmbitcastf64i64op","title":"<code>vm.bitcast.f64.i64</code> (VM::BitcastF64I64Op)","text":"<p>Bitcast from a 64-bit float-point value to a 64-bit integer</p> <p>Syntax:</p> <pre><code>operation ::= `vm.bitcast.f64.i64` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_33","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_19","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmbitcasti32f32-vmbitcasti32f32op","title":"<code>vm.bitcast.i32.f32</code> (VM::BitcastI32F32Op)","text":"<p>Bitcast from a 32-bit integer to a 32-bit float-point value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.bitcast.i32.f32` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_34","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_20","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmbitcasti64f64-vmbitcasti64f64op","title":"<code>vm.bitcast.i64.f64</code> (VM::BitcastI64F64Op)","text":"<p>Bitcast from a 64-bit integer to a 64-bit float-point value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.bitcast.i64.f64` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_35","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_21","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmcastanyref-vmcastanyrefop","title":"<code>vm.cast.any.ref</code> (VM::CastAnyRefOp)","text":"<p>Casts from any ref to a specific ref type</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cast.any.ref` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Performs a runtime cast of an opaque <code>!vm.ref&lt;?&gt;</code> to a specific <code>!vm.ref&lt;T&gt;</code> and raises an error if the operand does not match the expected type. Null refs can always be cast between types.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_36","title":"Operands:","text":"Operand Description <code>operand</code> ref"},{"location":"reference/mlir-dialects/VM/#results_22","title":"Results:","text":"Result Description <code>result</code> ref"},{"location":"reference/mlir-dialects/VM/#vmcastf32si32-vmcastf32si32op","title":"<code>vm.cast.f32.si32</code> (VM::CastF32SI32Op)","text":"<p>Cast from a float-point value to a signed integer</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cast.f32.si32` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_37","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_23","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcastf32ui32-vmcastf32ui32op","title":"<code>vm.cast.f32.ui32</code> (VM::CastF32UI32Op)","text":"<p>Cast from an float-point value to an unsigned integer</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cast.f32.ui32` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_38","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_24","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcastrefany-vmcastrefanyop","title":"<code>vm.cast.ref.any</code> (VM::CastRefAnyOp)","text":"<p>Casts from a specific ref to any ref type</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cast.ref.any` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Performs a compile-time widening cast of a specific <code>!vm.ref&lt;T&gt;</code> to an opaque <code>!vm.ref&lt;?&gt;</code>.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_AssignmentOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_39","title":"Operands:","text":"Operand Description <code>operand</code> ref"},{"location":"reference/mlir-dialects/VM/#results_25","title":"Results:","text":"Result Description <code>result</code> ref"},{"location":"reference/mlir-dialects/VM/#vmcastsi32f32-vmcastsi32f32op","title":"<code>vm.cast.si32.f32</code> (VM::CastSI32F32Op)","text":"<p>Cast from a signed integer to a float-point value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cast.si32.f32` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_40","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_26","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmcastui32f32-vmcastui32f32op","title":"<code>vm.cast.ui32.f32</code> (VM::CastUI32F32Op)","text":"<p>Cast from an unsigned integer to a float-point value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cast.ui32.f32` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_41","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_27","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmextf32f64-vmextf32f64op","title":"<code>vm.ext.f32.f64</code> (VM::ExtF32F64Op)","text":"<p>Floating-point zero extend 32 bits to 64 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ext.f32.f64` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_42","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_28","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmexti16i32s-vmexti16i32sop","title":"<code>vm.ext.i16.i32.s</code> (VM::ExtI16I32SOp)","text":"<p>Integer sign extend 16 bits to 32 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ext.i16.i32.s` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_43","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_29","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmexti16i32u-vmexti16i32uop","title":"<code>vm.ext.i16.i32.u</code> (VM::ExtI16I32UOp)","text":"<p>Integer zero extend 16 bits to 32 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ext.i16.i32.u` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_44","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_30","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmexti16i64s-vmexti16i64sop","title":"<code>vm.ext.i16.i64.s</code> (VM::ExtI16I64SOp)","text":"<p>Integer sign extend 16 bits to 64 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ext.i16.i64.s` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_45","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_31","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmexti16i64u-vmexti16i64uop","title":"<code>vm.ext.i16.i64.u</code> (VM::ExtI16I64UOp)","text":"<p>Integer zero extend 16 bits to 64 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ext.i16.i64.u` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_46","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_32","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmexti32i64s-vmexti32i64sop","title":"<code>vm.ext.i32.i64.s</code> (VM::ExtI32I64SOp)","text":"<p>Integer sign extend 32 bits to 64 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ext.i32.i64.s` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_47","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_33","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmexti32i64u-vmexti32i64uop","title":"<code>vm.ext.i32.i64.u</code> (VM::ExtI32I64UOp)","text":"<p>Integer zero extend 32 bits to 64 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ext.i32.i64.u` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_48","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_34","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmexti8i32s-vmexti8i32sop","title":"<code>vm.ext.i8.i32.s</code> (VM::ExtI8I32SOp)","text":"<p>Integer sign extend 8 bits to 32 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ext.i8.i32.s` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_49","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_35","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmexti8i32u-vmexti8i32uop","title":"<code>vm.ext.i8.i32.u</code> (VM::ExtI8I32UOp)","text":"<p>Integer zero extend 8 bits to 32 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ext.i8.i32.u` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_50","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_36","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmexti8i64s-vmexti8i64sop","title":"<code>vm.ext.i8.i64.s</code> (VM::ExtI8I64SOp)","text":"<p>Integer sign extend 8 bits to 64 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ext.i8.i64.s` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_51","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_37","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmexti8i64u-vmexti8i64uop","title":"<code>vm.ext.i8.i64.u</code> (VM::ExtI8I64UOp)","text":"<p>Integer zero extend 8 bits to 64 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ext.i8.i64.u` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_52","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_38","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmtruncf64f32-vmtruncf64f32op","title":"<code>vm.trunc.f64.f32</code> (VM::TruncF64F32Op)","text":"<p>Floating-point truncate to 32 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.trunc.f64.f32` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_53","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_39","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmtrunci32i16-vmtrunci32i16op","title":"<code>vm.trunc.i32.i16</code> (VM::TruncI32I16Op)","text":"<p>Integer truncate to 16 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.trunc.i32.i16` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_54","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_40","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmtrunci32i8-vmtrunci32i8op","title":"<code>vm.trunc.i32.i8</code> (VM::TruncI32I8Op)","text":"<p>Integer truncate to 8 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.trunc.i32.i8` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_55","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_41","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmtrunci64i16-vmtrunci64i16op","title":"<code>vm.trunc.i64.i16</code> (VM::TruncI64I16Op)","text":"<p>Integer truncate to 16 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.trunc.i64.i16` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_56","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_42","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmtrunci64i32-vmtrunci64i32op","title":"<code>vm.trunc.i64.i32</code> (VM::TruncI64I32Op)","text":"<p>Integer truncate to 32 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.trunc.i64.i32` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_57","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_43","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmtrunci64i8-vmtrunci64i8op","title":"<code>vm.trunc.i64.i8</code> (VM::TruncI64I8Op)","text":"<p>Integer truncate to 8 bits</p> <p>Syntax:</p> <pre><code>operation ::= `vm.trunc.i64.i8` $operand attr-dict `:` type($operand) `-&gt;` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_58","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_44","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#comparison-ops","title":"Comparison ops","text":""},{"location":"reference/mlir-dialects/VM/#vmcmpeqi32-vmcmpeqi32op","title":"<code>vm.cmp.eq.i32</code> (VM::CmpEQI32Op)","text":"<p>Integer equality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.eq.i32` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_59","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_45","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpeqi64-vmcmpeqi64op","title":"<code>vm.cmp.eq.i64</code> (VM::CmpEQI64Op)","text":"<p>Integer equality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.eq.i64` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_60","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_46","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgtei32s-vmcmpgtei32sop","title":"<code>vm.cmp.gte.i32.s</code> (VM::CmpGTEI32SOp)","text":"<p>Signed integer greater-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gte.i32.s` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_61","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_47","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgtei32u-vmcmpgtei32uop","title":"<code>vm.cmp.gte.i32.u</code> (VM::CmpGTEI32UOp)","text":"<p>Unsigned integer greater-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gte.i32.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_62","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_48","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgtei64s-vmcmpgtei64sop","title":"<code>vm.cmp.gte.i64.s</code> (VM::CmpGTEI64SOp)","text":"<p>Signed integer greater-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gte.i64.s` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_63","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_49","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgtei64u-vmcmpgtei64uop","title":"<code>vm.cmp.gte.i64.u</code> (VM::CmpGTEI64UOp)","text":"<p>Unsigned integer greater-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gte.i64.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_64","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_50","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgti32s-vmcmpgti32sop","title":"<code>vm.cmp.gt.i32.s</code> (VM::CmpGTI32SOp)","text":"<p>Signed integer greater-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gt.i32.s` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_65","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_51","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgti32u-vmcmpgti32uop","title":"<code>vm.cmp.gt.i32.u</code> (VM::CmpGTI32UOp)","text":"<p>Unsigned integer greater-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gt.i32.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_66","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_52","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgti64s-vmcmpgti64sop","title":"<code>vm.cmp.gt.i64.s</code> (VM::CmpGTI64SOp)","text":"<p>Signed integer greater-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gt.i64.s` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_67","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_53","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgti64u-vmcmpgti64uop","title":"<code>vm.cmp.gt.i64.u</code> (VM::CmpGTI64UOp)","text":"<p>Unsigned integer greater-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gt.i64.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_68","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_54","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpltei32s-vmcmpltei32sop","title":"<code>vm.cmp.lte.i32.s</code> (VM::CmpLTEI32SOp)","text":"<p>Signed integer less-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lte.i32.s` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_69","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_55","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpltei32u-vmcmpltei32uop","title":"<code>vm.cmp.lte.i32.u</code> (VM::CmpLTEI32UOp)","text":"<p>Unsigned integer less-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lte.i32.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_70","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_56","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpltei64s-vmcmpltei64sop","title":"<code>vm.cmp.lte.i64.s</code> (VM::CmpLTEI64SOp)","text":"<p>Signed integer less-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lte.i64.s` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_71","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_57","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpltei64u-vmcmpltei64uop","title":"<code>vm.cmp.lte.i64.u</code> (VM::CmpLTEI64UOp)","text":"<p>Unsigned integer less-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lte.i64.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_72","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_58","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmplti32s-vmcmplti32sop","title":"<code>vm.cmp.lt.i32.s</code> (VM::CmpLTI32SOp)","text":"<p>Signed integer less-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lt.i32.s` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_73","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_59","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmplti32u-vmcmplti32uop","title":"<code>vm.cmp.lt.i32.u</code> (VM::CmpLTI32UOp)","text":"<p>Unsigned integer less-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lt.i32.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_74","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_60","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmplti64s-vmcmplti64sop","title":"<code>vm.cmp.lt.i64.s</code> (VM::CmpLTI64SOp)","text":"<p>Signed integer less-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lt.i64.s` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_75","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_61","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmplti64u-vmcmplti64uop","title":"<code>vm.cmp.lt.i64.u</code> (VM::CmpLTI64UOp)","text":"<p>Unsigned integer less-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lt.i64.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_76","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_62","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnei32-vmcmpnei32op","title":"<code>vm.cmp.ne.i32</code> (VM::CmpNEI32Op)","text":"<p>Integer inequality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.ne.i32` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_77","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_63","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnei64-vmcmpnei64op","title":"<code>vm.cmp.ne.i64</code> (VM::CmpNEI64Op)","text":"<p>Integer inequality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.ne.i64` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_78","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_64","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnzi32-vmcmpnzi32op","title":"<code>vm.cmp.nz.i32</code> (VM::CmpNZI32Op)","text":"<p>Integer non-zero comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.nz.i32` $operand attr-dict `:` type($operand)\n</code></pre> <p>Compares the given integer operand for a non-zero value.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_79","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_65","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnzi64-vmcmpnzi64op","title":"<code>vm.cmp.nz.i64</code> (VM::CmpNZI64Op)","text":"<p>Integer non-zero comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.nz.i64` $operand attr-dict `:` type($operand)\n</code></pre> <p>Compares the given integer operand for a non-zero value.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_80","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_66","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#conditional-assignment-ops","title":"Conditional assignment ops","text":""},{"location":"reference/mlir-dialects/VM/#vmselectf32-vmselectf32op","title":"<code>vm.select.f32</code> (VM::SelectF32Op)","text":"<p>Floating-point select operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.select.f32` operands attr-dict `:` type($result)\n</code></pre> <p>Chooses one value based on a binary condition supplied as its first operand. If the value of the condition is true the <code>true_value</code> operand is chosen, otherwise the <code>false_value</code> operand is chosen. The true and false values must have the same types. For example, the maximum operation is obtained by combining \"select\" with \"cmpi\" as follows:</p> <pre><code>%2 = vm.cmp.gt.i32.s %0, %1 : i32\n%3 = vm.select.i32 %2, %0, %1 : i32\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_81","title":"Operands:","text":"Operand Description <code>condition</code> 32-bit signless integer <code>true_value</code> 32-bit float <code>false_value</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_67","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmselectf64-vmselectf64op","title":"<code>vm.select.f64</code> (VM::SelectF64Op)","text":"<p>Floating-point select operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.select.f64` operands attr-dict `:` type($result)\n</code></pre> <p>Chooses one value based on a binary condition supplied as its first operand. If the value of the condition is true the <code>true_value</code> operand is chosen, otherwise the <code>false_value</code> operand is chosen. The true and false values must have the same types. For example, the maximum operation is obtained by combining \"select\" with \"cmpi\" as follows:</p> <pre><code>%2 = vm.cmp.gt.i32.s %0, %1 : i32\n%3 = vm.select.i32 %2, %0, %1 : i32\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_82","title":"Operands:","text":"Operand Description <code>condition</code> 32-bit signless integer <code>true_value</code> 64-bit float <code>false_value</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_68","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmselecti32-vmselecti32op","title":"<code>vm.select.i32</code> (VM::SelectI32Op)","text":"<p>Integer select operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.select.i32` operands attr-dict `:` type($result)\n</code></pre> <p>Chooses one value based on a binary condition supplied as its first operand. If the value of the condition is true the <code>true_value</code> operand is chosen, otherwise the <code>false_value</code> operand is chosen. The true and false values must have the same types. For example, the maximum operation is obtained by combining \"select\" with \"cmpi\" as follows:</p> <pre><code>%2 = vm.cmp.gt.i32.s %0, %1 : i32\n%3 = vm.select.i32 %2, %0, %1 : i32\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_83","title":"Operands:","text":"Operand Description <code>condition</code> 32-bit signless integer <code>true_value</code> 32-bit signless integer <code>false_value</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_69","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmselecti64-vmselecti64op","title":"<code>vm.select.i64</code> (VM::SelectI64Op)","text":"<p>Integer select operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.select.i64` operands attr-dict `:` type($result)\n</code></pre> <p>Chooses one value based on a binary condition supplied as its first operand. If the value of the condition is true the <code>true_value</code> operand is chosen, otherwise the <code>false_value</code> operand is chosen. The true and false values must have the same types. For example, the maximum operation is obtained by combining \"select\" with \"cmpi\" as follows:</p> <pre><code>%2 = vm.cmp.gt.i32.s %0, %1 : i32\n%3 = vm.select.i32 %2, %0, %1 : i32\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_84","title":"Operands:","text":"Operand Description <code>condition</code> 32-bit signless integer <code>true_value</code> 64-bit signless integer <code>false_value</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_70","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmselectref-vmselectrefop","title":"<code>vm.select.ref</code> (VM::SelectRefOp)","text":"<p>Ref select operation <p>Syntax:</p> <pre><code>operation ::= `vm.select.ref` operands attr-dict `:` type($result)\n</code></pre> <p>Chooses one value based on a binary condition supplied as its first operand. If the value of the condition is true the <code>true_value</code> operand is chosen, otherwise the <code>false_value</code> operand is chosen.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_85","title":"Operands:","text":"Operand Description <code>condition</code> 32-bit signless integer <code>true_value</code> ref <code>false_value</code> ref"},{"location":"reference/mlir-dialects/VM/#results_71","title":"Results:","text":"Result Description <code>result</code> ref"},{"location":"reference/mlir-dialects/VM/#vmswitchf32-vmswitchf32op","title":"<code>vm.switch.f32</code> (VM::SwitchF32Op)","text":"<p>Floating-point switch operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.switch.f32` $index `[` $values `]` `else` $default_value attr-dict `:` type($result)\n</code></pre> <p>Returns the value with the given <code>index</code> in <code>values</code> or <code>default_value</code> if the index is out of bounds.</p> <pre><code>// Switch %index to cases of %c100/%c200/%c300 if index==0, ==1, ==2.\n// If %index is out of range (&lt;0 or &gt;2) then default to %c5.\n%0 = vm.switch.f32 %index[%c100, %c200, %c300] else %c5 : f32\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_86","title":"Operands:","text":"Operand Description <code>index</code> 32-bit signless integer <code>default_value</code> 32-bit float <code>values</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_72","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmswitchf64-vmswitchf64op","title":"<code>vm.switch.f64</code> (VM::SwitchF64Op)","text":"<p>Floating-point switch operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.switch.f64` $index `[` $values `]` `else` $default_value attr-dict `:` type($result)\n</code></pre> <p>Returns the value with the given <code>index</code> in <code>values</code> or <code>default_value</code> if the index is out of bounds.</p> <pre><code>// Switch %index to cases of %c100/%c200/%c300 if index==0, ==1, ==2.\n// If %index is out of range (&lt;0 or &gt;2) then default to %c5.\n%0 = vm.switch.f32 %index[%c100, %c200, %c300] else %c5 : f32\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_87","title":"Operands:","text":"Operand Description <code>index</code> 32-bit signless integer <code>default_value</code> 64-bit float <code>values</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_73","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmswitchi32-vmswitchi32op","title":"<code>vm.switch.i32</code> (VM::SwitchI32Op)","text":"<p>Integer switch operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.switch.i32` $index `[` $values `]` `else` $default_value attr-dict `:` type($result)\n</code></pre> <p>Returns the value with the given <code>index</code> in <code>values</code> or <code>default_value</code> if the index is out of bounds.</p> <pre><code>// Switch %index to cases of %c100/%c200/%c300 if index==0, ==1, ==2.\n// If %index is out of range (&lt;0 or &gt;2) then default to %c5.\n%0 = vm.switch.i32 %index[%c100, %c200, %c300] else %c5 : i32\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_88","title":"Operands:","text":"Operand Description <code>index</code> 32-bit signless integer <code>default_value</code> 32-bit signless integer <code>values</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_74","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmswitchi64-vmswitchi64op","title":"<code>vm.switch.i64</code> (VM::SwitchI64Op)","text":"<p>Integer switch operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.switch.i64` $index `[` $values `]` `else` $default_value attr-dict `:` type($result)\n</code></pre> <p>Returns the value with the given <code>index</code> in <code>values</code> or <code>default_value</code> if the index is out of bounds.</p> <pre><code>// Switch %index to cases of %c100/%c200/%c300 if index==0, ==1, ==2.\n// If %index is out of range (&lt;0 or &gt;2) then default to %c5.\n%0 = vm.switch.i32 %index[%c100, %c200, %c300] else %c5 : i32\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_89","title":"Operands:","text":"Operand Description <code>index</code> 32-bit signless integer <code>default_value</code> 64-bit signless integer <code>values</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_75","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmswitchref-vmswitchrefop","title":"<code>vm.switch.ref</code> (VM::SwitchRefOp)","text":"<p>Ref switch operation <p>Returns the value with the given <code>index</code> in <code>values</code> or <code>default_value</code> if the index is out of bounds.</p> <pre><code>// Switch %arg0 to cases of %r0/%r1/%r2 if arg0==0, ==1, ==2.\n// If %arg0 is out of range (&lt;0 or &gt;2) then default to %null.\n%0 = vm.switch.ref %index[%r0, %r1, %r2] else %null : vm.ref&lt;!foo&gt;\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_90","title":"Operands:","text":"Operand Description <code>index</code> 32-bit signless integer <code>default_value</code> ref <code>values</code> ref"},{"location":"reference/mlir-dialects/VM/#results_76","title":"Results:","text":"Result Description <code>result</code> ref"},{"location":"reference/mlir-dialects/VM/#constant-ops","title":"Constant ops","text":""},{"location":"reference/mlir-dialects/VM/#vmconstf32-vmconstf32op","title":"<code>vm.const.f32</code> (VM::ConstF32Op)","text":"<p>32-bit floating-point constant operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.const.f32` $value attr-dict\n</code></pre> <p>Defines a constant value that is treated as a scalar literal at runtime.</p> <p>Traits: AlwaysSpeculatableImplTrait, ConstantLike, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>value</code> FloatAttr 32-bit floating-point value"},{"location":"reference/mlir-dialects/VM/#results_77","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmconstf32zero-vmconstf32zeroop","title":"<code>vm.const.f32.zero</code> (VM::ConstF32ZeroOp)","text":"<p>32-bit floating-point constant zero operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.const.f32.zero` attr-dict\n</code></pre> <p>Defines a constant zero primitive.</p> <p>Traits: AlwaysSpeculatableImplTrait, ConstantLike, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#results_78","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmconstf64-vmconstf64op","title":"<code>vm.const.f64</code> (VM::ConstF64Op)","text":"<p>64-bit floating-point constant operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.const.f64` $value attr-dict\n</code></pre> <p>Defines a constant value that is treated as a scalar literal at runtime.</p> <p>Traits: AlwaysSpeculatableImplTrait, ConstantLike, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>value</code> FloatAttr 64-bit floating-point value"},{"location":"reference/mlir-dialects/VM/#results_79","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmconstf64zero-vmconstf64zeroop","title":"<code>vm.const.f64.zero</code> (VM::ConstF64ZeroOp)","text":"<p>64-bit floating-point constant zero operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.const.f64.zero` attr-dict\n</code></pre> <p>Defines a constant zero primitive.</p> <p>Traits: AlwaysSpeculatableImplTrait, ConstantLike, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#results_80","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmconsti32-vmconsti32op","title":"<code>vm.const.i32</code> (VM::ConstI32Op)","text":"<p>32-bit integer constant operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.const.i32` $value attr-dict\n</code></pre> <p>Defines a constant value that is treated as a scalar literal at runtime.</p> <p>Traits: AlwaysSpeculatableImplTrait, ConstantLike</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#attributes_2","title":"Attributes:","text":"Attribute MLIR Type Description <code>value</code> IntegerAttr 32-bit integer value"},{"location":"reference/mlir-dialects/VM/#results_81","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmconsti32zero-vmconsti32zeroop","title":"<code>vm.const.i32.zero</code> (VM::ConstI32ZeroOp)","text":"<p>32-bit integer constant zero operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.const.i32.zero` attr-dict\n</code></pre> <p>Defines a constant zero primitive.</p> <p>Traits: AlwaysSpeculatableImplTrait, ConstantLike</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#results_82","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmconsti64-vmconsti64op","title":"<code>vm.const.i64</code> (VM::ConstI64Op)","text":"<p>64-bit integer constant operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.const.i64` $value attr-dict\n</code></pre> <p>Defines a constant value that is treated as a scalar literal at runtime.</p> <p>Traits: AlwaysSpeculatableImplTrait, ConstantLike</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#attributes_3","title":"Attributes:","text":"Attribute MLIR Type Description <code>value</code> IntegerAttr 64-bit integer value"},{"location":"reference/mlir-dialects/VM/#results_83","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmconsti64zero-vmconsti64zeroop","title":"<code>vm.const.i64.zero</code> (VM::ConstI64ZeroOp)","text":"<p>64-bit integer constant zero operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.const.i64.zero` attr-dict\n</code></pre> <p>Defines a constant zero primitive.</p> <p>Traits: AlwaysSpeculatableImplTrait, ConstantLike</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#results_84","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmconstrefrodata-vmconstrefrodataop","title":"<code>vm.const.ref.rodata</code> (VM::ConstRefRodataOp)","text":"<p>Constant rodata access operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.const.ref.rodata` $rodata attr-dict `:` type($value)\n</code></pre> <p>Returns a reference to a read-only buffer.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#attributes_4","title":"Attributes:","text":"Attribute MLIR Type Description <code>rodata</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#results_85","title":"Results:","text":"Result Description <code>value</code> ref"},{"location":"reference/mlir-dialects/VM/#vmconstrefzero-vmconstrefzeroop","title":"<code>vm.const.ref.zero</code> (VM::ConstRefZeroOp)","text":"<p>Null ref constant operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.const.ref.zero` `:` type($result) attr-dict\n</code></pre> <p>Defines a constant null ref that can be used in comparisons and initialization.</p> <p>Traits: AlwaysSpeculatableImplTrait, ConstantLike</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#results_86","title":"Results:","text":"Result Description <code>result</code> ref"},{"location":"reference/mlir-dialects/VM/#vmrodatainline-vmrodatainlineop","title":"<code>vm.rodata.inline</code> (VM::RodataInlineOp)","text":"<p>Inlined constant rodata</p> <p>Syntax:</p> <pre><code>operation ::= `vm.rodata.inline` ($name^)? attr-dict `:` type($result) `=` $value\n</code></pre> <p>vm.rodata that can be embedded inline in functions. See vm.rodata for more information.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#attributes_5","title":"Attributes:","text":"Attribute MLIR Type Description <code>name</code> ::mlir::StringAttr string attribute <code>value</code> ::mlir::Attribute buffer-like constant attribute values <code>alignment</code> ::mlir::IntegerAttr 64-bit signless integer attribute <code>mime_type</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/VM/#results_87","title":"Results:","text":"Result Description <code>result</code> ref"},{"location":"reference/mlir-dialects/VM/#vmrodata-vmrodataop","title":"<code>vm.rodata</code> (VM::RodataOp)","text":"<p>Read-only data definition operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.rodata` custom&lt;SymbolVisibility&gt;($sym_visibility) $sym_name attr-dict $value\n</code></pre> <p>Defines a blob of read-only constant data that can be represented as a ref. This can be used to store arbitrary data within modules such as large constant buffers and other file contents.</p> <p>Note that the data is reference counted as a way to track its usage once the value leaves the module. For example, returning rodata from an exported function must keep the data (possibly backed by mmap) valid for its entire lifetime.</p> <p>By default all rodata will be aligned in the final module output at a 16-byte granularity. An optional alignment can be specified to override the default for cases where larger or smaller alignments are needed.</p> <p>Traits: HasParent, IsolatedFromAbove <p>Interfaces: Symbol, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_6","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>value</code> ::mlir::Attribute buffer-like constant attribute values <code>alignment</code> ::mlir::IntegerAttr 64-bit signless integer attribute <code>ordinal</code> ::mlir::IntegerAttr ordinal value <code>mime_type</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/VM/#control-flow-ops","title":"Control flow ops","text":""},{"location":"reference/mlir-dialects/VM/#vmbr-vmbranchop","title":"<code>vm.br</code> (VM::BranchOp)","text":"<p>Unconditional branch operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.br` $dest (`(` $destOperands^ `:` type($destOperands) `)`)? attr-dict\n</code></pre> <p>Represents an unconditional branch operation that branches to a target block  with the given set of arguments.</p> <p><code>^bb0(...):    vm.br ^bb1(%a)  ^bb1(%blockArg1):    ...</code></p> <p>Traits: Terminator</p> <p>Interfaces: BranchOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_91","title":"Operands:","text":"Operand Description <code>destOperands</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#successors_1","title":"Successors:","text":"Successor Description <code>dest</code> any successor"},{"location":"reference/mlir-dialects/VM/#vmcall-vmcallop","title":"<code>vm.call</code> (VM::CallOp)","text":"<p>Call operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.call` $callee `(` operands `)` attr-dict `:` functional-type(operands, results)\n</code></pre> <p>Calls an internal VM function with the given arguments.</p> <p>Interfaces: CallOpInterface, MemoryEffectOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_7","title":"Attributes:","text":"Attribute MLIR Type Description <code>callee</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#operands_92","title":"Operands:","text":"Operand Description <code>operands</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#results_88","title":"Results:","text":"Result Description <code>results</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#vmcallvariadic-vmcallvariadicop","title":"<code>vm.call.variadic</code> (VM::CallVariadicOp)","text":"<p>Call operation with variadic arguments</p> <p>Calls an internal VM function with the given arguments. One or more of the arguments may be variadic, encoded as segmented sized operand lists.</p> <p>Variadic arguments must be specified with a total count in the segment_sizes attribute.</p> <p>Interfaces: CallOpInterface, MemoryEffectOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_8","title":"Attributes:","text":"Attribute MLIR Type Description <code>callee</code> FlatSymbolRefAttr symbol reference attribute <code>segment_sizes</code> ::mlir::DenseIntElementsAttr 16-bit signless integer elements attribute <code>segment_types</code> ::mlir::ArrayAttr type array attribute"},{"location":"reference/mlir-dialects/VM/#operands_93","title":"Operands:","text":"Operand Description <code>operands</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#results_89","title":"Results:","text":"Result Description <code>results</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#vmcheckeq-vmcheckeqop","title":"<code>vm.check.eq</code> (VM::CheckEQOp)","text":"<p>Raises a global failure if the condition is true</p> <p>Syntax:</p> <pre><code>operation ::= `vm.check.eq` $lhs `,` $rhs (`,` $message^)? attr-dict `:` type($lhs)\n</code></pre> <p>When the condition is true this signals a runtime failure that causes the entire active invocation - and possibly all in-flight and pending invocations - to fail. The status will be propagated back via the available runtime error handling mechanisms such as semaphores or synchronous invocation results.</p> <p>This is implemented as a pseudo-op that transforms into a vm.cond_fail operation.</p> <pre><code>vm.check.eq %a, %b, \"a == b\" : i32\nvm.check.nz %ref, \"!null\" : !vm.ref&lt;?&gt;\n</code></pre> <p>Traits: Commutative, VM_PseudoOp</p> <p>Interfaces: VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_9","title":"Attributes:","text":"Attribute MLIR Type Description <code>message</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/VM/#operands_94","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref <code>rhs</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#vmcheckne-vmcheckneop","title":"<code>vm.check.ne</code> (VM::CheckNEOp)","text":"<p>Raises a global failure if the condition is true</p> <p>Syntax:</p> <pre><code>operation ::= `vm.check.ne` $lhs `,` $rhs (`,` $message^)? attr-dict `:` type($lhs)\n</code></pre> <p>When the condition is true this signals a runtime failure that causes the entire active invocation - and possibly all in-flight and pending invocations - to fail. The status will be propagated back via the available runtime error handling mechanisms such as semaphores or synchronous invocation results.</p> <p>This is implemented as a pseudo-op that transforms into a vm.cond_fail operation.</p> <pre><code>vm.check.eq %a, %b, \"a == b\" : i32\nvm.check.nz %ref, \"!null\" : !vm.ref&lt;?&gt;\n</code></pre> <p>Traits: Commutative, VM_PseudoOp</p> <p>Interfaces: VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_10","title":"Attributes:","text":"Attribute MLIR Type Description <code>message</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/VM/#operands_95","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref <code>rhs</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#vmchecknz-vmchecknzop","title":"<code>vm.check.nz</code> (VM::CheckNZOp)","text":"<p>Raises a global failure if the condition is true</p> <p>Syntax:</p> <pre><code>operation ::= `vm.check.nz` $value (`,` $message^)? attr-dict `:` type($value)\n</code></pre> <p>When the condition is true this signals a runtime failure that causes the entire active invocation - and possibly all in-flight and pending invocations - to fail. The status will be propagated back via the available runtime error handling mechanisms such as semaphores or synchronous invocation results.</p> <p>This is implemented as a pseudo-op that transforms into a vm.cond_fail operation.</p> <pre><code>vm.check.eq %a, %b, \"a == b\" : i32\nvm.check.nz %ref, \"!null\" : !vm.ref&lt;?&gt;\n</code></pre> <p>Traits: VM_PseudoOp</p> <p>Interfaces: VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_11","title":"Attributes:","text":"Attribute MLIR Type Description <code>message</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/VM/#operands_96","title":"Operands:","text":"Operand Description <code>value</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#vmchecknearly_eq-vmchecknearlyeqop","title":"<code>vm.check.nearly_eq</code> (VM::CheckNearlyEQOp)","text":"<p>Raises a global failure if the condition is true</p> <p>Syntax:</p> <pre><code>operation ::= `vm.check.nearly_eq` $lhs `,` $rhs (`,` $message^)? attr-dict `:` type($lhs)\n</code></pre> <p>When the condition is true this signals a runtime failure that causes the entire active invocation - and possibly all in-flight and pending invocations - to fail. The status will be propagated back via the available runtime error handling mechanisms such as semaphores or synchronous invocation results.</p> <p>This is implemented as a pseudo-op that transforms into a vm.cond_fail operation.</p> <pre><code>vm.check.eq %a, %b, \"a == b\" : i32\nvm.check.nz %ref, \"!null\" : !vm.ref&lt;?&gt;\n</code></pre> <p>Traits: Commutative, VM_PseudoOp</p> <p>Interfaces: VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_12","title":"Attributes:","text":"Attribute MLIR Type Description <code>message</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/VM/#operands_97","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref <code>rhs</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#vmcond_br-vmcondbranchop","title":"<code>vm.cond_br</code> (VM::CondBranchOp)","text":"<p>Conditional branch operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cond_br` $condition `,`\n              $trueDest (`(` $trueDestOperands^ `:` type($trueDestOperands) `)`)? `,`\n              $falseDest (`(` $falseDestOperands^ `:` type($falseDestOperands) `)`)?\n              attr-dict\n</code></pre> <p>Represents a conditional branch operation that branches to one of the two  target blocks with the given set of arguments.</p> <p><code>^bb0(...):    vm.cond_br %condition, ^bb1(%a), ^bb2(%b)  ^bb1(%blockArg1):    ...  ^bb2(%blockArg2):    ...</code></p> <p>Traits: AttrSizedOperandSegments, Terminator</p> <p>Interfaces: BranchOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_98","title":"Operands:","text":"Operand Description <code>condition</code> 32-bit signless integer <code>trueDestOperands</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref <code>falseDestOperands</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#successors_2","title":"Successors:","text":"Successor Description <code>trueDest</code> any successor <code>falseDest</code> any successor"},{"location":"reference/mlir-dialects/VM/#vmcond_fail-vmcondfailop","title":"<code>vm.cond_fail</code> (VM::CondFailOp)","text":"<p>Raises a global failure if the condition is true</p> <p>When the condition is true this signals a runtime failure that causes the entire active invocation - and possibly all in-flight and pending invocations - to fail with the given status. The status will be propagated back via the available runtime error handling mechanisms such as semaphores or synchronous invocation results.</p> <p>As the IREE execution model is deeply pipelined it's possible that failures have a latency between when they are emitted and when the application can observe the failure. It's also possible that other work that is in-flight or pending when the failure occurs will complete.</p> <p>This is implemented as a pseudo-op that transforms into a vm.fail operation guarded by the condition.</p> <pre><code>%nz = vm.cmp.nz.i32 %value : i32\n%statusCode = vm.const.i32 9\nvm.cond_fail %nz, %statusCode, \"expected non-zero\"\n</code></pre> <p>Traits: VM_PseudoOp</p> <p>Interfaces: VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_13","title":"Attributes:","text":"Attribute MLIR Type Description <code>message</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/VM/#operands_99","title":"Operands:","text":"Operand Description <code>condition</code> 32-bit signless integer <code>status</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmfail-vmfailop","title":"<code>vm.fail</code> (VM::FailOp)","text":"<p>Raises a global failure</p> <p>Syntax:</p> <pre><code>operation ::= `vm.fail` $status (`,` $message^)? attr-dict\n</code></pre> <p>Signals a runtime failure that causes the entire active invocation - and possibly all in-flight and pending invocations - to fail with the given status. The status will be propagated back via the available runtime error handling mechanisms such as semaphores or synchronous invocation results.</p> <p>As the IREE execution model is deeply pipelined it's possible that failures have a latency between when they are emitted and when the application can observe the failure. It's also possible that other work that is in-flight or pending when the failure occurs will complete.</p> <pre><code>%statusCode = vm.const.i32 9\nvm.fail %statusCode, \"oh no!\"\n</code></pre> <p>Traits: Terminator</p> <p>Interfaces: VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_14","title":"Attributes:","text":"Attribute MLIR Type Description <code>message</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/VM/#operands_100","title":"Operands:","text":"Operand Description <code>status</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmimportresolved-vmimportresolvedop","title":"<code>vm.import.resolved</code> (VM::ImportResolvedOp)","text":"<p>Returns true if an optional import was resolved at runtime</p> <p>Syntax:</p> <pre><code>operation ::= `vm.import.resolved` $import attr-dict `:` type($result)\n</code></pre> <p>Allows for checking whether a optional import was resolved at runtime. If this returns false then attempting to call the imported function will result in a failure at runtime.</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#attributes_15","title":"Attributes:","text":"Attribute MLIR Type Description <code>import</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#results_90","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmreturn-vmreturnop","title":"<code>vm.return</code> (VM::ReturnOp)","text":"<p>Return operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.return` attr-dict ($operands^ `:` type($operands))?\n</code></pre> <p>Represents a return operation within a function.</p> <pre><code>vm.func @foo(%0: i32, %1: f8) -&gt; (i32, f8) {\n  vm.return %0, %1 : i32, f8\n}\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, ReturnLike, Terminator</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_101","title":"Operands:","text":"Operand Description <code>operands</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#debugging-ops","title":"Debugging ops","text":""},{"location":"reference/mlir-dialects/VM/#vmbreak-vmbreakop","title":"<code>vm.break</code> (VM::BreakOp)","text":"<p>Unconditional debug break operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.break` $dest (`(` $destOperands^ `:` type($destOperands) `)`)? attr-dict\n</code></pre> <p>Breaks into the attached debugger or asks for attaching a debugger. After resuming (or if a debugger is not attached) execution will continue at the target block.</p> <p>Traits: Terminator, Util_YieldPoint, VM_DebugOnly, VM_FullBarrier</p> <p>Interfaces: BranchOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_102","title":"Operands:","text":"Operand Description <code>destOperands</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#successors_3","title":"Successors:","text":"Successor Description <code>dest</code> any successor"},{"location":"reference/mlir-dialects/VM/#vmcond_break-vmcondbreakop","title":"<code>vm.cond_break</code> (VM::CondBreakOp)","text":"<p>Conditional debug break operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cond_break` $condition `,` $dest (`(` $destOperands^ `:` type($destOperands) `)`)?\n              attr-dict\n</code></pre> <p>Breaks into the attached debugger or asks for attaching a debugger if the provided condition is true. After resuming (or if a debugger is not attached) execution will continue at the target block.</p> <p>Traits: Terminator, Util_YieldPoint, VM_DebugOnly, VM_FullBarrier</p> <p>Interfaces: BranchOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_103","title":"Operands:","text":"Operand Description <code>condition</code> 32-bit signless integer <code>destOperands</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#successors_4","title":"Successors:","text":"Successor Description <code>dest</code> any successor"},{"location":"reference/mlir-dialects/VM/#vmprint-vmprintop","title":"<code>vm.print</code> (VM::PrintOp)","text":"<p>Message printing operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.print` $message `(` operands `)` attr-dict `:` type(operands)\n</code></pre> <p>Prints the given string message and zero or more values.</p> <p>Traits: VM_DebugOnly, VM_FullBarrier</p> <p>Interfaces: VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_16","title":"Attributes:","text":"Attribute MLIR Type Description <code>message</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/VM/#operands_104","title":"Operands:","text":"Operand Description <code>operands</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#vmtrace-vmtraceop","title":"<code>vm.trace</code> (VM::TraceOp)","text":"<p>Trace value(s) operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.trace` $event_name `(` operands `)` attr-dict `:` type(operands)\n</code></pre> <p>Traces one or more values at the time the operation is executed. These values will be encoded into the active trace depending on the active trace verbosity setting.</p> <p>Traits: VM_DebugOnly, VM_FullBarrier</p> <p>Interfaces: VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_17","title":"Attributes:","text":"Attribute MLIR Type Description <code>event_name</code> ::mlir::StringAttr string attribute"},{"location":"reference/mlir-dialects/VM/#operands_105","title":"Operands:","text":"Operand Description <code>operands</code> 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float or 32-bit signless integer or ref"},{"location":"reference/mlir-dialects/VM/#floating-point-arithmetic-ops","title":"Floating-point arithmetic ops","text":""},{"location":"reference/mlir-dialects/VM/#vmabsf32-vmabsf32op","title":"<code>vm.abs.f32</code> (VM::AbsF32Op)","text":"<p>Floating point absolute-value operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.abs.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_106","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_91","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmabsf64-vmabsf64op","title":"<code>vm.abs.f64</code> (VM::AbsF64Op)","text":"<p>Floating point absolute-value operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.abs.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_107","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_92","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmaddf32-vmaddf32op","title":"<code>vm.add.f32</code> (VM::AddF32Op)","text":"<p>Floating-point add operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.add.f32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_108","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_93","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmaddf64-vmaddf64op","title":"<code>vm.add.f64</code> (VM::AddF64Op)","text":"<p>Floating-point add operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.add.f64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_109","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_94","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmceilf32-vmceilf32op","title":"<code>vm.ceil.f32</code> (VM::CeilF32Op)","text":"<p>Floating point ceiling operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ceil.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_110","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_95","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmceilf64-vmceilf64op","title":"<code>vm.ceil.f64</code> (VM::CeilF64Op)","text":"<p>Floating point ceiling operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ceil.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_111","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_96","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmdivf32-vmdivf32op","title":"<code>vm.div.f32</code> (VM::DivF32Op)","text":"<p>Floating point division operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.div.f32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_112","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_97","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmdivf64-vmdivf64op","title":"<code>vm.div.f64</code> (VM::DivF64Op)","text":"<p>Floating point division operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.div.f64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_113","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_98","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmfmaf32-vmfmaf32op","title":"<code>vm.fma.f32</code> (VM::FMAF32Op)","text":"<p>Floating point fused multiply-add operation (a*b+c)</p> <p>Syntax:</p> <pre><code>operation ::= `vm.fma.f32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_114","title":"Operands:","text":"Operand Description <code>a</code> 32-bit float <code>b</code> 32-bit float <code>c</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_99","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmfmaf64-vmfmaf64op","title":"<code>vm.fma.f64</code> (VM::FMAF64Op)","text":"<p>Floating point fused multiply-add operation (a*b+c)</p> <p>Syntax:</p> <pre><code>operation ::= `vm.fma.f64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_115","title":"Operands:","text":"Operand Description <code>a</code> 64-bit float <code>b</code> 64-bit float <code>c</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_100","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmfloorf32-vmfloorf32op","title":"<code>vm.floor.f32</code> (VM::FloorF32Op)","text":"<p>Floating point floor operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.floor.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_116","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_101","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmfloorf64-vmfloorf64op","title":"<code>vm.floor.f64</code> (VM::FloorF64Op)","text":"<p>Floating point floor operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.floor.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_117","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_102","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmmaxf32-vmmaxf32op","title":"<code>vm.max.f32</code> (VM::MaxF32Op)","text":"<p>Floating point maximum operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.max.f32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_118","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_103","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmmaxf64-vmmaxf64op","title":"<code>vm.max.f64</code> (VM::MaxF64Op)","text":"<p>Floating point maximum operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.max.f64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_119","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_104","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmminf32-vmminf32op","title":"<code>vm.min.f32</code> (VM::MinF32Op)","text":"<p>Floating point minimum operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.min.f32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_120","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_105","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmminf64-vmminf64op","title":"<code>vm.min.f64</code> (VM::MinF64Op)","text":"<p>Floating point minimum operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.min.f64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_121","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_106","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmmulf32-vmmulf32op","title":"<code>vm.mul.f32</code> (VM::MulF32Op)","text":"<p>Floating point multiplication operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.mul.f32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_122","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_107","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmmulf64-vmmulf64op","title":"<code>vm.mul.f64</code> (VM::MulF64Op)","text":"<p>Floating point multiplication operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.mul.f64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_123","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_108","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmnegf32-vmnegf32op","title":"<code>vm.neg.f32</code> (VM::NegF32Op)","text":"<p>Floating point negation operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.neg.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_124","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_109","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmnegf64-vmnegf64op","title":"<code>vm.neg.f64</code> (VM::NegF64Op)","text":"<p>Floating point negation operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.neg.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_125","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_110","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmremf32-vmremf32op","title":"<code>vm.rem.f32</code> (VM::RemF32Op)","text":"<p>Floating point remainder operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.rem.f32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_126","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_111","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmremf64-vmremf64op","title":"<code>vm.rem.f64</code> (VM::RemF64Op)","text":"<p>Floating point remainder operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.rem.f64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_127","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_112","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmroundf32even-vmroundf32evenop","title":"<code>vm.round.f32.even</code> (VM::RoundF32EvenOp)","text":"<p>Rounds the value to the nearest even integer</p> <p>Syntax:</p> <pre><code>operation ::= `vm.round.f32.even` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_128","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_113","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmroundf32-vmroundf32op","title":"<code>vm.round.f32</code> (VM::RoundF32Op)","text":"<p>Rounds the value to the nearest integer away from zero</p> <p>Syntax:</p> <pre><code>operation ::= `vm.round.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_129","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_114","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmroundf64even-vmroundf64evenop","title":"<code>vm.round.f64.even</code> (VM::RoundF64EvenOp)","text":"<p>Rounds the value to the nearest even integer</p> <p>Syntax:</p> <pre><code>operation ::= `vm.round.f64.even` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_130","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_115","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmroundf64-vmroundf64op","title":"<code>vm.round.f64</code> (VM::RoundF64Op)","text":"<p>Rounds the value to the nearest integer away from zero</p> <p>Syntax:</p> <pre><code>operation ::= `vm.round.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_131","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_116","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmsubf32-vmsubf32op","title":"<code>vm.sub.f32</code> (VM::SubF32Op)","text":"<p>Floating point subtraction operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.sub.f32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_132","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_117","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmsubf64-vmsubf64op","title":"<code>vm.sub.f64</code> (VM::SubF64Op)","text":"<p>Floating point subtraction operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.sub.f64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_133","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_118","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#floating-point-comparison-ops","title":"Floating-point comparison ops","text":""},{"location":"reference/mlir-dialects/VM/#vmcmpeqf32near-vmcmpeqf32nearop","title":"<code>vm.cmp.eq.f32.near</code> (VM::CmpEQF32NearOp)","text":"<p>Near floating-point equality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.eq.f32.near` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF32, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_134","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_119","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpeqf32o-vmcmpeqf32oop","title":"<code>vm.cmp.eq.f32.o</code> (VM::CmpEQF32OOp)","text":"<p>Ordered floating-point equality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.eq.f32.o` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_135","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_120","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpeqf32u-vmcmpeqf32uop","title":"<code>vm.cmp.eq.f32.u</code> (VM::CmpEQF32UOp)","text":"<p>Unordered floating-point equality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.eq.f32.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_136","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_121","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpeqf64near-vmcmpeqf64nearop","title":"<code>vm.cmp.eq.f64.near</code> (VM::CmpEQF64NearOp)","text":"<p>Near floating-point equality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.eq.f64.near` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF64, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_137","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_122","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpeqf64o-vmcmpeqf64oop","title":"<code>vm.cmp.eq.f64.o</code> (VM::CmpEQF64OOp)","text":"<p>Ordered floating-point equality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.eq.f64.o` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_138","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_123","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpeqf64u-vmcmpeqf64uop","title":"<code>vm.cmp.eq.f64.u</code> (VM::CmpEQF64UOp)","text":"<p>Unordered floating-point equality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.eq.f64.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_139","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_124","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgtef32o-vmcmpgtef32oop","title":"<code>vm.cmp.gte.f32.o</code> (VM::CmpGTEF32OOp)","text":"<p>Ordered floating-point greater-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gte.f32.o` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_140","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_125","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgtef32u-vmcmpgtef32uop","title":"<code>vm.cmp.gte.f32.u</code> (VM::CmpGTEF32UOp)","text":"<p>Unordered floating-point greater-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gte.f32.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_141","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_126","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgtef64o-vmcmpgtef64oop","title":"<code>vm.cmp.gte.f64.o</code> (VM::CmpGTEF64OOp)","text":"<p>Ordered floating-point greater-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gte.f64.o` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_142","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_127","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgtef64u-vmcmpgtef64uop","title":"<code>vm.cmp.gte.f64.u</code> (VM::CmpGTEF64UOp)","text":"<p>Unordered floating-point greater-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gte.f64.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_143","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_128","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgtf32o-vmcmpgtf32oop","title":"<code>vm.cmp.gt.f32.o</code> (VM::CmpGTF32OOp)","text":"<p>Ordered floating-point greater-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gt.f32.o` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_144","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_129","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgtf32u-vmcmpgtf32uop","title":"<code>vm.cmp.gt.f32.u</code> (VM::CmpGTF32UOp)","text":"<p>Unordered floating-point greater-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gt.f32.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_145","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_130","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgtf64o-vmcmpgtf64oop","title":"<code>vm.cmp.gt.f64.o</code> (VM::CmpGTF64OOp)","text":"<p>Ordered floating-point greater-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gt.f64.o` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_146","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_131","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpgtf64u-vmcmpgtf64uop","title":"<code>vm.cmp.gt.f64.u</code> (VM::CmpGTF64UOp)","text":"<p>Unordered floating-point greater-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.gt.f64.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_147","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_132","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpltef32o-vmcmpltef32oop","title":"<code>vm.cmp.lte.f32.o</code> (VM::CmpLTEF32OOp)","text":"<p>Ordered floating-point less-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lte.f32.o` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_148","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_133","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpltef32u-vmcmpltef32uop","title":"<code>vm.cmp.lte.f32.u</code> (VM::CmpLTEF32UOp)","text":"<p>Unordered floating-point less-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lte.f32.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_149","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_134","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpltef64o-vmcmpltef64oop","title":"<code>vm.cmp.lte.f64.o</code> (VM::CmpLTEF64OOp)","text":"<p>Ordered floating-point less-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lte.f64.o` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_150","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_135","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpltef64u-vmcmpltef64uop","title":"<code>vm.cmp.lte.f64.u</code> (VM::CmpLTEF64UOp)","text":"<p>Unordered floating-point less-than-or-equal comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lte.f64.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_151","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_136","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpltf32o-vmcmpltf32oop","title":"<code>vm.cmp.lt.f32.o</code> (VM::CmpLTF32OOp)","text":"<p>Ordered floating-point less-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lt.f32.o` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_152","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_137","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpltf32u-vmcmpltf32uop","title":"<code>vm.cmp.lt.f32.u</code> (VM::CmpLTF32UOp)","text":"<p>Unordered floating-point less-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lt.f32.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_153","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_138","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpltf64o-vmcmpltf64oop","title":"<code>vm.cmp.lt.f64.o</code> (VM::CmpLTF64OOp)","text":"<p>Ordered floating-point less-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lt.f64.o` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_154","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_139","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpltf64u-vmcmpltf64uop","title":"<code>vm.cmp.lt.f64.u</code> (VM::CmpLTF64UOp)","text":"<p>Unordered floating-point less-than comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.lt.f64.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_155","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_140","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnef32o-vmcmpnef32oop","title":"<code>vm.cmp.ne.f32.o</code> (VM::CmpNEF32OOp)","text":"<p>Ordered floating-point inequality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.ne.f32.o` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_156","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_141","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnef32u-vmcmpnef32uop","title":"<code>vm.cmp.ne.f32.u</code> (VM::CmpNEF32UOp)","text":"<p>Unordered floating-point inequality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.ne.f32.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_157","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_142","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnef64o-vmcmpnef64oop","title":"<code>vm.cmp.ne.f64.o</code> (VM::CmpNEF64OOp)","text":"<p>Ordered floating-point inequality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.ne.f64.o` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_158","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_143","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnef64u-vmcmpnef64uop","title":"<code>vm.cmp.ne.f64.u</code> (VM::CmpNEF64UOp)","text":"<p>Unordered floating-point inequality comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.ne.f64.u` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_159","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_144","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnzf32o-vmcmpnzf32oop","title":"<code>vm.cmp.nz.f32.o</code> (VM::CmpNZF32OOp)","text":"<p>Ordered floating-point non-zero comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.nz.f32.o` operands attr-dict `:` type($operand)\n</code></pre> <p>Compares the given floating-point operand for a non-zero value.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_160","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_145","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnzf32u-vmcmpnzf32uop","title":"<code>vm.cmp.nz.f32.u</code> (VM::CmpNZF32UOp)","text":"<p>Unordered floating-point non-zero comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.nz.f32.u` operands attr-dict `:` type($operand)\n</code></pre> <p>Compares the given floating-point operand for a non-zero value.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_161","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_146","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnzf64o-vmcmpnzf64oop","title":"<code>vm.cmp.nz.f64.o</code> (VM::CmpNZF64OOp)","text":"<p>Ordered floating-point non-zero comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.nz.f64.o` operands attr-dict `:` type($operand)\n</code></pre> <p>Compares the given floating-point operand for a non-zero value.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_162","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_147","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnzf64u-vmcmpnzf64uop","title":"<code>vm.cmp.nz.f64.u</code> (VM::CmpNZF64UOp)","text":"<p>Unordered floating-point non-zero comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.nz.f64.u` operands attr-dict `:` type($operand)\n</code></pre> <p>Compares the given floating-point operand for a non-zero value.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64, VM_PseudoOp</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_163","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_148","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnanf32-vmcmpnanf32op","title":"<code>vm.cmp.nan.f32</code> (VM::CmpNaNF32Op)","text":"<p>Floating-point NaN comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.nan.f32` $operand attr-dict `:` type($operand)\n</code></pre> <p>Returns 1 if the value is NaN.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_164","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_149","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnanf64-vmcmpnanf64op","title":"<code>vm.cmp.nan.f64</code> (VM::CmpNaNF64Op)","text":"<p>Floating-point NaN comparison operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.nan.f64` $operand attr-dict `:` type($operand)\n</code></pre> <p>Returns 1 if the value is NaN.</p> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_165","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_150","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#floating-point-math-ops","title":"Floating-point math ops","text":"<p>These map directly to the <code>math</code> dialect.</p>"},{"location":"reference/mlir-dialects/VM/#vmatan2f32-vmatan2f32op","title":"<code>vm.atan2.f32</code> (VM::Atan2F32Op)","text":"<p>2-argument arcus tangent of the given values</p> <p>Syntax:</p> <pre><code>operation ::= `vm.atan2.f32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_166","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_151","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmatan2f64-vmatan2f64op","title":"<code>vm.atan2.f64</code> (VM::Atan2F64Op)","text":"<p>2-argument arcus tangent of the given values</p> <p>Syntax:</p> <pre><code>operation ::= `vm.atan2.f64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_167","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_152","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmatanf32-vmatanf32op","title":"<code>vm.atan.f32</code> (VM::AtanF32Op)","text":"<p>Arcus tangent of the given value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.atan.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_168","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_153","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmatanf64-vmatanf64op","title":"<code>vm.atan.f64</code> (VM::AtanF64Op)","text":"<p>Arcus tangent of the given value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.atan.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_169","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_154","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmcosf32-vmcosf32op","title":"<code>vm.cos.f32</code> (VM::CosF32Op)","text":"<p>Cosine of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cos.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_170","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_155","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmcosf64-vmcosf64op","title":"<code>vm.cos.f64</code> (VM::CosF64Op)","text":"<p>Cosine of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.cos.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_171","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_156","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmerff32-vmerff32op","title":"<code>vm.erf.f32</code> (VM::ErfF32Op)","text":"<p>Computes the error function of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.erf.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_172","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_157","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmerff64-vmerff64op","title":"<code>vm.erf.f64</code> (VM::ErfF64Op)","text":"<p>Computes the error function of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.erf.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_173","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_158","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmexp2f32-vmexp2f32op","title":"<code>vm.exp2.f32</code> (VM::Exp2F32Op)","text":"<p>Base-2 exponential of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.exp2.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_174","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_159","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmexp2f64-vmexp2f64op","title":"<code>vm.exp2.f64</code> (VM::Exp2F64Op)","text":"<p>Base-2 exponential of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.exp2.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_175","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_160","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmexpf32-vmexpf32op","title":"<code>vm.exp.f32</code> (VM::ExpF32Op)","text":"<p>Base-e exponential of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.exp.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_176","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_161","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmexpf64-vmexpf64op","title":"<code>vm.exp.f64</code> (VM::ExpF64Op)","text":"<p>Base-e exponential of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.exp.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_177","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_162","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmexpm1f32-vmexpm1f32op","title":"<code>vm.expm1.f32</code> (VM::ExpM1F32Op)","text":"<p>Base-e exponential of the specified value minus 1</p> <p>Syntax:</p> <pre><code>operation ::= `vm.expm1.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_178","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_163","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmexpm1f64-vmexpm1f64op","title":"<code>vm.expm1.f64</code> (VM::ExpM1F64Op)","text":"<p>Base-e exponential of the specified value minus 1</p> <p>Syntax:</p> <pre><code>operation ::= `vm.expm1.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_179","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_164","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmlog10f32-vmlog10f32op","title":"<code>vm.log10.f32</code> (VM::Log10F32Op)","text":"<p>Base-10 logarithm of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.log10.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_180","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_165","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmlog10f64-vmlog10f64op","title":"<code>vm.log10.f64</code> (VM::Log10F64Op)","text":"<p>Base-10 logarithm of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.log10.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_181","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_166","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmlog1pf32-vmlog1pf32op","title":"<code>vm.log1p.f32</code> (VM::Log1pF32Op)","text":"<p>Natural logarithm of one plus the given value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.log1p.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_182","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_167","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmlog1pf64-vmlog1pf64op","title":"<code>vm.log1p.f64</code> (VM::Log1pF64Op)","text":"<p>Natural logarithm of one plus the given value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.log1p.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_183","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_168","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmlog2f32-vmlog2f32op","title":"<code>vm.log2.f32</code> (VM::Log2F32Op)","text":"<p>Base-2 logarithm of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.log2.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_184","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_169","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmlog2f64-vmlog2f64op","title":"<code>vm.log2.f64</code> (VM::Log2F64Op)","text":"<p>Base-2 logarithm of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.log2.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_185","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_170","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmlogf32-vmlogf32op","title":"<code>vm.log.f32</code> (VM::LogF32Op)","text":"<p>Base-e logarithm of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.log.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_186","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_171","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmlogf64-vmlogf64op","title":"<code>vm.log.f64</code> (VM::LogF64Op)","text":"<p>Base-e logarithm of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.log.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_187","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_172","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmpowf32-vmpowf32op","title":"<code>vm.pow.f32</code> (VM::PowF32Op)","text":"<p>Floating point raised to the power of operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.pow.f32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_188","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit float <code>rhs</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_173","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmpowf64-vmpowf64op","title":"<code>vm.pow.f64</code> (VM::PowF64Op)","text":"<p>Floating point raised to the power of operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.pow.f64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_189","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit float <code>rhs</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_174","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmrsqrtf32-vmrsqrtf32op","title":"<code>vm.rsqrt.f32</code> (VM::RsqrtF32Op)","text":"<p>Reciprocal of sqrt (1 / sqrt of the specified value)</p> <p>Syntax:</p> <pre><code>operation ::= `vm.rsqrt.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_190","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_175","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmrsqrtf64-vmrsqrtf64op","title":"<code>vm.rsqrt.f64</code> (VM::RsqrtF64Op)","text":"<p>Reciprocal of sqrt (1 / sqrt of the specified value)</p> <p>Syntax:</p> <pre><code>operation ::= `vm.rsqrt.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_191","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_176","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmsinf32-vmsinf32op","title":"<code>vm.sin.f32</code> (VM::SinF32Op)","text":"<p>Sine of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.sin.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_192","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_177","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmsinf64-vmsinf64op","title":"<code>vm.sin.f64</code> (VM::SinF64Op)","text":"<p>Sine of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.sin.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_193","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_178","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmsqrtf32-vmsqrtf32op","title":"<code>vm.sqrt.f32</code> (VM::SqrtF32Op)","text":"<p>Sqrt of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.sqrt.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_194","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_179","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmsqrtf64-vmsqrtf64op","title":"<code>vm.sqrt.f64</code> (VM::SqrtF64Op)","text":"<p>Sqrt of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.sqrt.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_195","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_180","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmtanhf32-vmtanhf32op","title":"<code>vm.tanh.f32</code> (VM::TanhF32Op)","text":"<p>Hyperbolic tangent of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.tanh.f32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF32</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_196","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#results_181","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmtanhf64-vmtanhf64op","title":"<code>vm.tanh.f64</code> (VM::TanhF64Op)","text":"<p>Hyperbolic tangent of the specified value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.tanh.f64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, VM_ExtF64</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_197","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#results_182","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#global-ops","title":"Global ops","text":""},{"location":"reference/mlir-dialects/VM/#vmglobaladdress-vmglobaladdressop","title":"<code>vm.global.address</code> (VM::GlobalAddressOp)","text":"<p>Returns an address reference to a global</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.address` $global attr-dict `:` type($result)\n</code></pre> <p>Returns an indirect address reference to the given global. During export the address will be converted to the natural format of the global table (for example, ordinals for refs and byte offsets for primitive types).</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), SymbolUserOpInterface, Util_GlobalAddressOpInterface, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#attributes_18","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#results_183","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer or a pointer-like reference"},{"location":"reference/mlir-dialects/VM/#vmglobalf32-vmglobalf32op","title":"<code>vm.global.f32</code> (VM::GlobalF32Op)","text":"<p>32-bit floating-point global declaration</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.f32` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              (`mutable` $is_mutable^)?\n              $sym_name\n              attr-dict\n              custom&lt;TypeOrAttr&gt;($type, $initial_value)\n</code></pre> <p>Defines a global value that is treated as a scalar literal at runtime. Initialized to zero unless an initial value is specified.</p> <p>Traits: HasParent, IsolatedFromAbove, VM_ExtF32 <p>Interfaces: Symbol, Util_GlobalOpInterface, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_19","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>type</code> ::mlir::TypeAttr any type attribute <code>is_mutable</code> ::mlir::UnitAttr unit attribute <code>initial_value</code> FloatAttr 32-bit floating-point value <code>ordinal</code> ::mlir::IntegerAttr ordinal value"},{"location":"reference/mlir-dialects/VM/#vmglobalf64-vmglobalf64op","title":"<code>vm.global.f64</code> (VM::GlobalF64Op)","text":"<p>64-bit floating-point global declaration</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.f64` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              (`mutable` $is_mutable^)?\n              $sym_name\n              attr-dict\n              custom&lt;TypeOrAttr&gt;($type, $initial_value)\n</code></pre> <p>Defines a global value that is treated as a scalar literal at runtime. Initialized to zero unless an initial value is specified.</p> <p>Traits: HasParent, IsolatedFromAbove, VM_ExtF64 <p>Interfaces: Symbol, Util_GlobalOpInterface, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_20","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>type</code> ::mlir::TypeAttr any type attribute <code>is_mutable</code> ::mlir::UnitAttr unit attribute <code>initial_value</code> FloatAttr 64-bit floating-point value <code>ordinal</code> ::mlir::IntegerAttr ordinal value"},{"location":"reference/mlir-dialects/VM/#vmglobali32-vmglobali32op","title":"<code>vm.global.i32</code> (VM::GlobalI32Op)","text":"<p>32-bit integer global declaration</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.i32` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              (`mutable` $is_mutable^)?\n              $sym_name\n              attr-dict\n              custom&lt;TypeOrAttr&gt;($type, $initial_value)\n</code></pre> <p>Defines a global value that is treated as a scalar literal at runtime. Initialized to zero unless an initial value is specified.</p> <p>Traits: HasParent, IsolatedFromAbove <p>Interfaces: Symbol, Util_GlobalOpInterface, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_21","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>type</code> ::mlir::TypeAttr any type attribute <code>is_mutable</code> ::mlir::UnitAttr unit attribute <code>initial_value</code> IntegerAttr 32-bit integer value <code>ordinal</code> ::mlir::IntegerAttr ordinal value"},{"location":"reference/mlir-dialects/VM/#vmglobali64-vmglobali64op","title":"<code>vm.global.i64</code> (VM::GlobalI64Op)","text":"<p>64-bit integer global declaration</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.i64` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              (`mutable` $is_mutable^)?\n              $sym_name\n              attr-dict\n              custom&lt;TypeOrAttr&gt;($type, $initial_value)\n</code></pre> <p>Defines a global value that is treated as a scalar literal at runtime. Initialized to zero unless an initial value is specified.</p> <p>Traits: HasParent, IsolatedFromAbove <p>Interfaces: Symbol, Util_GlobalOpInterface, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_22","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>type</code> ::mlir::TypeAttr any type attribute <code>is_mutable</code> ::mlir::UnitAttr unit attribute <code>initial_value</code> IntegerAttr 64-bit integer value <code>ordinal</code> ::mlir::IntegerAttr ordinal value"},{"location":"reference/mlir-dialects/VM/#vmgloballoadf32-vmgloballoadf32op","title":"<code>vm.global.load.f32</code> (VM::GlobalLoadF32Op)","text":"<p>Global 32-bit floating-point load operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.load.f32` $global attr-dict `:` type($value)\n</code></pre> <p>Loads the value of a global containing an primitive value.</p> <p>Traits: VM_ExtF32</p> <p>Interfaces: MemoryEffectOpInterface, OpAsmOpInterface, SymbolUserOpInterface, Util_GlobalLoadOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_23","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#results_184","title":"Results:","text":"Result Description <code>value</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmgloballoadf64-vmgloballoadf64op","title":"<code>vm.global.load.f64</code> (VM::GlobalLoadF64Op)","text":"<p>Global 64-bit floating-point load operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.load.f64` $global attr-dict `:` type($value)\n</code></pre> <p>Loads the value of a global containing an primitive value.</p> <p>Traits: VM_ExtF64</p> <p>Interfaces: MemoryEffectOpInterface, OpAsmOpInterface, SymbolUserOpInterface, Util_GlobalLoadOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_24","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#results_185","title":"Results:","text":"Result Description <code>value</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmgloballoadi32-vmgloballoadi32op","title":"<code>vm.global.load.i32</code> (VM::GlobalLoadI32Op)","text":"<p>Global 32-bit integer load operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.load.i32` $global attr-dict `:` type($value)\n</code></pre> <p>Loads the value of a global containing an primitive value.</p> <p>Interfaces: MemoryEffectOpInterface, OpAsmOpInterface, SymbolUserOpInterface, Util_GlobalLoadOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_25","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#results_186","title":"Results:","text":"Result Description <code>value</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmgloballoadi64-vmgloballoadi64op","title":"<code>vm.global.load.i64</code> (VM::GlobalLoadI64Op)","text":"<p>Global 64-bit integer load operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.load.i64` $global attr-dict `:` type($value)\n</code></pre> <p>Loads the value of a global containing an primitive value.</p> <p>Interfaces: MemoryEffectOpInterface, OpAsmOpInterface, SymbolUserOpInterface, Util_GlobalLoadOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_26","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#results_187","title":"Results:","text":"Result Description <code>value</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmgloballoadindirectf32-vmgloballoadindirectf32op","title":"<code>vm.global.load.indirect.f32</code> (VM::GlobalLoadIndirectF32Op)","text":"<p>Global 32-bit floating-point load operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.load.indirect.f32` $global attr-dict `:` type($global) `-&gt;` type($value)\n</code></pre> <p>Loads the value of a global containing a primitive value.</p> <p>Traits: VM_ExtF64</p> <p>Interfaces: Util_GlobalLoadIndirectOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_198","title":"Operands:","text":"Operand Description <code>global</code> 32-bit signless integer or ptr&lt;32-bit float&gt;"},{"location":"reference/mlir-dialects/VM/#results_188","title":"Results:","text":"Result Description <code>value</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmgloballoadindirectf64-vmgloballoadindirectf64op","title":"<code>vm.global.load.indirect.f64</code> (VM::GlobalLoadIndirectF64Op)","text":"<p>Global 64-bit floating-point load operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.load.indirect.f64` $global attr-dict `:` type($global) `-&gt;` type($value)\n</code></pre> <p>Loads the value of a global containing a primitive value.</p> <p>Traits: VM_ExtF64</p> <p>Interfaces: Util_GlobalLoadIndirectOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_199","title":"Operands:","text":"Operand Description <code>global</code> 32-bit signless integer or ptr&lt;64-bit float&gt;"},{"location":"reference/mlir-dialects/VM/#results_189","title":"Results:","text":"Result Description <code>value</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmgloballoadindirecti32-vmgloballoadindirecti32op","title":"<code>vm.global.load.indirect.i32</code> (VM::GlobalLoadIndirectI32Op)","text":"<p>Global 32-bit integer load operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.load.indirect.i32` $global attr-dict `:` type($global) `-&gt;` type($value)\n</code></pre> <p>Loads the value of a global containing a primitive value.</p> <p>Interfaces: Util_GlobalLoadIndirectOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_200","title":"Operands:","text":"Operand Description <code>global</code> 32-bit signless integer or ptr&lt;32-bit signless integer&gt;"},{"location":"reference/mlir-dialects/VM/#results_190","title":"Results:","text":"Result Description <code>value</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmgloballoadindirecti64-vmgloballoadindirecti64op","title":"<code>vm.global.load.indirect.i64</code> (VM::GlobalLoadIndirectI64Op)","text":"<p>Global 64-bit integer load operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.load.indirect.i64` $global attr-dict `:` type($global) `-&gt;` type($value)\n</code></pre> <p>Loads the value of a global containing a primitive value.</p> <p>Interfaces: Util_GlobalLoadIndirectOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_201","title":"Operands:","text":"Operand Description <code>global</code> 32-bit signless integer or ptr&lt;64-bit signless integer&gt;"},{"location":"reference/mlir-dialects/VM/#results_191","title":"Results:","text":"Result Description <code>value</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmgloballoadindirectref-vmgloballoadindirectrefop","title":"<code>vm.global.load.indirect.ref</code> (VM::GlobalLoadIndirectRefOp)","text":"<p>Global ref load operation <p>Syntax:</p> <pre><code>operation ::= `vm.global.load.indirect.ref` $global attr-dict `:` type($global) `-&gt;` type($value)\n</code></pre> <p>Loads the value of a global containing a ref of the given type.</p> <p>Interfaces: Util_GlobalLoadIndirectOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_202","title":"Operands:","text":"Operand Description <code>global</code> 32-bit signless integer or ptr"},{"location":"reference/mlir-dialects/VM/#results_192","title":"Results:","text":"Result Description <code>value</code> ref"},{"location":"reference/mlir-dialects/VM/#vmgloballoadref-vmgloballoadrefop","title":"<code>vm.global.load.ref</code> (VM::GlobalLoadRefOp)","text":"<p>Global ref load operation <p>Syntax:</p> <pre><code>operation ::= `vm.global.load.ref` $global attr-dict `:` type($value)\n</code></pre> <p>Loads the value of a global containing a ref of the given type.</p> <p>Interfaces: MemoryEffectOpInterface, OpAsmOpInterface, SymbolUserOpInterface, Util_GlobalLoadOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_27","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#results_193","title":"Results:","text":"Result Description <code>value</code> ref"},{"location":"reference/mlir-dialects/VM/#vmglobalref-vmglobalrefop","title":"<code>vm.global.ref</code> (VM::GlobalRefOp)","text":"<p>Ref global declaration <p>Syntax:</p> <pre><code>operation ::= `vm.global.ref` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              (`mutable` $is_mutable^)?\n              $sym_name\n              attr-dict\n              `:` $type\n</code></pre> <p>Defines a global value that is a ref of a specific type. The global will retain the ref object for the lifetime of the context or until the value is replaced with a store or reset. Initialized to null unless an initial value is specified.</p> <p>Traits: HasParent, IsolatedFromAbove <p>Interfaces: GlobalOpInterface, Symbol, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_28","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>type</code> ::mlir::TypeAttr any type attribute <code>is_mutable</code> ::mlir::UnitAttr unit attribute <code>ordinal</code> ::mlir::IntegerAttr ordinal value"},{"location":"reference/mlir-dialects/VM/#vmglobalstoref32-vmglobalstoref32op","title":"<code>vm.global.store.f32</code> (VM::GlobalStoreF32Op)","text":"<p>Global 32-bit floating-point store operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.store.f32` $value `,` $global attr-dict `:` type($value)\n</code></pre> <p>Stores a primitive value value to a global.</p> <p>Traits: VM_ExtF32</p> <p>Interfaces: SymbolUserOpInterface, Util_GlobalStoreOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_29","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#operands_203","title":"Operands:","text":"Operand Description <code>value</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmglobalstoref64-vmglobalstoref64op","title":"<code>vm.global.store.f64</code> (VM::GlobalStoreF64Op)","text":"<p>Global 64-bit floating-point store operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.store.f64` $value `,` $global attr-dict `:` type($value)\n</code></pre> <p>Stores a primitive value value to a global.</p> <p>Traits: VM_ExtF64</p> <p>Interfaces: SymbolUserOpInterface, Util_GlobalStoreOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_30","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#operands_204","title":"Operands:","text":"Operand Description <code>value</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmglobalstorei32-vmglobalstorei32op","title":"<code>vm.global.store.i32</code> (VM::GlobalStoreI32Op)","text":"<p>Global 32-bit integer store operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.store.i32` $value `,` $global attr-dict `:` type($value)\n</code></pre> <p>Stores a primitive value value to a global.</p> <p>Interfaces: SymbolUserOpInterface, Util_GlobalStoreOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_31","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#operands_205","title":"Operands:","text":"Operand Description <code>value</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmglobalstorei64-vmglobalstorei64op","title":"<code>vm.global.store.i64</code> (VM::GlobalStoreI64Op)","text":"<p>Global 64-bit integer store operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.store.i64` $value `,` $global attr-dict `:` type($value)\n</code></pre> <p>Stores a primitive value value to a global.</p> <p>Interfaces: SymbolUserOpInterface, Util_GlobalStoreOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_32","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#operands_206","title":"Operands:","text":"Operand Description <code>value</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmglobalstoreindirectf32-vmglobalstoreindirectf32op","title":"<code>vm.global.store.indirect.f32</code> (VM::GlobalStoreIndirectF32Op)","text":"<p>Global 32-bit floating-point store operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.store.indirect.f32` $value `,` $global attr-dict `:` type($value) `-&gt;` type($global)\n</code></pre> <p>Stores a primitive value to a global.</p> <p>Traits: VM_ExtF32</p> <p>Interfaces: Util_GlobalStoreIndirectOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_207","title":"Operands:","text":"Operand Description <code>value</code> 32-bit float <code>global</code> 32-bit signless integer or ptr&lt;32-bit float&gt;"},{"location":"reference/mlir-dialects/VM/#vmglobalstoreindirectf64-vmglobalstoreindirectf64op","title":"<code>vm.global.store.indirect.f64</code> (VM::GlobalStoreIndirectF64Op)","text":"<p>Global 64-bit floating-point store operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.store.indirect.f64` $value `,` $global attr-dict `:` type($value) `-&gt;` type($global)\n</code></pre> <p>Stores a primitive value to a global.</p> <p>Traits: VM_ExtF64</p> <p>Interfaces: Util_GlobalStoreIndirectOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_208","title":"Operands:","text":"Operand Description <code>value</code> 64-bit float <code>global</code> 32-bit signless integer or ptr&lt;64-bit float&gt;"},{"location":"reference/mlir-dialects/VM/#vmglobalstoreindirecti32-vmglobalstoreindirecti32op","title":"<code>vm.global.store.indirect.i32</code> (VM::GlobalStoreIndirectI32Op)","text":"<p>Global 32-bit integer store operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.store.indirect.i32` $value `,` $global attr-dict `:` type($value) `-&gt;` type($global)\n</code></pre> <p>Stores a primitive value to a global.</p> <p>Interfaces: Util_GlobalStoreIndirectOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_209","title":"Operands:","text":"Operand Description <code>value</code> 32-bit signless integer <code>global</code> 32-bit signless integer or ptr&lt;32-bit signless integer&gt;"},{"location":"reference/mlir-dialects/VM/#vmglobalstoreindirecti64-vmglobalstoreindirecti64op","title":"<code>vm.global.store.indirect.i64</code> (VM::GlobalStoreIndirectI64Op)","text":"<p>Global 64-bit integer store operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.global.store.indirect.i64` $value `,` $global attr-dict `:` type($value) `-&gt;` type($global)\n</code></pre> <p>Stores a primitive value to a global.</p> <p>Interfaces: Util_GlobalStoreIndirectOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_210","title":"Operands:","text":"Operand Description <code>value</code> 64-bit signless integer <code>global</code> 32-bit signless integer or ptr&lt;64-bit signless integer&gt;"},{"location":"reference/mlir-dialects/VM/#vmglobalstoreindirectref-vmglobalstoreindirectrefop","title":"<code>vm.global.store.indirect.ref</code> (VM::GlobalStoreIndirectRefOp)","text":"<p>Global ref stores operation <p>Syntax:</p> <pre><code>operation ::= `vm.global.store.indirect.ref` $value `,` $global attr-dict `:` type($value) `-&gt;` type($global)\n</code></pre> <p>Stores a ref to a global, retaining it until the global is reset. <p>Interfaces: Util_GlobalStoreIndirectOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#operands_211","title":"Operands:","text":"Operand Description <code>value</code> ref <code>global</code> 32-bit signless integer or ptr"},{"location":"reference/mlir-dialects/VM/#vmglobalstoreref-vmglobalstorerefop","title":"<code>vm.global.store.ref</code> (VM::GlobalStoreRefOp)","text":"<p>Global ref stores operation <p>Syntax:</p> <pre><code>operation ::= `vm.global.store.ref` $value `,` $global attr-dict `:` type($value)\n</code></pre> <p>Stores a ref to a global, retaining it until the global is reset. <p>Interfaces: SymbolUserOpInterface, Util_GlobalStoreOpInterface, VMSerializableOp, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_33","title":"Attributes:","text":"Attribute MLIR Type Description <code>global</code> FlatSymbolRefAttr symbol reference attribute"},{"location":"reference/mlir-dialects/VM/#operands_212","title":"Operands:","text":"Operand Description <code>value</code> ref"},{"location":"reference/mlir-dialects/VM/#integer-arithmetic-ops","title":"Integer arithmetic ops","text":""},{"location":"reference/mlir-dialects/VM/#vmabsi32-vmabsi32op","title":"<code>vm.abs.i32</code> (VM::AbsI32Op)","text":"<p>Integer absolute-value operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.abs.i32` $operand attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_213","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_194","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmabsi64-vmabsi64op","title":"<code>vm.abs.i64</code> (VM::AbsI64Op)","text":"<p>Integer absolute-value operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.abs.i64` $operand attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_214","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_195","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmaddi32-vmaddi32op","title":"<code>vm.add.i32</code> (VM::AddI32Op)","text":"<p>Integer add operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.add.i32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: Commutative</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_215","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_196","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmaddi64-vmaddi64op","title":"<code>vm.add.i64</code> (VM::AddI64Op)","text":"<p>Integer add operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.add.i64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: Commutative</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_216","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_197","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmdivi32s-vmdivi32sop","title":"<code>vm.div.i32.s</code> (VM::DivI32SOp)","text":"<p>Signed integer division operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.div.i32.s` operands attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_217","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_198","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmdivi32u-vmdivi32uop","title":"<code>vm.div.i32.u</code> (VM::DivI32UOp)","text":"<p>Unsigned integer division operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.div.i32.u` operands attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_218","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_199","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmdivi64s-vmdivi64sop","title":"<code>vm.div.i64.s</code> (VM::DivI64SOp)","text":"<p>Signed integer division operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.div.i64.s` operands attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_219","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_200","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmdivi64u-vmdivi64uop","title":"<code>vm.div.i64.u</code> (VM::DivI64UOp)","text":"<p>Unsigned integer division operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.div.i64.u` operands attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_220","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_201","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmfmai32-vmfmai32op","title":"<code>vm.fma.i32</code> (VM::FMAI32Op)","text":"<p>Integer fused-multiply add operation (a*b+c)</p> <p>Syntax:</p> <pre><code>operation ::= `vm.fma.i32` operands attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_221","title":"Operands:","text":"Operand Description <code>a</code> 32-bit signless integer <code>b</code> 32-bit signless integer <code>c</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_202","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmfmai64-vmfmai64op","title":"<code>vm.fma.i64</code> (VM::FMAI64Op)","text":"<p>Integer fused-multiply add operation (a*b+c)</p> <p>Syntax:</p> <pre><code>operation ::= `vm.fma.i64` operands attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_222","title":"Operands:","text":"Operand Description <code>a</code> 64-bit signless integer <code>b</code> 64-bit signless integer <code>c</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_203","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmmaxi32s-vmmaxi32sop","title":"<code>vm.max.i32.s</code> (VM::MaxI32SOp)","text":"<p>Signed integer maximum operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.max.i32.s` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: Commutative</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_223","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_204","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmmaxi32u-vmmaxi32uop","title":"<code>vm.max.i32.u</code> (VM::MaxI32UOp)","text":"<p>Unsigned integer maximum operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.max.i32.u` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: Commutative</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_224","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_205","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmmaxi64s-vmmaxi64sop","title":"<code>vm.max.i64.s</code> (VM::MaxI64SOp)","text":"<p>Signed integer maximum operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.max.i64.s` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: Commutative</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_225","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_206","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmmaxi64u-vmmaxi64uop","title":"<code>vm.max.i64.u</code> (VM::MaxI64UOp)","text":"<p>Unsigned integer maximum operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.max.i64.u` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: Commutative</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_226","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_207","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmmini32s-vmmini32sop","title":"<code>vm.min.i32.s</code> (VM::MinI32SOp)","text":"<p>Signed integer minimum operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.min.i32.s` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: Commutative</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_227","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_208","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmmini32u-vmmini32uop","title":"<code>vm.min.i32.u</code> (VM::MinI32UOp)","text":"<p>Unsigned integer minimum operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.min.i32.u` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: Commutative</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_228","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_209","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmmini64s-vmmini64sop","title":"<code>vm.min.i64.s</code> (VM::MinI64SOp)","text":"<p>Signed integer minimum operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.min.i64.s` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: Commutative</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_229","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_210","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmmini64u-vmmini64uop","title":"<code>vm.min.i64.u</code> (VM::MinI64UOp)","text":"<p>Unsigned integer minimum operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.min.i64.u` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: Commutative</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_230","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_211","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmmuli32-vmmuli32op","title":"<code>vm.mul.i32</code> (VM::MulI32Op)","text":"<p>Integer multiplication operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.mul.i32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: Commutative</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_231","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_212","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmmuli64-vmmuli64op","title":"<code>vm.mul.i64</code> (VM::MulI64Op)","text":"<p>Integer multiplication operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.mul.i64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: Commutative</p> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_232","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_213","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmremi32s-vmremi32sop","title":"<code>vm.rem.i32.s</code> (VM::RemI32SOp)","text":"<p>Signed integer division remainder operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.rem.i32.s` operands attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_233","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_214","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmremi32u-vmremi32uop","title":"<code>vm.rem.i32.u</code> (VM::RemI32UOp)","text":"<p>Unsigned integer division remainder operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.rem.i32.u` operands attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_234","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_215","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmremi64s-vmremi64sop","title":"<code>vm.rem.i64.s</code> (VM::RemI64SOp)","text":"<p>Signed integer division remainder operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.rem.i64.s` operands attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_235","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_216","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmremi64u-vmremi64uop","title":"<code>vm.rem.i64.u</code> (VM::RemI64UOp)","text":"<p>Unsigned integer division remainder operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.rem.i64.u` operands attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_236","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_217","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmsubi32-vmsubi32op","title":"<code>vm.sub.i32</code> (VM::SubI32Op)","text":"<p>Integer subtract operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.sub.i32` operands attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_237","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_218","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmsubi64-vmsubi64op","title":"<code>vm.sub.i64</code> (VM::SubI64Op)","text":"<p>Integer subtract operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.sub.i64` operands attr-dict `:` type($result)\n</code></pre> <p>Interfaces: NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_238","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_219","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#integer-bit-manipulation-ops","title":"Integer bit manipulation ops","text":""},{"location":"reference/mlir-dialects/VM/#vmandi32-vmandi32op","title":"<code>vm.and.i32</code> (VM::AndI32Op)","text":"<p>Integer binary and operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.and.i32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_239","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_220","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmandi64-vmandi64op","title":"<code>vm.and.i64</code> (VM::AndI64Op)","text":"<p>Integer binary and operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.and.i64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_240","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_221","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmctlzi32-vmctlzi32op","title":"<code>vm.ctlz.i32</code> (VM::CtlzI32Op)","text":"<p>Counts the leading zeros in an integer value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ctlz.i32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_241","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_222","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmctlzi64-vmctlzi64op","title":"<code>vm.ctlz.i64</code> (VM::CtlzI64Op)","text":"<p>Counts the leading zeros in an integer value</p> <p>Syntax:</p> <pre><code>operation ::= `vm.ctlz.i64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_242","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_223","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmnoti32-vmnoti32op","title":"<code>vm.not.i32</code> (VM::NotI32Op)","text":"<p>Integer binary not operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.not.i32` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_243","title":"Operands:","text":"Operand Description <code>operand</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_224","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmnoti64-vmnoti64op","title":"<code>vm.not.i64</code> (VM::NotI64Op)","text":"<p>Integer binary not operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.not.i64` $operand attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_244","title":"Operands:","text":"Operand Description <code>operand</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_225","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmori32-vmori32op","title":"<code>vm.or.i32</code> (VM::OrI32Op)","text":"<p>Integer binary or operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.or.i32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_245","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_226","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmori64-vmori64op","title":"<code>vm.or.i64</code> (VM::OrI64Op)","text":"<p>Integer binary or operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.or.i64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_246","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_227","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmxori32-vmxori32op","title":"<code>vm.xor.i32</code> (VM::XorI32Op)","text":"<p>Integer binary exclusive-or operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.xor.i32` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_247","title":"Operands:","text":"Operand Description <code>lhs</code> 32-bit signless integer <code>rhs</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_228","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmxori64-vmxori64op","title":"<code>vm.xor.i64</code> (VM::XorI64Op)","text":"<p>Integer binary exclusive-or operation</p> <p>Syntax:</p> <pre><code>operation ::= `vm.xor.i64` operands attr-dict `:` type($result)\n</code></pre> <p>Traits: AlwaysSpeculatableImplTrait, Commutative</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_248","title":"Operands:","text":"Operand Description <code>lhs</code> 64-bit signless integer <code>rhs</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_229","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#list-ops","title":"List ops","text":""},{"location":"reference/mlir-dialects/VM/#vmlistalloc-vmlistallocop","title":"<code>vm.list.alloc</code> (VM::ListAllocOp)","text":"<p>Allocates a new empty list</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.alloc` operands attr-dict `:` `(` type($initial_capacity) `)` `-&gt;` type($result)\n</code></pre> <p>Allocates a new typed list with a minimum initial_capacity.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_249","title":"Operands:","text":"Operand Description <code>initial_capacity</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_230","title":"Results:","text":"Result Description <code>result</code> list"},{"location":"reference/mlir-dialects/VM/#vmlistgetf32-vmlistgetf32op","title":"<code>vm.list.get.f32</code> (VM::ListGetF32Op)","text":"<p>Primitive type element accessor</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.get.f32` operands attr-dict `:` `(` type($list) `,` type($index) `)` `-&gt;` type($result)\n</code></pre> <p>Returns the value of the element at the given index.</p> <p>Traits: VM_ExtF32</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_250","title":"Operands:","text":"Operand Description <code>list</code> list&lt;8/16/32/64-bit integer or 16/32/64-bit float&gt; <code>index</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_231","title":"Results:","text":"Result Description <code>result</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmlistgetf64-vmlistgetf64op","title":"<code>vm.list.get.f64</code> (VM::ListGetF64Op)","text":"<p>Primitive type element accessor</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.get.f64` operands attr-dict `:` `(` type($list) `,` type($index) `)` `-&gt;` type($result)\n</code></pre> <p>Returns the value of the element at the given index.</p> <p>Traits: VM_ExtF64</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_251","title":"Operands:","text":"Operand Description <code>list</code> list&lt;8/16/32/64-bit integer or 16/32/64-bit float&gt; <code>index</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_232","title":"Results:","text":"Result Description <code>result</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmlistgeti32-vmlistgeti32op","title":"<code>vm.list.get.i32</code> (VM::ListGetI32Op)","text":"<p>Primitive type element accessor</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.get.i32` operands attr-dict `:` `(` type($list) `,` type($index) `)` `-&gt;` type($result)\n</code></pre> <p>Returns the value of the element at the given index.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_252","title":"Operands:","text":"Operand Description <code>list</code> list&lt;8/16/32/64-bit integer or 16/32/64-bit float&gt; <code>index</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_233","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmlistgeti64-vmlistgeti64op","title":"<code>vm.list.get.i64</code> (VM::ListGetI64Op)","text":"<p>Primitive type element accessor</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.get.i64` operands attr-dict `:` `(` type($list) `,` type($index) `)` `-&gt;` type($result)\n</code></pre> <p>Returns the value of the element at the given index.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_253","title":"Operands:","text":"Operand Description <code>list</code> list&lt;8/16/32/64-bit integer or 16/32/64-bit float&gt; <code>index</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_234","title":"Results:","text":"Result Description <code>result</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmlistgetref-vmlistgetrefop","title":"<code>vm.list.get.ref</code> (VM::ListGetRefOp)","text":"<p>Ref type element accessor</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.get.ref` operands attr-dict `:` `(` type($list) `,` type($index) `)` `-&gt;` type($result)\n</code></pre> <p>Returns the ref value of the element at the given index. Note that the value may be null if the element is null or the type does not match.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_254","title":"Operands:","text":"Operand Description <code>list</code> list <code>index</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#results_235","title":"Results:","text":"Result Description <code>result</code> ref"},{"location":"reference/mlir-dialects/VM/#vmlistreserve-vmlistreserveop","title":"<code>vm.list.reserve</code> (VM::ListReserveOp)","text":"<p>Reserves capacity for list growth</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.reserve` operands attr-dict `:` `(` type($list) `,` type($minimum_capacity) `)`\n</code></pre> <p>Reserves storage for at least minimum_capacity elements. If the list already has at least the specified capacity the operation is ignored.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Allocate on ::mlir::SideEffects::DefaultResource, MemoryEffects::Read on ::mlir::SideEffects::DefaultResource, MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_255","title":"Operands:","text":"Operand Description <code>list</code> list <code>minimum_capacity</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmlistresize-vmlistresizeop","title":"<code>vm.list.resize</code> (VM::ListResizeOp)","text":"<p>Resizes the list to a new count in elements</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.resize` operands attr-dict `:` `(` type($list) `,` type($new_size) `)`\n</code></pre> <p>Resizes the list to contain new_size elements. This will either truncate the list if the existing size is greater than new_size or extend the list with the default list value of 0 if storing primitives and null if refs.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_256","title":"Operands:","text":"Operand Description <code>list</code> list <code>new_size</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmlistsetf32-vmlistsetf32op","title":"<code>vm.list.set.f32</code> (VM::ListSetF32Op)","text":"<p>Primitive type element mutator</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.set.f32` operands attr-dict `:` `(` type($list) `,` type($index) `,` type($value) `)`\n</code></pre> <p>Sets the element at the given index to the new value.</p> <p>Traits: VM_ExtF32</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_257","title":"Operands:","text":"Operand Description <code>list</code> list&lt;8/16/32/64-bit integer or 16/32/64-bit float&gt; <code>index</code> 32-bit signless integer <code>value</code> 32-bit float"},{"location":"reference/mlir-dialects/VM/#vmlistsetf64-vmlistsetf64op","title":"<code>vm.list.set.f64</code> (VM::ListSetF64Op)","text":"<p>Primitive type element mutator</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.set.f64` operands attr-dict `:` `(` type($list) `,` type($index) `,` type($value) `)`\n</code></pre> <p>Sets the element at the given index to the new value.</p> <p>Traits: VM_ExtF64</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_258","title":"Operands:","text":"Operand Description <code>list</code> list&lt;8/16/32/64-bit integer or 16/32/64-bit float&gt; <code>index</code> 32-bit signless integer <code>value</code> 64-bit float"},{"location":"reference/mlir-dialects/VM/#vmlistseti32-vmlistseti32op","title":"<code>vm.list.set.i32</code> (VM::ListSetI32Op)","text":"<p>Primitive type element mutator</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.set.i32` operands attr-dict `:` `(` type($list) `,` type($index) `,` type($value) `)`\n</code></pre> <p>Sets the element at the given index to the new value.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_259","title":"Operands:","text":"Operand Description <code>list</code> list&lt;8/16/32/64-bit integer or 16/32/64-bit float&gt; <code>index</code> 32-bit signless integer <code>value</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmlistseti64-vmlistseti64op","title":"<code>vm.list.set.i64</code> (VM::ListSetI64Op)","text":"<p>Primitive type element mutator</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.set.i64` operands attr-dict `:` `(` type($list) `,` type($index) `,` type($value) `)`\n</code></pre> <p>Sets the element at the given index to the new value.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_260","title":"Operands:","text":"Operand Description <code>list</code> list&lt;8/16/32/64-bit integer or 16/32/64-bit float&gt; <code>index</code> 32-bit signless integer <code>value</code> 64-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmlistsetref-vmlistsetrefop","title":"<code>vm.list.set.ref</code> (VM::ListSetRefOp)","text":"<p>Ref type element mutator</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.set.ref` operands attr-dict `:` `(` type($list) `,` type($index) `,` type($value) `)`\n</code></pre> <p>Sets the element at the given index to the new ref value (possibly null).</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Write on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_261","title":"Operands:","text":"Operand Description <code>list</code> list <code>index</code> 32-bit signless integer <code>value</code> ref"},{"location":"reference/mlir-dialects/VM/#vmlistsize-vmlistsizeop","title":"<code>vm.list.size</code> (VM::ListSizeOp)","text":"<p>The size of the list in elements</p> <p>Syntax:</p> <pre><code>operation ::= `vm.list.size` operands attr-dict `:` `(` type($list) `)` `-&gt;` type($result)\n</code></pre> <p>Returns the current size of the list in elements.</p> <p>Interfaces: MemoryEffectOpInterface (MemoryEffectOpInterface), VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{MemoryEffects::Read on ::mlir::SideEffects::DefaultResource}</p>"},{"location":"reference/mlir-dialects/VM/#operands_262","title":"Operands:","text":"Operand Description <code>list</code> list"},{"location":"reference/mlir-dialects/VM/#results_236","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#ref-comparison-ops","title":"Ref comparison ops","text":"<p>Comparison ops for <code>vm.ref</code>.</p>"},{"location":"reference/mlir-dialects/VM/#vmcmpeqref-vmcmpeqrefop","title":"<code>vm.cmp.eq.ref</code> (VM::CmpEQRefOp)","text":"<p>Ref equality comparison operation <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.eq.ref` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_263","title":"Operands:","text":"Operand Description <code>lhs</code> ref <code>rhs</code> ref"},{"location":"reference/mlir-dialects/VM/#results_237","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpneref-vmcmpnerefop","title":"<code>vm.cmp.ne.ref</code> (VM::CmpNERefOp)","text":"<p>Ref inequality comparison operation <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.ne.ref` operands attr-dict `:` type($lhs)\n</code></pre> <p>Compares two operands with the specified predicate.</p> <p>Traits: AlwaysSpeculatableImplTrait, Commutative</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_264","title":"Operands:","text":"Operand Description <code>lhs</code> ref <code>rhs</code> ref"},{"location":"reference/mlir-dialects/VM/#results_238","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#vmcmpnzref-vmcmpnzrefop","title":"<code>vm.cmp.nz.ref</code> (VM::CmpNZRefOp)","text":"<p>Ref non-zero comparison operation <p>Syntax:</p> <pre><code>operation ::= `vm.cmp.nz.ref` $operand attr-dict `:` type($operand)\n</code></pre> <p>Compares the given ref operand for a non-zero/null value.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface), OpAsmOpInterface, VMSerializableOp, VM_OpInterface</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VM/#operands_265","title":"Operands:","text":"Operand Description <code>operand</code> ref"},{"location":"reference/mlir-dialects/VM/#results_239","title":"Results:","text":"Result Description <code>result</code> 32-bit signless integer"},{"location":"reference/mlir-dialects/VM/#structural-ops","title":"Structural ops","text":""},{"location":"reference/mlir-dialects/VM/#vmexport-vmexportop","title":"<code>vm.export</code> (VM::ExportOp)","text":"<p>Exports a function from the module</p> <p>Specifies an exported function with an externally-visible alias. Multiple exports can reference the same internal functions.</p> <p>Interfaces: SymbolUserOpInterface, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_34","title":"Attributes:","text":"Attribute MLIR Type Description <code>function_ref</code> ::mlir::FlatSymbolRefAttr flat symbol reference attribute <code>export_name</code> ::mlir::StringAttr string attribute <code>ordinal</code> ::mlir::IntegerAttr ordinal value"},{"location":"reference/mlir-dialects/VM/#vmfunc-vmfuncop","title":"<code>vm.func</code> (VM::FuncOp)","text":"<p>Function defined with VM control flow ops</p> <p>Represents a function containing VM ops and those of compatible dialects. All flow control is performed by VM ops.</p> <p>Traits: HasParent, IsolatedFromAbove <p>Interfaces: CallableOpInterface, FunctionOpInterface, Symbol, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_35","title":"Attributes:","text":"Attribute MLIR Type Description <code>function_type</code> ::mlir::TypeAttr type attribute of function type <code>ordinal</code> ::mlir::IntegerAttr ordinal value <code>noinline</code> ::mlir::UnitAttr unit attribute <code>arg_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes <code>res_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes"},{"location":"reference/mlir-dialects/VM/#vmimport-vmimportop","title":"<code>vm.import</code> (VM::ImportOp)","text":"<p>Imports a function from an external module</p> <p>Specifies a function that should be imported from either the runtime or an external VM module.</p> <p>Required imports can be declared with a minimum version of the module that contains the import. The maximum declared minimum version of all required imports from the module will become the required minimum version at runtime.</p> <p>Optional imports not present at runtime will be invalid to call and whether they were resolved can be queried with <code>vm.import.resolved</code>.</p> <p>Interfaces: CallableOpInterface, FunctionOpInterface, Symbol, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_36","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_name</code> ::mlir::StringAttr string attribute <code>function_type</code> ::mlir::TypeAttr type attribute of function type <code>arg_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes <code>res_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>ordinal</code> ::mlir::IntegerAttr ordinal value <code>is_optional</code> ::mlir::UnitAttr unit attribute <code>minimum_version</code> ::mlir::IntegerAttr 32-bit signless integer attribute"},{"location":"reference/mlir-dialects/VM/#vminitializer-vminitializerop","title":"<code>vm.initializer</code> (VM::InitializerOp)","text":"<p>Global initialization function</p> <p>A function that is called in definition order upon module initialization. Must not load any globals that are defined or initialized after it in the module.</p> <p>Traits: HasParent, IsolatedFromAbove <p>Interfaces: CallableOpInterface, FunctionOpInterface, Symbol, Util_InitializerOpInterface, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_37","title":"Attributes:","text":"Attribute MLIR Type Description <code>function_type</code> ::mlir::TypeAttr type attribute of function type <code>arg_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes <code>res_attrs</code> ::mlir::ArrayAttr Array of dictionary attributes"},{"location":"reference/mlir-dialects/VM/#vmmodule-vmmoduleop","title":"<code>vm.module</code> (VM::ModuleOp)","text":"<p>Module containing VM functions and variables</p> <p>Syntax:</p> <pre><code>operation ::= `vm.module` custom&lt;SymbolVisibility&gt;($sym_visibility)\n              $sym_name\n              attr-dict-with-keyword\n              regions\n</code></pre> <p>Top-level container for VM functions.</p> <p>Traits: IsolatedFromAbove, SingleBlockImplicitTerminator, SymbolTable <p>Interfaces: Symbol, VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attributes_38","title":"Attributes:","text":"Attribute MLIR Type Description <code>sym_visibility</code> ::mlir::StringAttr string attribute <code>sym_name</code> ::mlir::StringAttr string attribute <code>ordinal_counts</code> ::mlir::iree_compiler::IREE::VM::OrdinalCountsAttr <code>version</code> ::mlir::IntegerAttr 32-bit signless integer attribute"},{"location":"reference/mlir-dialects/VM/#vmmodule_terminator-vmmoduleterminatorop","title":"<code>vm.module_terminator</code> (VM::ModuleTerminatorOp)","text":"<p>Terminator pseudo-op for the module op</p> <p>Syntax:</p> <pre><code>operation ::= `vm.module_terminator` attr-dict\n</code></pre> <p>Traits: HasParent, Terminator <p>Interfaces: VM_OpInterface</p>"},{"location":"reference/mlir-dialects/VM/#attribute-definition","title":"Attribute definition","text":""},{"location":"reference/mlir-dialects/VM/#ordinalcountsattr","title":"OrdinalCountsAttr","text":"<p>Syntax:</p> <pre><code>#vm.ordinal_counts&lt;\n  int32_t,   # import_funcs\n  int32_t,   # export_funcs\n  int32_t,   # internal_funcs\n  int32_t,   # global_bytes\n  int32_t,   # global_refs\n  int32_t,   # rodatas\n  int32_t   # rwdatas\n&gt;\n</code></pre>"},{"location":"reference/mlir-dialects/VM/#parameters","title":"Parameters:","text":"Parameter C++ type Description import_funcs <code>int32_t</code> export_funcs <code>int32_t</code> internal_funcs <code>int32_t</code> global_bytes <code>int32_t</code> global_refs <code>int32_t</code> rodatas <code>int32_t</code> rwdatas <code>int32_t</code>"},{"location":"reference/mlir-dialects/VMVX/","title":"VMVX","text":""},{"location":"reference/mlir-dialects/VMVX/#vmvx-dialect","title":"'vmvx' Dialect","text":"<p>Vector extensions to the IREE VM.</p> <p>This is a reference dialect representing a simple IREE VM-based linear algebra module that is used as a library at runtime. The ops in this dialect map (roughly) 1:1 with the exported functions in the runtime module.</p> <p>See <code>vmvx.imports.mlir</code> for the full list of exported functions.</p> <ul> <li>'vmvx' Dialect<ul> <li>Operation definition<ul> <li>ABI ops<ul> <li>vmvx.binary (VMVX::BinaryOp)</li> <li>vmvx.copy (VMVX::CopyOp)</li> <li>vmvx.fill2d (VMVX::Fill2DOp)</li> <li>vmvx.unary (VMVX::UnaryOp)</li> </ul> </li> <li>Utility ops<ul> <li>vmvx.get_buffer_descriptor (VMVX::GetBufferDescriptorOp)</li> <li>vmvx.get_raw_interface_binding_buffer (VMVX::GetRawInterfaceBindingBufferOp)</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/mlir-dialects/VMVX/#operation-definition","title":"Operation definition","text":""},{"location":"reference/mlir-dialects/VMVX/#abi-ops","title":"ABI ops","text":""},{"location":"reference/mlir-dialects/VMVX/#vmvxbinary-vmvxbinaryop","title":"<code>vmvx.binary</code> (VMVX::BinaryOp)","text":"<p>Performs a strided elementwise operation on two same-rank buffers</p> <p>Syntax:</p> <pre><code>operation ::= `vmvx.binary` `op` `` `(` $opcode `:` $element_type `)`\n              `lhs` `` `(` $lhs_buffer `offset` $lhs_offset `strides` `[` $lhs_strides `]` `:` type($lhs_buffer) `)`\n              `rhs` `` `(` $rhs_buffer `offset` $rhs_offset `strides` `[` $rhs_strides `]` `:` type($rhs_buffer) `)`\n              `out` `` `(` $out_buffer `offset` $out_offset `strides` `[` $out_strides `]` `:` type($out_buffer) `)`\n              `sizes` `` `(` $sizes `)`\n              attr-dict\n</code></pre> <p>Performs the operation in-place as if: <pre><code>  OUT = OP(LHS, RHS)\n</code></pre></p> <p>Where <code>OP</code> is a concrete operation name as defined in ukernel/elementwise.h</p> <p>Traits: SameVariadicOperandSize</p>"},{"location":"reference/mlir-dialects/VMVX/#attributes","title":"Attributes:","text":"Attribute MLIR Type Description <code>opcode</code> ::mlir::StringAttr string attribute <code>element_type</code> ::mlir::TypeAttr type attribute of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float"},{"location":"reference/mlir-dialects/VMVX/#operands","title":"Operands:","text":"Operand Description <code>lhs_buffer</code> a reference counted byte buffer <code>lhs_offset</code> index <code>lhs_strides</code> index <code>rhs_buffer</code> a reference counted byte buffer <code>rhs_offset</code> index <code>rhs_strides</code> index <code>out_buffer</code> a reference counted byte buffer <code>out_offset</code> index <code>out_strides</code> index <code>sizes</code> index"},{"location":"reference/mlir-dialects/VMVX/#vmvxcopy-vmvxcopyop","title":"<code>vmvx.copy</code> (VMVX::CopyOp)","text":"<p>Copy from one buffer to another</p> <p>Syntax:</p> <pre><code>operation ::= `vmvx.copy` `in` `` `(` $in_buffer `offset` $in_offset `strides` `[` $in_strides `]` `:` type($in_buffer) `)`\n              `out` `` `(` $out_buffer `offset` $out_offset `strides` `[` $out_strides `]` `:` type($out_buffer) `)`\n              `sizes` `` `(` $sizes `)`\n              `:` $element_type\n              attr-dict\n</code></pre> <p>Traits: SameVariadicOperandSize</p>"},{"location":"reference/mlir-dialects/VMVX/#attributes_1","title":"Attributes:","text":"Attribute MLIR Type Description <code>element_type</code> ::mlir::TypeAttr type attribute of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float"},{"location":"reference/mlir-dialects/VMVX/#operands_1","title":"Operands:","text":"Operand Description <code>in_buffer</code> a reference counted byte buffer <code>in_offset</code> index <code>in_strides</code> index <code>out_buffer</code> a reference counted byte buffer <code>out_offset</code> index <code>out_strides</code> index <code>sizes</code> index"},{"location":"reference/mlir-dialects/VMVX/#vmvxfill2d-vmvxfill2dop","title":"<code>vmvx.fill2d</code> (VMVX::Fill2DOp)","text":"<p>Fill a tile with a scalar</p> <p>Syntax:</p> <pre><code>operation ::= `vmvx.fill2d` `scalar` `` `(` $scalar `:` type($scalar) `)`\n              `out` `` `(` $out_buffer `offset` $out_offset `row_stride` $out_row_stride `:` type($out_buffer) `)`\n              `sizes` `` `(` $m `,` $n `)`\n              attr-dict\n</code></pre> <p>Fills a tile with dimensions [m, n] with a scalar.</p>"},{"location":"reference/mlir-dialects/VMVX/#operands_2","title":"Operands:","text":"Operand Description <code>scalar</code> 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float <code>out_buffer</code> a reference counted byte buffer <code>out_offset</code> index <code>out_row_stride</code> index <code>m</code> index <code>n</code> index"},{"location":"reference/mlir-dialects/VMVX/#vmvxunary-vmvxunaryop","title":"<code>vmvx.unary</code> (VMVX::UnaryOp)","text":"<p>Performs a strided elementwise unary operation</p> <p>Syntax:</p> <pre><code>operation ::= `vmvx.unary` `op` `` `(` $opcode `:` $element_type `)`\n              `in` `` `(` $in_buffer `offset` $in_offset `strides` `[` $in_strides `]` `:` type($in_buffer) `)`\n              `out` `` `(` $out_buffer `offset` $out_offset `strides` `[` $out_strides `]` `:` type($out_buffer) `)`\n              `sizes` `` `(` $sizes `)`\n              attr-dict\n</code></pre> <p>Performs the operation in-place as if: <pre><code>  OUT = OP(IN)\n</code></pre></p> <p>Where <code>OP</code> is a concrete operation name as defined in ukernel/elementwise.h</p> <p>Traits: SameVariadicOperandSize</p>"},{"location":"reference/mlir-dialects/VMVX/#attributes_2","title":"Attributes:","text":"Attribute MLIR Type Description <code>opcode</code> ::mlir::StringAttr string attribute <code>element_type</code> ::mlir::TypeAttr type attribute of 8-bit signless integer or 16-bit signless integer or 32-bit signless integer or 64-bit signless integer or 32-bit float or 64-bit float"},{"location":"reference/mlir-dialects/VMVX/#operands_3","title":"Operands:","text":"Operand Description <code>in_buffer</code> a reference counted byte buffer <code>in_offset</code> index <code>in_strides</code> index <code>out_buffer</code> a reference counted byte buffer <code>out_offset</code> index <code>out_strides</code> index <code>sizes</code> index"},{"location":"reference/mlir-dialects/VMVX/#utility-ops","title":"Utility ops","text":""},{"location":"reference/mlir-dialects/VMVX/#vmvxget_buffer_descriptor-vmvxgetbufferdescriptorop","title":"<code>vmvx.get_buffer_descriptor</code> (VMVX::GetBufferDescriptorOp)","text":"<p>Late binds a base buffer/offset/strides</p> <p>Syntax:</p> <pre><code>operation ::= `vmvx.get_buffer_descriptor` $source `:` type($source) `-&gt;` type(results) attr-dict\n</code></pre> <p>Queries a base buffer, offset and strides. This op is late bound to its source (alloca, binding, etc), allowing additional layers of transformations to be added as lowering progresses (or for buffers to be combined).</p> <p>This op has canonicalization rules which will bubble it up through the view stack. A final reconciliation pass is used explicitly to bind it to concrete sources.</p> <p>Traits: AlwaysSpeculatableImplTrait, SameVariadicResultSize</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VMVX/#operands_4","title":"Operands:","text":"Operand Description <code>source</code> memref of any type values"},{"location":"reference/mlir-dialects/VMVX/#results","title":"Results:","text":"Result Description <code>base_buffer</code> a reference counted byte buffer <code>offset</code> index <code>sizes</code> index <code>strides</code> index"},{"location":"reference/mlir-dialects/VMVX/#vmvxget_raw_interface_binding_buffer-vmvxgetrawinterfacebindingbufferop","title":"<code>vmvx.get_raw_interface_binding_buffer</code> (VMVX::GetRawInterfaceBindingBufferOp)","text":"<p>Gets the raw buffer associated with a binding</p> <p>Syntax:</p> <pre><code>operation ::= `vmvx.get_raw_interface_binding_buffer` `set` `(` $set `)` `binding` `(` $binding `)` attr-dict\n</code></pre> <p>Normally, a slice of a binding buffer is returned via hal.interface.binding.subspan. However, the normal VMVX lowering flow for this presumes that the result is a memref, and upon final conversion, it will offset the memref automatically to make it consistent.</p> <p>This op is used in situations where earlier in a lowering, we have fully resolved the binding to a buffer and would just like the raw backing buffer as passed to the interface.</p> <p>Traits: AlwaysSpeculatableImplTrait</p> <p>Interfaces: ConditionallySpeculatable, NoMemoryEffect (MemoryEffectOpInterface)</p> <p>Effects: MemoryEffects::Effect{}</p>"},{"location":"reference/mlir-dialects/VMVX/#attributes_3","title":"Attributes:","text":"Attribute MLIR Type Description <code>set</code> ::mlir::IntegerAttr index attribute <code>binding</code> ::mlir::IntegerAttr index attribute"},{"location":"reference/mlir-dialects/VMVX/#results_1","title":"Results:","text":"Result Description <code>buffer</code> a reference counted byte buffer"}]}